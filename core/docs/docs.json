{"name":"core","dependencies":[],"components":[{"description":"<p>A React portal for the body.</p>\n","name":"Html.Portals.Body","connects":[],"computed-properties":[],"properties":[{"default":"[]","type":"Array(Html)","description":"<p>The children to render into the portal</p>\n","name":"children"}],"functions":[{"type":"Html","description":"<p>Renders the children into the document's body.</p>\n","name":"render","source":"/* Renders the children into the document's body. */\nfun render : Html {\n  `_createPortal(#{children}, document.body)`\n}","arguments":[]}],"providers":[],"states":[]},{"description":"<p>A React portal for the head.</p>\n","name":"Html.Portals.Head","connects":[],"computed-properties":[],"properties":[{"default":"[]","type":"Array(Html)","description":"<p>The children to render into the portal</p>\n","name":"children"}],"functions":[{"type":"Html","description":"<p>Renders the children into the document's head.</p>\n","name":"render","source":"/* Renders the children into the document's head. */\nfun render : Html {\n  `_createPortal(#{children}, document.head)`\n}","arguments":[]}],"providers":[],"states":[]},{"description":"<p>Renders the children if the given condition is true.</p>\n","name":"If","connects":[],"computed-properties":[],"properties":[{"default":"[]","type":"Array(Html)","description":"<p>The children to render.</p>\n","name":"children"},{"default":"true","type":"Bool","description":"<p>The condition.</p>\n","name":"condition"}],"functions":[{"type":"Array(Html)","description":null,"name":"render","source":"fun render : Array(Html) {\n  if condition {\n    children\n  } else {\n    []\n  }\n}","arguments":[]}],"providers":[],"states":[]},{"description":"<p>Renders the children if the given condition is false.</p>\n","name":"Unless","connects":[],"computed-properties":[],"properties":[{"default":"[]","type":"Array(Html)","description":"<p>The children to render.</p>\n","name":"children"},{"default":"true","type":"Bool","description":"<p>The condition.</p>\n","name":"condition"}],"functions":[{"type":"Array(Html)","description":null,"name":"render","source":"fun render : Array(Html) {\n  if !condition {\n    children\n  } else {\n    []\n  }\n}","arguments":[]}],"providers":[],"states":[]}],"stores":[{"name":"Console.Counter","description":null,"states":[{"type":"Map(String, Number)","description":null,"default":"Map.empty()","name":"counts"}],"computed-properties":[],"functions":[{"type":null,"description":null,"name":"increment","source":"fun increment (label : String = \"Default\") {\n  next\n    {\n      counts:\n        case Map.has(counts, label) {\n          false => Map.set(counts, label, 1)\n          => Map.set(counts, label, Map.getWithDefault(counts, label, 0) + 1)\n        }\n    }\n}","arguments":[{"type":"String","name":"label"}]},{"type":null,"description":null,"name":"clear","source":"fun clear (label : String = \"Default\") {\n  next { counts: Map.set(counts, label, 0) }\n}","arguments":[{"type":"String","name":"label"}]},{"type":"Number","description":null,"name":"get","source":"fun get (label : String = \"Default\") : Number {\n  Map.getWithDefault(counts, label, 0)\n}","arguments":[{"type":"String","name":"label"}]}]}],"modules":[{"description":null,"name":"AnimationFrame","functions":[{"type":"Number","description":"<p>Cancels a scheduled function call.</p>\n<pre><code>AnimationFrame.cancel(id)\n</code></pre>\n","name":"cancel","source":"/*\nCancels a scheduled function call.\n\n  AnimationFrame.cancel(id)\n*/\nfun cancel (id : Number) : Number {\n  `cancelAnimationFrame(#{id}) || -1`\n}","arguments":[{"type":"Number","name":"id"}]},{"type":"Number","description":"<p>Schedules the function to run on the next frame, and returns its ID.</p>\n<pre><code>id = AnimationFrame.request((timestamp : Number) { Debug.log(&quot;Hello&quot;) })\n</code></pre>\n","name":"request","source":"/*\nSchedules the function to run on the next frame, and returns its ID.\n\n  id = AnimationFrame.request((timestamp : Number) { Debug.log(\"Hello\") })\n*/\nfun request (function : Function(Number, a)) : Number {\n  `requestAnimationFrame(#{function})`\n}","arguments":[{"type":"Function(Number, a)","name":"function"}]}]},{"description":null,"name":"Array","functions":[{"type":"Bool","description":"<p>Returns <code>true</code> if any item in the array matches the predicate function\n<code>false</code> otherwise.</p>\n<pre><code>Array.any([1, 2, 3, 4], (number : Number) : Bool { number % 2 == 0 }) == true\nArray.any([1, 3], (number : Number) : Bool { number % 2 == 0 }) == false\n</code></pre>\n","name":"any","source":"/*\nReturns `true` if any item in the array matches the predicate function\n`false` otherwise.\n\n  Array.any([1, 2, 3, 4], (number : Number) : Bool { number % 2 == 0 }) == true\n  Array.any([1, 3], (number : Number) : Bool { number % 2 == 0 }) == false\n*/\nfun any (array : Array(item), function : Function(item, Bool)) : Bool {\n  case Array.find(array, function) {\n    Maybe.Nothing => false\n    Maybe.Just => true\n  }\n}","arguments":[{"type":"Array(item)","name":"array"},{"type":"Function(item, Bool)","name":"function"}]},{"type":"Array(item)","description":"<p>Merges two arrays together into a new one.</p>\n<pre><code>Array.append([1, 1, 2] [3, 5, 8]) == [1, 1, 2, 3, 5, 8]\n</code></pre>\n","name":"append","source":"/*\nMerges two arrays together into a new one.\n\n  Array.append([1, 1, 2] [3, 5, 8]) == [1, 1, 2, 3, 5, 8]\n*/\nfun append (array1 : Array(item), array2 : Array(item)) : Array(item) {\n  `[].concat(#{array1}).concat(#{array2})`\n}","arguments":[{"type":"Array(item)","name":"array1"},{"type":"Array(item)","name":"array2"}]},{"type":"Maybe(item)","description":"<p>Returns the element at the given index as a <code>Maybe(item)</code>.</p>\n<pre><code>Array.at([0], 0) == Maybe::Just(0)\nArray.at([0], 1) == Maybe::Nothing()\n</code></pre>\n","name":"at","source":"/*\nReturns the element at the given index as a `Maybe(item)`.\n\n  Array.at([0], 0) == Maybe::Just(0)\n  Array.at([0], 1) == Maybe::Nothing()\n*/\nfun at (array : Array(item), index : Number) : Maybe(item) {\n  array[index]\n}","arguments":[{"type":"Array(item)","name":"array"},{"type":"Number","name":"index"}]},{"type":"Array(item)","description":"<p>Flattens an <code>Array(Maybe(item))</code> into an <code>Array(item)</code>, by unwrapping the\nitems and skipping all elements of <code>Maybe::Nothing</code>.</p>\n<pre><code>Array.compact([Maybe::Just(&quot;A&quot;), Maybe::Nothing()]) == [&quot;A&quot;]\n</code></pre>\n","name":"compact","source":"/*\nFlattens an `Array(Maybe(item))` into an `Array(item)`, by unwrapping the\nitems and skipping all elements of `Maybe::Nothing`.\n\n  Array.compact([Maybe::Just(\"A\"), Maybe::Nothing()]) == [\"A\"]\n*/\nfun compact (array : Array(Maybe(item))) : Array(item) {\n  Array.reduce(\n    array, \n    [], \n    (memo : Array(item), item : Maybe(item)) : Array(item) {\n      case item {\n        Maybe.Just(value) => Array.push(memo, value)\n        Maybe.Nothing => memo\n      }\n    })\n}","arguments":[{"type":"Array(Maybe(item))","name":"array"}]},{"type":"Array(item)","description":"<p>Concatenate multiple arrays into a single array.</p>\n<pre><code>Array.concat([[1,2],[3],[4,5]]) == [1,2,3,4,5]\n</code></pre>\n","name":"concat","source":"/*\nConcatenate multiple arrays into a single array.\n\n  Array.concat([[1,2],[3],[4,5]]) == [1,2,3,4,5]\n*/\nfun concat (arrays : Array(Array(item))) : Array(item) {\n  reduce(arrays, [], append)\n}","arguments":[{"type":"Array(Array(item))","name":"arrays"}]},{"type":"Bool","description":"<p>Checks whether or not the given element exists in the array.</p>\n<pre><code>Array.contains([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], &quot;a&quot;) == true\nArray.contains([&quot;x&quot;, &quot;y&quot;, &quot;z&quot;], &quot;a&quot;) == false\n</code></pre>\n","name":"contains","source":"/*\nChecks whether or not the given element exists in the array.\n\n  Array.contains([\"a\", \"b\", \"c\"], \"a\") == true\n  Array.contains([\"x\", \"y\", \"z\"], \"a\") == false\n*/\nfun contains (array : Array(item), other : item) : Bool {\n  `\n    (() => {\n      for (let item of #{array}) {\n        if (_compare(#{other}, item)) {\n          return true\n        }\n      }\n\n      return false\n    })()\n    `\n}","arguments":[{"type":"Array(item)","name":"array"},{"type":"item","name":"other"}]},{"type":"Array(item)","description":"<p>Deletes every occurrence of the element from the array.</p>\n<pre><code>Array.delete([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], &quot;a&quot;) == [&quot;b&quot;, &quot;c&quot;]\n</code></pre>\n","name":"delete","source":"/*\nDeletes every occurrence of the element from the array.\n\n  Array.delete([\"a\", \"b\", \"c\"], \"a\") == [\"b\", \"c\"]\n*/\nfun delete (array : Array(item), what : item) : Array(item) {\n  reject(array, (item : item) { item == what })\n}","arguments":[{"type":"Array(item)","name":"array"},{"type":"item","name":"what"}]},{"type":"Array(item)","description":"<p>Deletes the item of an array at the specified index.</p>\n<pre><code>Array.deleteAt([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], 1) == [&quot;a&quot;, &quot;c&quot;]\n</code></pre>\n","name":"deleteAt","source":"/*\nDeletes the item of an array at the specified index.\n\n  Array.deleteAt([\"a\", \"b\", \"c\"], 1) == [\"a\", \"c\"]\n*/\nfun deleteAt (array : Array(item), index : Number) : Array(item) {\n  `\n    (() => {\n      if (#{index} < 0 || #{index} >= #{array}.length) { return #{array} }\n      const result = Array.from(#{array})\n      result.splice(#{index}, 1)\n      return result\n    })()\n    `\n}","arguments":[{"type":"Array(item)","name":"array"},{"type":"Number","name":"index"}]},{"type":"Array(item)","description":"<p>Drop the specified number of items from the end of the array.</p>\n<pre><code>Array.dropEnd([1, 2, 3, 4], 2) == [1, 2]\n</code></pre>\n","name":"dropEnd","source":"/*\nDrop the specified number of items from the end of the array.\n\n  Array.dropEnd([1, 2, 3, 4], 2) == [1, 2]\n*/\nfun dropEnd (array : Array(item), number : Number) : Array(item) {\n  `\n    (() => {\n      if (#{number} < 0) { return #{array} }\n      return #{array}.slice(0, -#{number})\n    })()\n    `\n}","arguments":[{"type":"Array(item)","name":"array"},{"type":"Number","name":"number"}]},{"type":"Array(item)","description":"<p>Drop the specified number of items from the start of the array.</p>\n<pre><code>Array.dropStart([1, 2, 3, 4], 2) == [3, 4]\n</code></pre>\n","name":"dropStart","source":"/*\nDrop the specified number of items from the start of the array.\n\n  Array.dropStart([1, 2, 3, 4], 2) == [3, 4]\n*/\nfun dropStart (array : Array(item), number : Number) : Array(item) {\n  `#{array}.slice(#{number})`\n}","arguments":[{"type":"Array(item)","name":"array"},{"type":"Number","name":"number"}]},{"type":"Maybe(item)","description":"<p>Finds the first element in the array that matches the predicate function.</p>\n<pre><code>Array.find([1, 2, 3, 4], (number : Number) { number % 2 == 0 }) == Maybe::Just(2)\n</code></pre>\n","name":"find","source":"/*\nFinds the first element in the array that matches the predicate function.\n\n  Array.find([1, 2, 3, 4], (number : Number) { number % 2 == 0 }) == Maybe::Just(2)\n*/\nfun find (array : Array(item), function : Function(item, Bool)) : Maybe(item) {\n  Array.first(\n    for item of array {\n      item\n    } when {\n      function(item)\n    })\n}","arguments":[{"type":"Array(item)","name":"array"},{"type":"Function(item, Bool)","name":"function"}]},{"type":"Maybe(b)","description":"<p>Finds the first element in the array that matches the predicate function and\nreturns the second item in the resulting tuple.</p>\n<pre><code>Array.findByAndMap(\n  [1, 2, 3, 4],\n  (number : Number) : (Bool, value) { {number % 2 == 0, &quot;Two&quot;} }\n) == Maybe::Just(&quot;Two&quot;)\n</code></pre>\n","name":"findByAndMap","source":"/*\nFinds the first element in the array that matches the predicate function and\nreturns the second item in the resulting tuple.\n\n  Array.findByAndMap(\n    [1, 2, 3, 4],\n    (number : Number) : (Bool, value) { {number % 2 == 0, \"Two\"} }\n  ) == Maybe::Just(\"Two\")\n*/\nfun findByAndMap (\n  array : Array(item),\n  function : Function(item, Tuple(Bool, result))\n) : Maybe(b) {\n  `\n    (() => {\n      for (let item of #{array}) {\n        const [found, value] = #{function}(item)\n\n        if (found) {\n          return #{Maybe::Just(`value`)}\n        }\n      }\n\n      return #{Maybe::Nothing}\n    })()\n    `\n}","arguments":[{"type":"Array(item)","name":"array"},{"type":"Function(item, Tuple(Bool, result))","name":"function"}]},{"type":"Maybe(item)","description":"<p>Returns the first element of the array as <code>Maybe::Just(item)</code> or\n<code>Maybe::Nothing</code>.</p>\n<pre><code>Array.first([&quot;a&quot;, &quot;x&quot;]) == Maybe::Just(&quot;a&quot;)\nArray.first([]) == Maybe::Nothing\n</code></pre>\n","name":"first","source":"/*\nReturns the first element of the array as `Maybe::Just(item)` or\n`Maybe::Nothing`.\n\n  Array.first([\"a\", \"x\"]) == Maybe::Just(\"a\")\n  Array.first([]) == Maybe::Nothing\n*/\nfun first (array : Array(item)) : Maybe(item) {\n  array[0]\n}","arguments":[{"type":"Array(item)","name":"array"}]},{"type":"item","description":"<p>Returns the first element of the array or the default value.</p>\n<pre><code>Array.firstWithDefault([&quot;b&quot;, &quot;x&quot;], &quot;a&quot;) == &quot;b&quot;\nArray.firstWithDefault([], &quot;a&quot;) == &quot;a&quot;\n</code></pre>\n","name":"firstWithDefault","source":"/*\nReturns the first element of the array or the default value.\n\n  Array.firstWithDefault([\"b\", \"x\"], \"a\") == \"b\"\n  Array.firstWithDefault([], \"a\") == \"a\"\n*/\nfun firstWithDefault (array : Array(item), item : item) : item {\n  array[0] or item\n}","arguments":[{"type":"Array(item)","name":"array"},{"type":"item","name":"item"}]},{"type":"Array(result)","description":"<p>Map over a nested array and then flatten.</p>\n<pre><code>Array.flatMap(\n  [[1,2],[1,5]],\n  (item : Array(Number) : Array(Maybe(Number)) {\n    [Maybe.withDefault(Array.max(item), 0)]\n  }) == [2,5]\n</code></pre>\n","name":"flatMap","source":"/*\nMap over a nested array and then flatten.\n\n  Array.flatMap(\n    [[1,2],[1,5]],\n    (item : Array(Number) : Array(Maybe(Number)) {\n      [Maybe.withDefault(Array.max(item), 0)]\n    }) == [2,5]\n*/\nfun flatMap (\n  array : Array(Array(item)),\n  function : Function(Array(item), Array(result))\n) : Array(result) {\n  concat(map(array, function))\n}","arguments":[{"type":"Array(Array(item))","name":"array"},{"type":"Function(Array(item), Array(result))","name":"function"}]},{"type":"Array(Array(item))","description":"<p>Group an array into sub groups of specified length (all items are included so\nthe last group maybe shorter if after grouping there is a remainder)</p>\n<pre><code>Array.groupsOf([1,2,3,4,5,6,7], 2) == [[1,2],[3,4],[5,6],[7]]\n</code></pre>\n","name":"groupsOf","source":"/*\nGroup an array into sub groups of specified length (all items are included so\nthe last group maybe shorter if after grouping there is a remainder)\n\n  Array.groupsOf([1,2,3,4,5,6,7], 2) == [[1,2],[3,4],[5,6],[7]]\n*/\nfun groupsOf (array : Array(item), size : Number) : Array(Array(item)) {\n  `\n    (() => {\n      const groups = Math.ceil(#{array}.length/#{size})\n      const result = []\n\n      let lowerLimit = 0\n\n      for (var $0 = 0; $0 < groups; $0++) {\n        lowerLimit = $0 * #{size};\n        result.push(#{array}.slice(lowerLimit, lowerLimit + #{size}))\n      }\n\n      return result;\n    })()\n    `\n}","arguments":[{"type":"Array(item)","name":"array"},{"type":"Number","name":"size"}]},{"type":"Array(Array(item))","description":"<p>Group an array into sub groups of specified length (all items are included so\nthe last group maybe shorter if after grouping there is a remainder) starting\nfrom the end of the array.</p>\n<pre><code>Array.groupsOfFromEnd([1,2,3,4,5,6,7], 2) == [[1],[2,3],[4,5],[6,7]]\n</code></pre>\n","name":"groupsOfFromEnd","source":"/*\nGroup an array into sub groups of specified length (all items are included so\nthe last group maybe shorter if after grouping there is a remainder) starting\nfrom the end of the array.\n\n  Array.groupsOfFromEnd([1,2,3,4,5,6,7], 2) == [[1],[2,3],[4,5],[6,7]]\n*/\nfun groupsOfFromEnd (array : Array(item), size : Number) : Array(Array(item)) {\n  `\n    (() => {\n      const groups = Math.ceil(#{array}.length / #{size})\n      const result = []\n\n      let lowerLimit = 0\n\n      #{array} =\n        Array.from(#{array}).reverse()\n\n      for (var $0 = 0; $0 < groups; $0++) {\n        lowerLimit = $0 * #{size};\n        result.unshift(#{array}.slice(lowerLimit, lowerLimit +  #{size}).reverse())\n      }\n\n      return result;\n    })()\n    `\n}","arguments":[{"type":"Array(item)","name":"array"},{"type":"Number","name":"size"}]},{"type":"Number","description":"<p>Returns the index of the item in the array which matches the value\nusing the function to generate the compared value.</p>\n<pre><code>Array.indexBy([&quot;a&quot;,&quot;b&quot;,&quot;c&quot;], &quot;a&quot;, (item : String) : String { item }) == 0\n</code></pre>\n","name":"indexBy","source":"/*\nReturns the index of the item in the array which matches the value\nusing the function to generate the compared value.\n\n  Array.indexBy([\"a\",\"b\",\"c\"], \"a\", (item : String) : String { item }) == 0\n*/\nfun indexBy (\n  array : Array(item),\n  value : result,\n  method : Function(item, result)\n) : Number {\n  `\n    (() => {\n      for (let index = 0; index < #{array}.length; index++) {\n        if (_compare(#{value}, #{method}(#{array}[index]))) {\n          return index\n        }\n      }\n\n      return -1\n    })()\n    `\n}","arguments":[{"type":"Array(item)","name":"array"},{"type":"result","name":"value"},{"type":"Function(item, result)","name":"method"}]},{"type":"Maybe(Number)","description":"<p>Returns the index of the specified item in the array.</p>\n<pre><code>Array.indexOf([&quot;a&quot;,&quot;b&quot;,&quot;c&quot;], &quot;a&quot;) == 0\n</code></pre>\n","name":"indexOf","source":"/*\nReturns the index of the specified item in the array.\n\n  Array.indexOf([\"a\",\"b\",\"c\"], \"a\") == 0\n*/\nfun indexOf (array : Array(item), search : item) : Maybe(Number) {\n  for item, index of array {\n    index\n  } when {\n    item == search\n  }[0]\n}","arguments":[{"type":"Array(item)","name":"array"},{"type":"item","name":"search"}]},{"type":"Array(item)","description":"<p>Inserts the item into the specified position of the array, pushing items\ntoward the end of the array. If the length is negative the item will be\ninserted at the start of the array.</p>\n<pre><code>Array.insertAt([&quot;b&quot;,&quot;c&quot;], &quot;a&quot;, 0) == [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]\n</code></pre>\n","name":"insertAt","source":"/*\nInserts the item into the specified position of the array, pushing items\ntoward the end of the array. If the length is negative the item will be\ninserted at the start of the array.\n\n  Array.insertAt([\"b\",\"c\"], \"a\", 0) == [\"a\",\"b\",\"c\"]\n*/\nfun insertAt (array : Array(item), item : item, position : Number) : Array(item) {\n  `\n    (() => {\n      const result = Array.from(#{array})\n\n      if (#{position} <= 0) {\n        result.unshift(#{item})\n      } else {\n        result.splice(#{position}, 0, #{item})\n      }\n\n      return result\n    })()\n    `\n}","arguments":[{"type":"Array(item)","name":"array"},{"type":"item","name":"item"},{"type":"Number","name":"position"}]},{"type":"Array(item)","description":"<p>Inserts the element between the elements of the array.</p>\n<pre><code>Array.intersperse([&quot;x&quot;, &quot;y&quot;, &quot;z&quot;], &quot;a&quot;) == [&quot;x&quot;, &quot;a&quot;, &quot;y&quot;, &quot;a&quot;, &quot;z&quot;]\n</code></pre>\n","name":"intersperse","source":"/*\nInserts the element between the elements of the array.\n\n  Array.intersperse([\"x\", \"y\", \"z\"], \"a\") == [\"x\", \"a\", \"y\", \"a\", \"z\"]\n*/\nfun intersperse (array : Array(item), item : item) : Array(item) {\n  `#{array}.reduce((array, value)=>[...array, value, #{item}], []).slice(0,-1)`\n}","arguments":[{"type":"Array(item)","name":"array"},{"type":"item","name":"item"}]},{"type":"Bool","description":"<p>Returns whether or not the array is empty.</p>\n<pre><code>Array.isEmpty([&quot;a&quot;, &quot;b&quot;]) == false\nArray.isEmpty([]) == true\n</code></pre>\n","name":"isEmpty","source":"/*\nReturns whether or not the array is empty.\n\n  Array.isEmpty([\"a\", \"b\"]) == false\n  Array.isEmpty([]) == true\n*/\nfun isEmpty (array : Array(item)) : Bool {\n  size(array) == 0\n}","arguments":[{"type":"Array(item)","name":"array"}]},{"type":"Maybe(item)","description":"<p>Returns the last element of the array as <code>Maybe::Just(a)</code> or <code>Maybe::Nothing</code>.</p>\n<pre><code>Array.last([&quot;x&quot;, &quot;a&quot;]) == Maybe::Just(&quot;a&quot;)\nArray.last([]) == Maybe::Nothing\n</code></pre>\n","name":"last","source":"/*\nReturns the last element of the array as `Maybe::Just(a)` or `Maybe::Nothing`.\n\n  Array.last([\"x\", \"a\"]) == Maybe::Just(\"a\")\n  Array.last([]) == Maybe::Nothing\n*/\nfun last (array : Array(item)) : Maybe(item) {\n  `\n    (() => {\n      let last = #{array}[#{array}.length - 1]\n      if (last !== undefined) {\n        return #{Maybe::Just(`last`)}\n      } else {\n        return #{Maybe::Nothing}\n      }\n    })()\n    `\n}","arguments":[{"type":"Array(item)","name":"array"}]},{"type":"item","description":"<p>Returns the last element of the array or the default value.</p>\n<pre><code>Array.lastWithDefault([&quot;x&quot;, &quot;b&quot;], &quot;a&quot;) == &quot;b&quot;\nArray.lastWithDefault([], &quot;a&quot;) == &quot;a&quot;\n</code></pre>\n","name":"lastWithDefault","source":"/*\nReturns the last element of the array or the default value.\n\n  Array.lastWithDefault([\"x\", \"b\"], \"a\") == \"b\"\n  Array.lastWithDefault([], \"a\") == \"a\"\n*/\nfun lastWithDefault (array : Array(item), item : item) : item {\n  Maybe.withDefault(last(array), item)\n}","arguments":[{"type":"Array(item)","name":"array"},{"type":"item","name":"item"}]},{"type":"Array(result)","description":"<p>Creates a new array with the results of calling a provided function on every\nelement in the array.</p>\n<pre><code>Array.map([1, 2, 3], (number : Number) : Number { number + 1 }) == [2, 3, 4]\n</code></pre>\n","name":"map","source":"/*\nCreates a new array with the results of calling a provided function on every\nelement in the array.\n\n  Array.map([1, 2, 3], (number : Number) : Number { number + 1 }) == [2, 3, 4]\n*/\nfun map (array : Array(item), method : Function(item, result)) : Array(result) {\n  for item of array {\n    method(item)\n  }\n}","arguments":[{"type":"Array(item)","name":"array"},{"type":"Function(item, result)","name":"method"}]},{"type":"Array(result)","description":"<p>Creates a new array with the results of calling a provided function on every\nelement in the array while providing the index of the element.</p>\n<pre><code>Array.mapWithIndex(\n  [1, 2, 3],\n  (number : Number, index : Number) : Number { number + index }\n) == [2, 4, 6]\n</code></pre>\n","name":"mapWithIndex","source":"/*\nCreates a new array with the results of calling a provided function on every\nelement in the array while providing the index of the element.\n\n  Array.mapWithIndex(\n    [1, 2, 3],\n    (number : Number, index : Number) : Number { number + index }\n  ) == [2, 4, 6]\n*/\nfun mapWithIndex (\n  array : Array(item),\n  method : Function(item, Number, result)\n) : Array(result) {\n  for item, index of array {\n    method(item, index)\n  }\n}","arguments":[{"type":"Array(item)","name":"array"},{"type":"Function(item, Number, result)","name":"method"}]},{"type":"Maybe(Number)","description":"<p>Returns the maximum value of an array of numbers. It's a maybe because the\narray might not have items in it.</p>\n<pre><code>Array.max([0, 1, 2, 3, 4]) == Maybe::Just(4)\nArray.max([]) == Maybe::Nothing\n</code></pre>\n","name":"max","source":"/*\nReturns the maximum value of an array of numbers. It's a maybe because the\narray might not have items in it.\n\n  Array.max([0, 1, 2, 3, 4]) == Maybe::Just(4)\n  Array.max([]) == Maybe::Nothing\n*/\nfun max (array : Array(Number)) : Maybe(Number) {\n  if Array.size(array) > 0 {\n    Maybe.Just(`Math.max(...#{array})`)\n  } else {\n    Maybe.Nothing\n  }\n}","arguments":[{"type":"Array(Number)","name":"array"}]},{"type":"Maybe(Number)","description":"<p>Returns the minimum value of an array of numbers. It's a maybe because the\narray might not have items in it.</p>\n<pre><code>Array.min([0, 1, 2, 3, 4]) == Maybe::Just(0)\nArray.min([]) == Maybe::Nothing\n</code></pre>\n","name":"min","source":"/*\nReturns the minimum value of an array of numbers. It's a maybe because the\narray might not have items in it.\n\n  Array.min([0, 1, 2, 3, 4]) == Maybe::Just(0)\n  Array.min([]) == Maybe::Nothing\n*/\nfun min (array : Array(Number)) : Maybe(Number) {\n  if Array.size(array) > 0 {\n    Maybe.Just(`Math.min(...#{array})`)\n  } else {\n    Maybe.Nothing\n  }\n}","arguments":[{"type":"Array(Number)","name":"array"}]},{"type":"Array(item)","description":"<p>Moves an item at the index <code>from</code> to a new index <code>to</code>.</p>\n<p>The array is returned as is if:</p>\n<ul>\n<li>\n<p><code>from</code> and <code>to</code> are the same</p>\n</li>\n<li>\n<p>a negative number is supplied to <code>from</code></p>\n</li>\n<li>\n<p>a number is supplied to <code>from</code> which is grater the the length of the array</p>\n<p>Array.move([&quot;A&quot;, &quot;B&quot;, &quot;C&quot;], -1, 1) == [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]\nArray.move([&quot;A&quot;, &quot;B&quot;, &quot;C&quot;], 10, 1) == [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]\nArray.move([&quot;A&quot;, &quot;B&quot;, &quot;C&quot;], 0, 0) == [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]</p>\n</li>\n</ul>\n<p>If a negative number is supplied to <code>to</code> then, the item is moved to the\nfirst position.</p>\n<pre><code>Array.move([&quot;A&quot;, &quot;B&quot;, &quot;C&quot;], 2, -1) == [&quot;C&quot;, &quot;A&quot;, &quot;B&quot;]\n</code></pre>\n<p>If a number is supplied to <code>to</code> which is grater the the length of the array,\nthen the item is moved to the last position.</p>\n<pre><code>Array.move([&quot;A&quot;, &quot;B&quot;, &quot;C&quot;], 0, 10) == [&quot;B&quot;, &quot;C&quot;, &quot;A&quot;]\n</code></pre>\n","name":"move","source":"/*\nMoves an item at the index `from` to a new index `to`.\n\nThe array is returned as is if:\n* `from` and `to` are the same\n* a negative number is supplied to `from`\n* a number is supplied to `from` which is grater the the length of the array\n\n  Array.move([\"A\", \"B\", \"C\"], -1, 1) == [\"A\", \"B\", \"C\"]\n  Array.move([\"A\", \"B\", \"C\"], 10, 1) == [\"A\", \"B\", \"C\"]\n  Array.move([\"A\", \"B\", \"C\"], 0, 0) == [\"A\", \"B\", \"C\"]\n\nIf a negative number is supplied to `to` then, the item is moved to the\nfirst position.\n\n  Array.move([\"A\", \"B\", \"C\"], 2, -1) == [\"C\", \"A\", \"B\"]\n\nIf a number is supplied to `to` which is grater the the length of the array,\nthen the item is moved to the last position.\n\n  Array.move([\"A\", \"B\", \"C\"], 0, 10) == [\"B\", \"C\", \"A\"]\n*/\nfun move (array : Array(item), from : Number, to : Number) : Array(item) {\n  `\n    (() => {\n      const result = Array.from(#{array})\n\n      if (#{from} == #{to} || #{from} < 0 || #{from} >= result.length) {\n        return result\n      } else if (#{to} < 0) {\n        /* If the desired position is lower then zero put at the front. */\n        result.unshift(result.splice(#{from}, 1)[0])\n      } else if (#{to} >= result.length) {\n        /* If the desired position is bigger then length put at the back. */\n        result.push(result.splice(#{from}, 1)[0])\n      } else {\n        /* Else we just move. */\n        result.splice(#{to}, 0, result.splice(#{from}, 1)[0])\n      }\n\n      return result\n    })()\n    `\n}","arguments":[{"type":"Array(item)","name":"array"},{"type":"Number","name":"from"},{"type":"Number","name":"to"}]},{"type":"Array(item)","description":"<p>Push an element to the end of an array.</p>\n<pre><code>Array.push([1, 2, 3], 4) == [1, 2, 3, 4]\nArray.push([], &quot;a&quot;) == [&quot;a&quot;]\n</code></pre>\n","name":"push","source":"/*\nPush an element to the end of an array.\n\n  Array.push([1, 2, 3], 4) == [1, 2, 3, 4]\n  Array.push([], \"a\") == [\"a\"]\n*/\nfun push (array : Array(item), item : item) : Array(item) {\n  `[...#{array}, #{item}]`\n}","arguments":[{"type":"Array(item)","name":"array"},{"type":"item","name":"item"}]},{"type":"Array(Number)","description":"<p>Creates an array of numbers starting from the first argument and\nending in the last.</p>\n<pre><code>Array.range(0, 5) == [0, 1, 2, 3, 4, 5]\n</code></pre>\n","name":"range","source":"/*\nCreates an array of numbers starting from the first argument and\nending in the last.\n\n  Array.range(0, 5) == [0, 1, 2, 3, 4, 5]\n*/\nfun range (from : Number, to : Number) : Array(Number) {\n  `Array.from({ length: (#{to} + 1) - #{from} }).map((v, $0) => $0 + #{from})`\n}","arguments":[{"type":"Number","name":"from"},{"type":"Number","name":"to"}]},{"type":"memo","description":"<p>Applies the function against an accumulator and each element in the array\n(from start to end) to reduce it to a single value.</p>\n<pre><code>Array.reduce(\n  [1, 2, 3],\n  0,\n  (memo : Number, item : Number) : Number { memo + item }) == 6\n</code></pre>\n","name":"reduce","source":"/*\nApplies the function against an accumulator and each element in the array\n(from start to end) to reduce it to a single value.\n\n  Array.reduce(\n    [1, 2, 3],\n    0,\n    (memo : Number, item : Number) : Number { memo + item }) == 6\n*/\nfun reduce (\n  array : Array(item),\n  initial : memo,\n  function : Function(memo, item, memo)\n) : memo {\n  `#{array}.reduce(#{function}, #{initial})`\n}","arguments":[{"type":"Array(item)","name":"array"},{"type":"memo","name":"initial"},{"type":"Function(memo, item, memo)","name":"function"}]},{"type":"memo","description":"<p>Applies the function against an accumulator and each element in the array\n(from end to start) to reduce it to a single value.</p>\n<pre><code>Array.reduceEnd(\n  [1,2,3,4,5],\n  0,\n  (acc : Number, n : Number) : Number { acc + n}) == 15\n</code></pre>\n","name":"reduceEnd","source":"/*\nApplies the function against an accumulator and each element in the array\n(from end to start) to reduce it to a single value.\n\n  Array.reduceEnd(\n    [1,2,3,4,5],\n    0,\n    (acc : Number, n : Number) : Number { acc + n}) == 15\n*/\nfun reduceEnd (\n  array : Array(item),\n  initial : memo,\n  function : Function(memo, item, memo)\n) : memo {\n  `#{array}.reduceRight(#{function}, #{initial})`\n}","arguments":[{"type":"Array(item)","name":"array"},{"type":"memo","name":"initial"},{"type":"Function(memo, item, memo)","name":"function"}]},{"type":"Array(item)","description":"<p>Returns all elements that do not match the predicate function.</p>\n<pre><code>Array.reject([1, 2, 3, 4], (number : Number) : Bool { number % 2 == 0 }) == [1, 3]\n</code></pre>\n","name":"reject","source":"/*\nReturns all elements that do not match the predicate function.\n\n  Array.reject([1, 2, 3, 4], (number : Number) : Bool { number % 2 == 0 }) == [1, 3]\n*/\nfun reject (array : Array(item), function : Function(item, Bool)) : Array(item) {\n  `#{array}.filter((item) => !#{function}(item))`\n}","arguments":[{"type":"Array(item)","name":"array"},{"type":"Function(item, Bool)","name":"function"}]},{"type":"Array(item)","description":"<p>Returns a new array where the elements are reversed. The first array element\nbecomes the last, and the last array element becomes the first.</p>\n<pre><code>Array.reverse([1, 2, 3]) == [3, 2, 1]\n</code></pre>\n","name":"reverse","source":"/*\nReturns a new array where the elements are reversed. The first array element\nbecomes the last, and the last array element becomes the first.\n\n  Array.reverse([1, 2, 3]) == [3, 2, 1]\n*/\nfun reverse (array : Array(item)) : Array(item) {\n  `[...#{array}].reverse()`\n}","arguments":[{"type":"Array(item)","name":"array"}]},{"type":"Array(item)","description":"<p>Returns a new array where the elements are reversed if the condition is true.</p>\n<pre><code>Array.reverseIf([1, 2, 3], false) == [1, 2, 3]\nArray.reverseIf([1, 2, 3], true) == [3, 2, 1]\n</code></pre>\n","name":"reverseIf","source":"/*\nReturns a new array where the elements are reversed if the condition is true.\n\n  Array.reverseIf([1, 2, 3], false) == [1, 2, 3]\n  Array.reverseIf([1, 2, 3], true) == [3, 2, 1]\n*/\nfun reverseIf (array : Array(item), condition : Bool) : Array(item) {\n  if condition {\n    Array.reverse(array)\n  } else {\n    array\n  }\n}","arguments":[{"type":"Array(item)","name":"array"},{"type":"Bool","name":"condition"}]},{"type":"Maybe(item)","description":"<p>Returns a random element from the array.</p>\n<pre><code>Array.sample([&quot;a&quot;]) == Maybe::Just(&quot;a&quot;)\nArray.sample() == Maybe::Nothing()\n</code></pre>\n","name":"sample","source":"/*\nReturns a random element from the array.\n\n  Array.sample([\"a\"]) == Maybe::Just(\"a\")\n  Array.sample() == Maybe::Nothing()\n*/\nfun sample (array : Array(item)) : Maybe(item) {\n  `\n    (() => {\n      if (#{array}.length) {\n        const item = #{array}[Math.floor(Math.random() * #{array}.length)]\n\n        return #{Maybe::Just(`item`)}\n      } else {\n        return #{Maybe::Nothing}\n      }\n    })()\n    `\n}","arguments":[{"type":"Array(item)","name":"array"}]},{"type":"Array(item)","description":"<p>Returns all elements that match the predicate function.</p>\n<pre><code>Array.select([1, 2, 3, 4], (number : Number) : Bool { number % 2 == 0 }) == [2, 4]\n</code></pre>\n","name":"select","source":"/*\nReturns all elements that match the predicate function.\n\n  Array.select([1, 2, 3, 4], (number : Number) : Bool { number % 2 == 0 }) == [2, 4]\n*/\nfun select (array : Array(item), function : Function(item, Bool)) : Array(item) {\n  `#{array}.filter(#{function})`\n}","arguments":[{"type":"Array(item)","name":"array"},{"type":"Function(item, Bool)","name":"function"}]},{"type":"Array(item)","description":"<p>Sets the item at index to the item of the array, if the specified index is\nnot found in the array it returns the array unchanged.</p>\n<pre><code>Array.setAt([1,2,3], 2, 5) == [1,2,5]\n</code></pre>\n","name":"setAt","source":"/*\nSets the item at index to the item of the array, if the specified index is\nnot found in the array it returns the array unchanged.\n\n  Array.setAt([1,2,3], 2, 5) == [1,2,5]\n*/\nfun setAt (array : Array(item), index : Number, item : item) : Array(item) {\n  `\n    (() => {\n      if (#{index} < 0 || #{index} >= #{array}.length) { return #{array} }\n      const result = Array.from(#{array})\n      result[#{index}] = #{item}\n      return result\n    })()\n    `\n}","arguments":[{"type":"Array(item)","name":"array"},{"type":"Number","name":"index"},{"type":"item","name":"item"}]},{"type":"Number","description":"<p>Returns the size of the array.</p>\n<pre><code>Array.size([1, 2, 3]) == 3\nArray.size([]) == 0\n</code></pre>\n","name":"size","source":"/*\nReturns the size of the array.\n\n  Array.size([1, 2, 3]) == 3\n  Array.size([]) == 0\n*/\nfun size (array : Array(item)) : Number {\n  `#{array}.length`\n}","arguments":[{"type":"Array(item)","name":"array"}]},{"type":"Array(item)","description":"<p>Returns a copy of a portion of an array (end not included).</p>\n<pre><code>Array.slice([&quot;ant&quot;, &quot;bison&quot;, &quot;camel&quot;, &quot;duck&quot;, &quot;elephant&quot;], 2, 4) == [&quot;camel&quot;, &quot;duck&quot;]\n</code></pre>\n","name":"slice","source":"/*\nReturns a copy of a portion of an array (end not included).\n\n  Array.slice([\"ant\", \"bison\", \"camel\", \"duck\", \"elephant\"], 2, 4) == [\"camel\", \"duck\"]\n*/\nfun slice (array : Array(item), begin : Number, end : Number) : Array(item) {\n  `#{array}.slice(#{begin}, #{end})`\n}","arguments":[{"type":"Array(item)","name":"array"},{"type":"Number","name":"begin"},{"type":"Number","name":"end"}]},{"type":"Array(item)","description":"<p>Returns a new sorted array using the sorting function <code>compareFunction(a, b)</code>.\nItems are sorted using a number:</p>\n<ul>\n<li>\n<p><code>&gt; 0</code> - sort b before a</p>\n</li>\n<li>\n<p><code>&lt; 0</code> - sort a before b</p>\n</li>\n<li>\n<p><code>0</code> - keep original order of a and b</p>\n<p>Array.sort([4, 1, 3, 2], (a : Number, b : Number) : Number { a - b }) == [1, 2, 3, 4]</p>\n</li>\n</ul>\n","name":"sort","source":"/*\nReturns a new sorted array using the sorting function `compareFunction(a, b)`.\nItems are sorted using a number:\n\n* `> 0` - sort b before a\n* `< 0` - sort a before b\n* `0` - keep original order of a and b\n\n  Array.sort([4, 1, 3, 2], (a : Number, b : Number) : Number { a - b }) == [1, 2, 3, 4]\n*/\nfun sort (\n  array : Array(item),\n  function : Function(item, item, Number)\n) : Array(item) {\n  `[...#{array}].sort(#{function})`\n}","arguments":[{"type":"Array(item)","name":"array"},{"type":"Function(item, item, Number)","name":"function"}]},{"type":"Array(item)","description":"<p>Returns a new sorted array using the functions return as the base of\nthe sorting.</p>\n<pre><code>Array.sortBy([4, 1, 3, 2], (number : Number) : Number { number }) == [1, 2, 3, 4]\n</code></pre>\n","name":"sortBy","source":"/*\nReturns a new sorted array using the functions return as the base of\nthe sorting.\n\n  Array.sortBy([4, 1, 3, 2], (number : Number) : Number { number }) == [1, 2, 3, 4]\n*/\nfun sortBy (\n  array : Array(item),\n  function : Function(item, result)\n) : Array(item) {\n  `\n    (() => {\n      return #{array}.sort((a, b) => {\n        let aVal = #{function}(a)\n        let bVal = #{function}(b)\n\n        if (aVal < bVal) {\n          return -1\n        }\n\n        if (aVal > bVal) {\n          return 1\n        }\n\n        return 0\n      })\n    })()\n    `\n}","arguments":[{"type":"Array(item)","name":"array"},{"type":"Function(item, result)","name":"function"}]},{"type":"Number","description":"<p>Sums up the array of numbers.</p>\n<pre><code>Array.sum([1, 2, 3]) == 6\n</code></pre>\n","name":"sum","source":"/*\nSums up the array of numbers.\n\n  Array.sum([1, 2, 3]) == 6\n*/\nfun sum (array : Array(Number)) : Number {\n  Array.reduce(\n    array, \n    0, \n    (memo : Number, item : Number) : Number {\n      item + memo\n    })\n}","arguments":[{"type":"Array(Number)","name":"array"}]},{"type":"Number","description":"<p>Sums up the array using the specified function.</p>\n<pre><code>Array.sumBy([1, 2, 3], (value : Number) : Number { value }) == 6\n</code></pre>\n","name":"sumBy","source":"/*\nSums up the array using the specified function.\n\n  Array.sumBy([1, 2, 3], (value : Number) : Number { value }) == 6\n*/\nfun sumBy (array : Array(item), method : Function(item, Number)) : Number {\n  array\n  |> Array.map(method)\n  |> Array.sum()\n}","arguments":[{"type":"Array(item)","name":"array"},{"type":"Function(item, Number)","name":"method"}]},{"type":"Array(item)","description":"<p>Swaps the items at the specified indexes of the array. It returns the array\nunchanged if there is no item at any of the specified indexes.</p>\n<pre><code>Array.swap([&quot;a&quot;,&quot;b&quot;], 0, 1) == [&quot;b&quot;, &quot;a&quot;]\n</code></pre>\n","name":"swap","source":"/*\nSwaps the items at the specified indexes of the array. It returns the array\nunchanged if there is no item at any of the specified indexes.\n\n  Array.swap([\"a\",\"b\"], 0, 1) == [\"b\", \"a\"]\n*/\nfun swap (array : Array(item), index1 : Number, index2 : Number) : Array(item) {\n  `\n    (() => {\n      if (#{index1} < 0 ||\n          #{index2} < 0 ||\n          #{index1} >= #{array}.length ||\n          #{index2} >= #{array}.length) {\n        return #{array}\n      }\n\n      const result = Array.from(#{array})\n      const saved = result[#{index1}]\n      result[#{index1}] = result[#{index2}]\n      result[#{index2}] = saved;\n      return result\n    })()\n    `\n}","arguments":[{"type":"Array(item)","name":"array"},{"type":"Number","name":"index1"},{"type":"Number","name":"index2"}]},{"type":"Array(item)","description":"<p>Takes the specified number of items from the end of the array.</p>\n<pre><code>Array.takeEnd([1, 2, 3, 4], 2) == [3, 4]\n</code></pre>\n","name":"takeEnd","source":"/*\nTakes the specified number of items from the end of the array.\n\n  Array.takeEnd([1, 2, 3, 4], 2) == [3, 4]\n*/\nfun takeEnd (array : Array(item), number : Number) : Array(item) {\n  `#{array}.slice(-#{number})`\n}","arguments":[{"type":"Array(item)","name":"array"},{"type":"Number","name":"number"}]},{"type":"Array(item)","description":"<p>Takes the specified number of items from the start of the array.</p>\n<pre><code>Array.takeStart([1, 2, 3, 4], 2) == [1, 2]\n</code></pre>\n","name":"takeStart","source":"/*\nTakes the specified number of items from the start of the array.\n\n  Array.takeStart([1, 2, 3, 4], 2) == [1, 2]\n*/\nfun takeStart (array : Array(item), number : Number) : Array(item) {\n  `#{array}.slice(0, #{number})`\n}","arguments":[{"type":"Array(item)","name":"array"},{"type":"Number","name":"number"}]},{"type":"Array(item)","description":"<p>Removes duplicate items from the array.</p>\n<pre><code>Array.uniq([&quot;a&quot;, &quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;c&quot;] == [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]\n</code></pre>\n","name":"uniq","source":"/*\nRemoves duplicate items from the array.\n\n  Array.uniq([\"a\", \"a\", \"b\", \"b\", \"c\"] == [\"a\", \"b\", \"c\"]\n*/\nfun uniq (array : Array(item)) : Array(item) {\n  for item, index of array {\n    item\n  } when {\n    indexOf(array, item) == Maybe.Just(index)\n  }\n}","arguments":[{"type":"Array(item)","name":"array"}]},{"type":"Array(item)","description":"<p>Pushes a new item at the head of the array.</p>\n<pre><code>Array.unshift([3, 4], 2) == [2, 3, 4]\n</code></pre>\n","name":"unshift","source":"/*\nPushes a new item at the head of the array.\n\n  Array.unshift([3, 4], 2) == [2, 3, 4]\n*/\nfun unshift (array : Array(item), item : item) : Array(item) {\n  `\n    (() => {\n      const result = Array.from(#{array})\n      result.unshift(#{item})\n      return result\n    })()\n    `\n}","arguments":[{"type":"Array(item)","name":"array"},{"type":"item","name":"item"}]},{"type":"Array(item)","description":"<p>Updates the item at the given index of the given array using the given\nfunction.</p>\n<pre><code>Array.updateAt(\n  [0,1,2], 2, (number : Number) : Number {\n    number + 2\n  }) == [0,1,4]\n</code></pre>\n","name":"updateAt","source":"/*\nUpdates the item at the given index of the given array using the given\nfunction.\n\n  Array.updateAt(\n    [0,1,2], 2, (number : Number) : Number {\n      number + 2\n    }) == [0,1,4]\n*/\nfun updateAt (\n  array : Array(item),\n  index : Number,\n  method : Function(item, item)\n) : Array(item) {\n  case array[index] {\n    Maybe.Just(item) => setAt(array, index, method(item))\n    Maybe.Nothing => array\n  }\n}","arguments":[{"type":"Array(item)","name":"array"},{"type":"Number","name":"index"},{"type":"Function(item, item)","name":"method"}]}]},{"description":null,"name":"ArrayBuffer","functions":[{"type":"ArrayBuffer","description":"<p>Converts the given string to an ArrayBuffer.</p>\n<pre><code>(&quot;Hello&quot;\n|&gt; ArrayBuffer.toArrayBuffer()\n|&gt; ArrayBuffer.toString()) == &quot;Hello&quot;\n</code></pre>\n","name":"toArrayBuffer","source":"/*\nConverts the given string to an ArrayBuffer.\n\n  (\"Hello\"\n  |> ArrayBuffer.toArrayBuffer()\n  |> ArrayBuffer.toString()) == \"Hello\"\n*/\nfun toArrayBuffer (string : String) : ArrayBuffer {\n  `new TextEncoder().encode(#{string})`\n}","arguments":[{"type":"String","name":"string"}]},{"type":"String","description":"<p>Converts an ArrayBuffer to an UTF-8 string.</p>\n<pre><code>(&quot;Hello&quot;\n|&gt; ArrayBuffer.toArrayBuffer()\n|&gt; ArrayBuffer.toString()) == &quot;Hello&quot;\n</code></pre>\n","name":"toString","source":"/*\nConverts an ArrayBuffer to an UTF-8 string.\n\n  (\"Hello\"\n  |> ArrayBuffer.toArrayBuffer()\n  |> ArrayBuffer.toString()) == \"Hello\"\n*/\nfun toString (buffer : ArrayBuffer) : String {\n  `new TextDecoder().decode(#{buffer})`\n}","arguments":[{"type":"ArrayBuffer","name":"buffer"}]}]},{"description":null,"name":"Base64","functions":[{"type":"Result(String, String)","description":"<p>Tries to decode the given Base64 string.</p>\n","name":"decode","source":"/* Tries to decode the given Base64 string. */\nfun decode (value : String) : Result(String, String) {\n  `\n    (() => {\n      try {\n        return #{Result::Ok(`atob(#{value})`)};\n      } catch (error) {\n        return #{Result::Err(`error.toString()`)};\n      }\n    })()\n    `\n}","arguments":[{"type":"String","name":"value"}]},{"type":"String","description":"<p>Encodes the given value as Base64.</p>\n","name":"encode","source":"/* Encodes the given value as Base64. */\nfun encode (value : String) : String {\n  `btoa(#{value})`\n}","arguments":[{"type":"String","name":"value"}]}]},{"description":null,"name":"Bool","functions":[{"type":"String","description":"<p>Converts a boolean to a string.</p>\n<pre><code>Bool.toString(true) == &quot;true&quot;\nBool.toString(false) == &quot;false&quot;\n</code></pre>\n","name":"toString","source":"/*\nConverts a boolean to a string.\n\n  Bool.toString(true) == \"true\"\n  Bool.toString(false) == \"false\"\n*/\nfun toString (item : Bool) : String {\n  `#{item}.toString()`\n}","arguments":[{"type":"Bool","name":"item"}]}]},{"description":null,"name":"Clipboard","functions":[{"type":"Promise(String)","description":"<p>Sets the clipboards content to the given value.</p>\n","name":"set","source":"/* Sets the clipboards content to the given value. */\nfun set (value : String) : Promise(String) {\n  `\n    (() => {\n      // Create a textarea element\n      const textarea = document.createElement(\"textarea\")\n\n      // Position it on the screen\n      textarea.style.position = \"fixed\"\n      textarea.style.left = \"10px\"\n      textarea.style.top = \"10px\"\n      textarea.style.opacity = 0\n\n      // Add it to the DOM\n      document.body.appendChild(textarea)\n\n      // Remember the currently focused element\n      const lastActive = document.activeElement\n\n      // Focus it and set value\n      textarea.focus()\n      textarea.value = #{value}\n\n      // Create a selection range and set value\n      const range = document.createRange()\n      range.selectNodeContents(textarea)\n\n      // Get selection and replace current selection\n      const selection = window.getSelection()\n      const lastRanges = Array.from({length: selection.rangeCount}, (_, i) => selection.getRangeAt(i))\n      selection.removeAllRanges()\n      selection.addRange(range)\n\n      // Select all the text\n      textarea.setSelectionRange(0, 999999)\n\n      // Copy to clipboard\n      document.execCommand(\"copy\")\n\n      // Remove textarea from the DOM\n      textarea.remove()\n\n      // Refocus the previous active element\n      lastActive.focus()\n\n      // Restore previous range(s)\n      selection.removeAllRanges()\n\n      for (let range of lastRanges) {\n        selection.addRange(range)\n      }\n\n      return #{value}\n    })()\n    `\n}","arguments":[{"type":"String","name":"value"}]}]},{"description":null,"name":"Console","functions":[{"type":"Tuple(Bool, a, Array(b))","description":"<p>If the assertion is false, the message is written to the console. Supports string substitution.</p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/console/assert\">assert()</a></p>\n","name":"assert","source":"/*\nIf the assertion is false, the message is written to the console. Supports string substitution.\n\n[assert()](https://developer.mozilla.org/en-US/docs/Web/API/console/assert)\n*/\nfun assert (assertion : Bool, value : a, values : Array(b) = []) : Tuple(Bool, a, Array(b)) {\n  `console.assert(#{assertion}, #{value}, ...#{values})`\n\n  #(assertion, value, values)\n}","arguments":[{"type":"Bool","name":"assertion"},{"type":"a","name":"value"},{"type":"Array(b)","name":"values"}]},{"type":"Void","description":"<p>Clears the console.</p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/console/clear\">clear()</a></p>\n","name":"clear","source":"/*\nClears the console.\n\n[clear()](https://developer.mozilla.org/en-US/docs/Web/API/console/clear)\n*/\nfun clear : Void {\n  `console.clear()`\n}","arguments":[]},{"type":"Tuple(String, Number)","description":"<p>Logs the number of times that this particular call to count() has been called.\nReturns the label passed along with the current count.</p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/console/count\">count()</a></p>\n","name":"count","source":"/*\nLogs the number of times that this particular call to count() has been called.\nReturns the label passed along with the current count.\n\n[count()](https://developer.mozilla.org/en-US/docs/Web/API/console/count)\n*/\nfun count (label : String = \"Default\") : Tuple(String, Number) {\n  `console.count(#{label})`\n  Console.Counter.increment(label)\n\n  #(label, Console.Counter.get(label))\n}","arguments":[{"type":"String","name":"label"}]},{"type":"Tuple(String, Number)","description":"<p>Resets the counter used with Console.count().\nReturns the label passed along with the current count.</p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/console/countReset\">countReset()</a></p>\n","name":"countReset","source":"/*\nResets the counter used with Console.count().\nReturns the label passed along with the current count.\n\n[countReset()](https://developer.mozilla.org/en-US/docs/Web/API/console/countReset)\n*/\nfun countReset (label : String = \"Default\") : Tuple(String, Number) {\n  `console.countReset(#{label})`\n  Console.Counter.clear(label)\n\n  #(label, Console.Counter.get(label))\n}","arguments":[{"type":"String","name":"label"}]},{"type":"Tuple(a, Array(b))","description":"<p>Outputs a message to the Web Console at the &quot;debug&quot; log level.\nThe message is only displayed to the user if the console is configured to display debug output.\nSupports string substitution.</p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/console/debug\">debug()</a></p>\n","name":"debug","source":"/*\nOutputs a message to the Web Console at the \"debug\" log level.\nThe message is only displayed to the user if the console is configured to display debug output.\nSupports string substitution.\n\n[debug()](https://developer.mozilla.org/en-US/docs/Web/API/console/debug)\n*/\nfun debug (value : a, values : Array(b) = []) : Tuple(a, Array(b)) {\n  `console.debug(#{value}, ...#{values})`\n\n  #(value, values)\n}","arguments":[{"type":"a","name":"value"},{"type":"Array(b)","name":"values"}]},{"type":"a","description":"<p>Displays an interactive list of the properties of the generated JavaScript object.</p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/console/dir\">dir()</a></p>\n","name":"dir","source":"/*\nDisplays an interactive list of the properties of the generated JavaScript object.\n\n[dir()](https://developer.mozilla.org/en-US/docs/Web/API/console/dir)\n*/\nfun dir (value : a) : a {\n  `console.dir(#{value})`\n\n  value\n}","arguments":[{"type":"a","name":"value"}]},{"type":"a","description":"<p>Displays an interactive tree of the descendant elements of the specified XML/HTML\nelement.</p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/console/dirxml\">dirxml()</a></p>\n","name":"dirxml","source":"/*\nDisplays an interactive tree of the descendant elements of the specified XML/HTML\nelement.\n\n[dirxml()](https://developer.mozilla.org/en-US/docs/Web/API/console/dirxml)\n*/\nfun dirxml (value : a) : a {\n  `console.dirxml(#{value})`\n\n  value\n}","arguments":[{"type":"a","name":"value"}]},{"type":"Tuple(a, Array(b))","description":"<p>Outputs an error message to the Web Console. Supports string substitution.</p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/console/error\">error()</a></p>\n","name":"error","source":"/*\nOutputs an error message to the Web Console. Supports string substitution.\n\n[error()](https://developer.mozilla.org/en-US/docs/Web/API/console/error)\n*/\nfun error (value : a, values : Array(b) = []) : Tuple(a, Array(b)) {\n  `console.error(#{value}, ...#{values})`\n\n  #(value, values)\n}","arguments":[{"type":"a","name":"value"},{"type":"Array(b)","name":"values"}]},{"type":"String","description":"<p>Creates a new inline group in the Web Console log.</p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/console/group\">group()</a></p>\n","name":"group","source":"/*\nCreates a new inline group in the Web Console log.\n\n[group()](https://developer.mozilla.org/en-US/docs/Web/API/console/group)\n*/\nfun group (label : String = \"Default\") : String {\n  `console.group(#{label})`\n\n  label\n}","arguments":[{"type":"String","name":"label"}]},{"type":"String","description":"<p>Creates a new inline group in the Web Console log. The new group is created collapsed.</p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/console/groupCollapsed\">groupCollapsed()</a></p>\n","name":"groupCollapsed","source":"/*\nCreates a new inline group in the Web Console log. The new group is created collapsed.\n\n[groupCollapsed()](https://developer.mozilla.org/en-US/docs/Web/API/console/groupCollapsed)\n*/\nfun groupCollapsed (label : String = \"Default\") : String {\n  `console.groupCollapsed(#{label})`\n\n  label\n}","arguments":[{"type":"String","name":"label"}]},{"type":"String","description":"<p>Exits the current inline group in the Web Console.</p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/console/groupEnd\">groupEnd()</a></p>\n","name":"groupEnd","source":"/*\nExits the current inline group in the Web Console.\n\n[groupEnd()](https://developer.mozilla.org/en-US/docs/Web/API/console/groupEnd)\n*/\nfun groupEnd (label : String = \"Default\") : String {\n  `console.groupEnd(#{label})`\n\n  label\n}","arguments":[{"type":"String","name":"label"}]},{"type":"Tuple(a, Array(b))","description":"<p>Outputs an informational message to the Web Console. Supports string substitution.</p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/console/info\">info()</a></p>\n","name":"info","source":"/*\nOutputs an informational message to the Web Console. Supports string substitution.\n\n[info()](https://developer.mozilla.org/en-US/docs/Web/API/console/info)\n*/\nfun info (value : a, values : Array(b) = []) : Tuple(a, Array(b)) {\n  `console.info(#{value}, ...#{values})`\n\n  #(value, values)\n}","arguments":[{"type":"a","name":"value"},{"type":"Array(b)","name":"values"}]},{"type":"Tuple(a, Array(b))","description":"<p>Outputs a message to the Web Console. Supports string substitution.</p>\n<p>Console.log(&quot;Hello &quot;, [&quot;World&quot;, &quot;!&quot;]) =&gt; &quot;Hello World!&quot;</p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/console/log\">log()</a></p>\n","name":"log","source":"/*\nOutputs a message to the Web Console. Supports string substitution.\n\nConsole.log(\"Hello \", [\"World\", \"!\"]) => \"Hello World!\"\n\n[log()](https://developer.mozilla.org/en-US/docs/Web/API/console/log)\n*/\nfun log (value : a, values : Array(b) = []) : Tuple(a, Array(b)) {\n  `console.log(#{value}, ...#{values})`\n\n  #(value, values)\n}","arguments":[{"type":"a","name":"value"},{"type":"Array(b)","name":"values"}]},{"type":"String","description":"<p><strong>NON-STANDARD</strong>:</p>\n<p>Starts recording a performance profile.</p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/console/profile\">profile()</a></p>\n","name":"profile","source":"/*\n**NON-STANDARD**:\n\nStarts recording a performance profile.\n\n[profile()](https://developer.mozilla.org/en-US/docs/Web/API/console/profile)\n*/\nfun profile (profileName : String = \"Default\") : String {\n  if `!console.profile` {\n    Debug.log(\"Your browser does not support console.profile\")\n  } else {\n    `console.profile(#{profileName})`\n  }\n\n  profileName\n}","arguments":[{"type":"String","name":"profileName"}]},{"type":"String","description":"<p><strong>NON-STANDARD</strong>:</p>\n<p>Stops recording a performance profile previously started.</p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/console/profileEnd\">profileEnd()</a></p>\n","name":"profileEnd","source":"/*\n**NON-STANDARD**:\n\nStops recording a performance profile previously started.\n\n[profileEnd()](https://developer.mozilla.org/en-US/docs/Web/API/console/profileEnd)\n*/\nfun profileEnd (profileName : String = \"Default\") : String {\n  if `!console.profileEnd` {\n    Debug.log(\"Your browser does not support console.profileEnd\")\n  } else {\n    `console.profileEnd(#{profileName})`\n  }\n\n  profileName\n}","arguments":[{"type":"String","name":"profileName"}]},{"type":"Tuple(a, Array(String))","description":"<p>Logs data as a table.</p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/console/table\">table()</a></p>\n","name":"table","source":"/*\nLogs data as a table.\n\n[table()](https://developer.mozilla.org/en-US/docs/Web/API/console/table)\n*/\nfun table (data : a, columns : Array(String) = []) : Tuple(a, Array(String)) {\n  if columns != [] {\n    `console.table(#{data}, #{columns})`\n  } else {\n    `console.table(#{data})`\n  }\n\n  #(data, columns)\n}","arguments":[{"type":"a","name":"data"},{"type":"Array(String)","name":"columns"}]},{"type":"String","description":"<p>Starts a timer.</p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/console/time\">time()</a></p>\n","name":"time","source":"/*\nStarts a timer.\n\n[time()](https://developer.mozilla.org/en-US/docs/Web/API/console/time)\n*/\nfun time (label : String = \"Default\") : String {\n  `console.time(#{label})`\n\n  label\n}","arguments":[{"type":"String","name":"label"}]},{"type":"String","description":"<p>Stops a timer that was previously started.</p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/console/timeEnd\">timeEnd()</a></p>\n","name":"timeEnd","source":"/*\nStops a timer that was previously started.\n\n[timeEnd()](https://developer.mozilla.org/en-US/docs/Web/API/console/timeEnd)\n*/\nfun timeEnd (label : String = \"Default\") : String {\n  `console.timeEnd(#{label})`\n\n  label\n}","arguments":[{"type":"String","name":"label"}]},{"type":"Tuple(String, Array(a))","description":"<p>Logs the current value of a timer that was previously started.</p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/console/timeLog\">timeLog()</a></p>\n","name":"timeLog","source":"/*\nLogs the current value of a timer that was previously started.\n\n[timeLog()](https://developer.mozilla.org/en-US/docs/Web/API/console/timeLog)\n*/\nfun timeLog (label : String = \"Default\", values : Array(a) = []) : Tuple(String, Array(a)) {\n  `console.timeLog(#{label}, ...#{values})`\n\n  #(label, values)\n}","arguments":[{"type":"String","name":"label"},{"type":"Array(a)","name":"values"}]},{"type":"String","description":"<p><strong>NON-STANDARD</strong>:</p>\n<p>Adds a single marker to the browser's performance tool.</p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/console/timestamp\">timestamp()</a></p>\n","name":"timestamp","source":"/*\n**NON-STANDARD**:\n\nAdds a single marker to the browser's performance tool.\n\n[timestamp()](https://developer.mozilla.org/en-US/docs/Web/API/console/timestamp)\n*/\nfun timestamp (label : String = \"Default\") : String {\n  if `!console.timestamp` {\n    Debug.log(\"Your browser does not support console.timestamp\")\n  } else {\n    `console.timestamp(#{label})`\n  }\n\n  label\n}","arguments":[{"type":"String","name":"label"}]},{"type":"Tuple(a, Array(b))","description":"<p>Outputs a stack trace to the Web Console. Does not support string substitution.</p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/console/trace\">trace()</a></p>\n","name":"trace","source":"/*\nOutputs a stack trace to the Web Console. Does not support string substitution.\n\n[trace()](https://developer.mozilla.org/en-US/docs/Web/API/console/trace)\n*/\nfun trace (value : a, values : Array(b)) : Tuple(a, Array(b)) {\n  `console.trace(#{value}, ...#{values})`\n\n  #(value, values)\n}","arguments":[{"type":"a","name":"value"},{"type":"Array(b)","name":"values"}]},{"type":"Tuple(a, Array(b))","description":"<p>Outputs a warning message to the Web Console.</p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/console/warn\">warn()</a></p>\n","name":"warn","source":"/*\nOutputs a warning message to the Web Console.\n\n[warn()](https://developer.mozilla.org/en-US/docs/Web/API/console/warn)\n*/\nfun warn (value : a, values : Array(b) = []) : Tuple(a, Array(b)) {\n  `console.warn(#{value}, ...#{values})`\n\n  #(value, values)\n}","arguments":[{"type":"a","name":"value"},{"type":"Array(b)","name":"values"}]}]},{"description":null,"name":"Debug","functions":[{"type":"a","description":"<p>Logs an arbitrary value to the windows console.</p>\n","name":"log","source":"/* Logs an arbitrary value to the windows console. */\nfun log (value : a) : a {\n  `\n    (() => {\n      if (window.DEBUG) {\n        window.DEBUG.log(#{value})\n      } else {\n        console.log(#{value})\n      }\n\n      return #{value}\n    })()\n    `\n}","arguments":[{"type":"a","name":"value"}]}]},{"description":null,"name":"Dom","functions":[{"type":"Promise(Void)","description":"<p>Blurs the active element of the page.</p>\n<pre><code>Dom.blurActiveElement()\n</code></pre>\n","name":"blurActiveElement","source":"/*\nBlurs the active element of the page.\n\n  Dom.blurActiveElement()\n*/\nfun blurActiveElement : Promise(Void) {\n  `document.activeElement && document.activeElement.blur()`\n}","arguments":[]},{"type":"Bool","description":"<p>Returns if the given element is in an element that matches the given\nselector.</p>\n<pre><code>Dom.containedInSelector(Dom.getElementBySelector(&quot;div&quot;), &quot;body&quot;)\n</code></pre>\n","name":"containedInSelector","source":"/*\nReturns if the given element is in an element that matches the given\nselector.\n\n  Dom.containedInSelector(Dom.getElementBySelector(\"div\"), \"body\")\n*/\nfun containedInSelector (element : Dom.Element, selector : String) : Bool {\n  `\n    (() => {\n      for (let base of document.querySelectorAll(selector)) {\n        if (base.contains(element)) {\n          return true\n        }\n      }\n\n      return false\n    })()\n    `\n}","arguments":[{"type":"Dom.Element","name":"element"},{"type":"String","name":"selector"}]},{"type":"Bool","description":"<p>Returns if the given base element contains the given element.</p>\n<pre><code>Dom.contains(body, div) == true\n</code></pre>\n","name":"contains","source":"/*\nReturns if the given base element contains the given element.\n\n  Dom.contains(body, div) == true\n*/\nfun contains (base : Dom.Element, element : Dom.Element) : Bool {\n  `#{base}.contains(#{element})`\n}","arguments":[{"type":"Dom.Element","name":"base"},{"type":"Dom.Element","name":"element"}]},{"type":"Dom.Element","description":"<p>Creates a new <code>Dom.Element</code> with the given tag.</p>\n<pre><code>Dom.createElement(&quot;div&quot;)\n</code></pre>\n","name":"createElement","source":"/*\nCreates a new `Dom.Element` with the given tag.\n\n  Dom.createElement(\"div\")\n*/\nfun createElement (tag : String) : Dom.Element {\n  `document.createElement(#{tag})`\n}","arguments":[{"type":"String","name":"tag"}]},{"type":"Promise(Void)","description":"<p>Tries to focus the given element (if exists) in the next 150 milliseconds.\nFails silently if there is no element or if the element cannot be focused.</p>\n<pre><code>&quot;my-id&quot;\n|&gt; Dom.focus\n|&gt; Dom.getElementById()\n</code></pre>\n","name":"focus","source":"/*\nTries to focus the given element (if exists) in the next 150 milliseconds.\nFails silently if there is no element or if the element cannot be focused.\n\n  \"my-id\"\n  |> Dom.focus\n  |> Dom.getElementById()\n*/\nfun focus (maybeElement : Maybe(Dom.Element)) : Promise(Void) {\n  case maybeElement {\n    Maybe.Just(element) =>\n      {\n        focusWhenVisible(element)\n        Promise.resolve(void)\n      }\n\n    Maybe.Nothing => Promise.resolve(void)\n  }\n}","arguments":[{"type":"Maybe(Dom.Element)","name":"maybeElement"}]},{"type":"Promise(Void)","description":"<p>Focuses the first focusable descendant of the given element.</p>\n","name":"focusFirst","source":"/* Focuses the first focusable descendant of the given element. */\nfun focusFirst (element : Dom.Element) : Promise(Void) {\n  element\n  |> getFocusableElements\n  |> Array.first\n  |> focus\n}","arguments":[{"type":"Dom.Element","name":"element"}]},{"type":"Promise(Result(String, Void))","description":"<p>Tries to focus the given element in the next 150 milliseconds.</p>\n<pre><code>&quot;my-div&quot;\n|&gt; Dom.getElementById\n|&gt; Dom.focusWhenVisible()\n</code></pre>\n","name":"focusWhenVisible","source":"/*\nTries to focus the given element in the next 150 milliseconds.\n\n  \"my-div\"\n  |> Dom.getElementById\n  |> Dom.focusWhenVisible()\n*/\nfun focusWhenVisible (element : Dom.Element) : Promise(Result(String, Void)) {\n  `\n    new Promise((resolve) => {\n      let counter = 0\n\n      let focus = () => {\n        if (counter > 15) {\n          resolve(#{Result::Err(\"Could not focus the element in 150ms. Is it visible?\")})\n        }\n\n        #{element}.focus()\n\n        if (document.activeElement != #{element}) {\n          counter++\n          setTimeout(focus, 10)\n        } else {\n          resolve(#{Result::Ok(void)})\n        }\n      }\n\n      focus()\n    })\n    `\n}","arguments":[{"type":"Dom.Element","name":"element"}]},{"type":"Maybe(Dom.Element)","description":"<p>Returns the active (focused) element of the page.</p>\n<pre><code>Dom.getActiveElement() == Dom.getElementBySelector(&quot;body&quot;)\n</code></pre>\n","name":"getActiveElement","source":"/*\nReturns the active (focused) element of the page.\n\n  Dom.getActiveElement() == Dom.getElementBySelector(\"body\")\n*/\nfun getActiveElement : Maybe(Dom.Element) {\n  `\n    (() => {\n      if (document.activeElement) {\n        return #{Maybe::Just(`document.activeElement`)}\n      } else {\n        return #{Maybe::Nothing}\n      }\n    })()\n    `\n}","arguments":[]},{"type":"Maybe(String)","description":"<p>If the attribute is present, it will return its value on the given element.</p>\n<pre><code>outcome =\n  Dom.getElementById(&quot;my-div&quot;)\n\ncase (outcome) {\n  Maybe::Just(element) =&gt; Dom.getAttribute(element, &quot;id&quot;) == &quot;my-div&quot;\n  Maybe::Nothing =&gt; false\n}\n</code></pre>\n","name":"getAttribute","source":"/*\nIf the attribute is present, it will return its value on the given element.\n\n  outcome =\n    Dom.getElementById(\"my-div\")\n\n  case (outcome) {\n    Maybe::Just(element) => Dom.getAttribute(element, \"id\") == \"my-div\"\n    Maybe::Nothing => false\n  }\n*/\nfun getAttribute (element : Dom.Element, name : String) : Maybe(String) {\n  `\n    (() => {\n      const value = #{element}.getAttribute(#{name})\n\n      if (value === \"\") {\n        return #{Maybe::Nothing}\n      } else {\n        return #{Maybe::Just(`value`)}\n      }\n    })()\n    `\n}","arguments":[{"type":"Dom.Element","name":"element"},{"type":"String","name":"name"}]},{"type":"Array(Dom.Element)","description":"<p>Returns all child elements of the given element.</p>\n<pre><code>Dom.getChildren())\n</code></pre>\n","name":"getChildren","source":"/*\nReturns all child elements of the given element.\n\n  Dom.getChildren())\n*/\nfun getChildren (element : Dom.Element) : Array(Dom.Element) {\n  `Array.from(#{element}.children)`\n}","arguments":[{"type":"Dom.Element","name":"element"}]},{"type":"Number","description":"<p>Returns the <code>clientHeight</code> of the given element.</p>\n<pre><code>Dom.getClientHeight(div) == 200\n</code></pre>\n","name":"getClientHeight","source":"/*\nReturns the `clientHeight` of the given element.\n\n  Dom.getClientHeight(div) == 200\n*/\nfun getClientHeight (element : Dom.Element) : Number {\n  `#{element}.clientHeight || 0`\n}","arguments":[{"type":"Dom.Element","name":"element"}]},{"type":"Number","description":"<p>Returns the <code>clientWidth</code> of the given element.</p>\n<pre><code>Dom.getClientWidth(div) == 200\n</code></pre>\n","name":"getClientWidth","source":"/*\nReturns the `clientWidth` of the given element.\n\n  Dom.getClientWidth(div) == 200\n*/\nfun getClientWidth (element : Dom.Element) : Number {\n  `#{element}.clientWidth || 0`\n}","arguments":[{"type":"Dom.Element","name":"element"}]},{"type":"Dom.Dimensions","description":"<p>Returns the dimensions (BoundingClientRect) of a <code>Dom.Element</code></p>\n<pre><code>Dom.getDimensions(Dom.createElement(&quot;div&quot;)) = {\n  bottom: 0,\n  height: 0,\n  width: 0,\n  right: 0,\n  left: 0,\n  top: 0,\n  x: 0,\n  y: 0\n}\n</code></pre>\n","name":"getDimensions","source":"/*\nReturns the dimensions (BoundingClientRect) of a `Dom.Element`\n\n  Dom.getDimensions(Dom.createElement(\"div\")) = {\n    bottom: 0,\n    height: 0,\n    width: 0,\n    right: 0,\n    left: 0,\n    top: 0,\n    x: 0,\n    y: 0\n  }\n*/\nfun getDimensions (dom : Dom.Element) : Dom.Dimensions {\n  `\n    (() => {\n      const rect = #{dom}.getBoundingClientRect()\n\n      return #{{\n        bottom: `rect.bottom`,\n        height: `rect.height`,\n        width: `rect.width`,\n        right: `rect.right`,\n        left: `rect.left`,\n        top: `rect.top`,\n        x: `rect.x`,\n        y: `rect.y`\n      }}\n    })()\n    `\n}","arguments":[{"type":"Dom.Element","name":"dom"}]},{"type":"Maybe(Dom.Element)","description":"<p>Gets the element with the given id from anywhere in the page.</p>\n<pre><code>Dom.getElementById(&quot;my-div&quot;)\n</code></pre>\n","name":"getElementById","source":"/*\nGets the element with the given id from anywhere in the page.\n\n  Dom.getElementById(\"my-div\")\n*/\nfun getElementById (id : String) : Maybe(Dom.Element) {\n  `\n    (() => {\n      let element = document.getElementById(#{id})\n\n      if (element) {\n        return #{Maybe::Just(`element`)}\n      } else {\n        return #{Maybe::Nothing}\n      }\n    })()\n    `\n}","arguments":[{"type":"String","name":"id"}]},{"type":"Maybe(Dom.Element)","description":"<p>Gets the first element to match the given selector from anywhere in the page.</p>\n<pre><code>Dom.getElementBySelector(&quot;body section &gt; p:first-child&quot;)\n</code></pre>\n","name":"getElementBySelector","source":"/*\nGets the first element to match the given selector from anywhere in the page.\n\n  Dom.getElementBySelector(\"body section > p:first-child\")\n*/\nfun getElementBySelector (selector : String) : Maybe(Dom.Element) {\n  `\n    (() => {\n      try {\n        let element = document.querySelector(#{selector})\n\n        if (element) {\n          return #{Maybe::Just(`element`)}\n        } else {\n          return #{Maybe::Nothing}\n        }\n      } catch (error) {\n        return #{Maybe::Nothing}\n      }\n    })()\n    `\n}","arguments":[{"type":"String","name":"selector"}]},{"type":"Maybe(Dom.Element)","description":"<p>Gets the element from a point on the screen.</p>\n<pre><code>Dom.getElementFromPoint(0, 0)\n</code></pre>\n","name":"getElementFromPoint","source":"/*\nGets the element from a point on the screen.\n\n  Dom.getElementFromPoint(0, 0)\n*/\nfun getElementFromPoint (left : Number, top : Number) : Maybe(Dom.Element) {\n  `\n    (() => {\n      const element = document.elementFromPoint(#{left}, #{top})\n\n      if (element) {\n        return #{Maybe::Just(`element`)}\n      } else {\n        return #{Maybe::Nothing}\n      }\n    })()\n    `\n}","arguments":[{"type":"Number","name":"left"},{"type":"Number","name":"top"}]},{"type":"Array(Dom.Element)","description":"<p>Gets all descendant elements of an element which are matching\nthe given selector.</p>\n<pre><code>Dom.getElementsBySelector(element, &quot;a[name]&quot;)\n</code></pre>\n","name":"getElementsBySelector","source":"/*\nGets all descendant elements of an element which are matching\nthe given selector.\n\n  Dom.getElementsBySelector(element, \"a[name]\")\n*/\nfun getElementsBySelector (element : Dom.Element, selector : String) : Array(Dom.Element) {\n  `Array.from(#{element}.querySelectorAll(#{selector}))`\n}","arguments":[{"type":"Dom.Element","name":"element"},{"type":"String","name":"selector"}]},{"type":"Array(Dom.Element)","description":"<p>Returns all focusable descendant elements.</p>\n","name":"getFocusableElements","source":"/* Returns all focusable descendant elements. */\nfun getFocusableElements (element : Dom.Element) : Array(Dom.Element) {\n  `\n    (() => {\n      /* Save focused element. */\n      const focused = document.activeElement\n\n      /* Save scroll position. */\n      const scrollX = window.scrollX\n      const scrollY = window.scrollY\n\n      /* Save the scroll position of each element. */\n      const scrollPositions =\n        Array.from(document.querySelectorAll(\"*\")).reduce((memo, element) => {\n          if (element.scrollHeight > 0 || element.scrollWidth > 0) {\n            memo.set(element, [element.scrollLeft, element.scrollTop])\n          }\n\n          return memo\n        }, new Map)\n\n      /* Gather the focusable elements by focusing them and comparing it\n         with the focused element. */\n      const foundElements =\n        Array.from(#{element}.querySelectorAll(\"*\")).reduce((memo ,element) => {\n          element.focus()\n          if (document.activeElement == element && element.tabIndex !== -1) {\n            memo.push(element)\n          }\n\n          return memo\n        }, [])\n\n      /* Restore scroll positions and focus. */\n      for (let element in scrollPositions) {\n        const [x, y] = scrollPositions[element]\n        element.scrollTo(x, y)\n      }\n\n      window.scrollTo(scrollX, scrollY)\n      focused.focus()\n\n      return foundElements\n    })()\n    `\n}","arguments":[{"type":"Dom.Element","name":"element"}]},{"type":"Number","description":"<p>Returns the scrollable height of the given element.</p>\n<pre><code>Dom.getScrollHeight(div) == 0\n</code></pre>\n","name":"getScrollHeight","source":"/*\nReturns the scrollable height of the given element.\n\n  Dom.getScrollHeight(div) == 0\n*/\nfun getScrollHeight (element : Dom.Element) : Number {\n  `#{element}.scrollHeight || 0`\n}","arguments":[{"type":"Dom.Element","name":"element"}]},{"type":"Number","description":"<p>Returns the horizontal scroll position of the given element.</p>\n<pre><code>Dom.getScrollLeft(div) == 0\n</code></pre>\n","name":"getScrollLeft","source":"/*\nReturns the horizontal scroll position of the given element.\n\n  Dom.getScrollLeft(div) == 0\n*/\nfun getScrollLeft (element : Dom.Element) : Number {\n  `#{element}.scrollLeft || 0`\n}","arguments":[{"type":"Dom.Element","name":"element"}]},{"type":"Number","description":"<p>Returns the vertical scroll position of the given element.</p>\n<pre><code>Dom.getScrollTop(div) == 0\n</code></pre>\n","name":"getScrollTop","source":"/*\nReturns the vertical scroll position of the given element.\n\n  Dom.getScrollTop(div) == 0\n*/\nfun getScrollTop (element : Dom.Element) : Number {\n  `#{element}.scrollTop || 0`\n}","arguments":[{"type":"Dom.Element","name":"element"}]},{"type":"Number","description":"<p>Returns the scrollable width of the given element.</p>\n<pre><code>Dom.getScrollWidth(div) == 300\n</code></pre>\n","name":"getScrollWidth","source":"/*\nReturns the scrollable width of the given element.\n\n  Dom.getScrollWidth(div) == 300\n*/\nfun getScrollWidth (element : Dom.Element) : Number {\n  `#{element}.scrollWidth || 0`\n}","arguments":[{"type":"Dom.Element","name":"element"}]},{"type":"Array(Tuple(String, String, String))","description":"<p>Returns the table of contents of the given element for the given selectors.</p>\n<pre><code>Dom.getTableOfContents(element, &quot;h1, h2, h3, h4&quot;) == [\n  {&quot;h1&quot;, &quot;The title of the page&quot;, &quot;the-title-of-the-page&quot;},\n  {&quot;h2&quot;, &quot;A subtitle of the page&quot;, &quot;a-subtitle-of-the-page&quot;},\n  {&quot;h3&quot;, &quot;A sub-subtitle of the page&quot;, &quot;a-sub-subtitle-of-the-page&quot;}\n]\n</code></pre>\n","name":"getTableOfContents","source":"/*\nReturns the table of contents of the given element for the given selectors.\n\n  Dom.getTableOfContents(element, \"h1, h2, h3, h4\") == [\n    {\"h1\", \"The title of the page\", \"the-title-of-the-page\"},\n    {\"h2\", \"A subtitle of the page\", \"a-subtitle-of-the-page\"},\n    {\"h3\", \"A sub-subtitle of the page\", \"a-sub-subtitle-of-the-page\"}\n  ]\n*/\nfun getTableOfContents (element : Dom.Element, selector : String) : Array(Tuple(String, String, String)) {\n  element\n  |> getElementsBySelector(selector)\n  |> Array.map(\n    (item : Dom.Element) : Tuple(String, String, String) {\n      let tag =\n        item\n        |> getTagName()\n        |> String.toLowerCase()\n\n      let text =\n        getTextContent(item)\n\n      let hash =\n        String.parameterize(text)\n\n      #(tag, text, hash)\n    })\n}","arguments":[{"type":"Dom.Element","name":"element"},{"type":"String","name":"selector"}]},{"type":"String","description":"<p>Returns the tagname of the given element.</p>\n<pre><code>(&quot;body&quot;\n|&gt; Dom.getElementBySelector(&quot;body&quot;)\n|&gt; Dom.getTagName) == &quot;BODY&quot;\n</code></pre>\n","name":"getTagName","source":"/*\nReturns the tagname of the given element.\n\n  (\"body\"\n  |> Dom.getElementBySelector(\"body\")\n  |> Dom.getTagName) == \"BODY\"\n*/\nfun getTagName (element : Dom.Element) : String {\n  `#{element}.tagName`\n}","arguments":[{"type":"Dom.Element","name":"element"}]},{"type":"String","description":"<p>Returns the text content of the given element.</p>\n<pre><code>Dom.getTextContent(Dom.getElementBySelector(&quot;body&quot;))\n</code></pre>\n","name":"getTextContent","source":"/*\nReturns the text content of the given element.\n\n  Dom.getTextContent(Dom.getElementBySelector(\"body\"))\n*/\nfun getTextContent (element : Dom.Element) : String {\n  `#{element}.textContent`\n}","arguments":[{"type":"Dom.Element","name":"element"}]},{"type":"Number","description":"<p>Measures the given text width with the given font using the canvas.</p>\n<pre><code>Dom.getTextWidth(&quot;Hello There&quot;, &quot;20px sans-serif&quot;) = 300\n</code></pre>\n","name":"getTextWidth","source":"/*\nMeasures the given text width with the given font using the canvas.\n\n  Dom.getTextWidth(\"Hello There\", \"20px sans-serif\") = 300\n*/\nfun getTextWidth (text : String, font : String) : Number {\n  `\n    (() => {\n      const canvas = document.createElement('canvas');\n      const context = canvas.getContext(\"2d\");\n\n      context.font = #{font};\n\n      return context.measureText(#{text}).width\n    })()\n    `\n}","arguments":[{"type":"String","name":"text"},{"type":"String","name":"font"}]},{"type":"String","description":"<p>Gets the value as string form a <code>Dom.Element</code>.</p>\n<p>If the element supports value it will return it, otherwise it returns an\nempty string.</p>\n<pre><code>Dom.getValue(&quot;input[value=hello]&quot;) == &quot;hello&quot;\nDom.getValue(&quot;div&quot;) == &quot;&quot;\n</code></pre>\n","name":"getValue","source":"/*\nGets the value as string form a `Dom.Element`.\n\nIf the element supports value it will return it, otherwise it returns an\nempty string.\n\n  Dom.getValue(\"input[value=hello]\") == \"hello\"\n  Dom.getValue(\"div\") == \"\"\n*/\nfun getValue (dom : Dom.Element) : String {\n  `\n    (() => {\n      let value = #{dom}.value\n\n      if (typeof value === \"string\") {\n        return value\n      } else {\n        return \"\"\n      }\n    })()\n    `\n}","arguments":[{"type":"Dom.Element","name":"dom"}]},{"type":"Bool","description":"<p>Returns whether or not the given <code>Dom.Element</code> matches the given selector.</p>\n<pre><code>Dom.matches(Dom.createElement(&quot;div&quot;), &quot;div&quot;) == true\nDom.matches(Dom.createElement(&quot;div&quot;), &quot;p&quot;) == false\n</code></pre>\n","name":"matches","source":"/*\nReturns whether or not the given `Dom.Element` matches the given selector.\n\n  Dom.matches(Dom.createElement(\"div\"), \"div\") == true\n  Dom.matches(Dom.createElement(\"div\"), \"p\") == false\n*/\nfun matches (dom : Dom.Element, selector : String) : Bool {\n  `\n    (() => {\n      try {\n        return #{dom}.matches(#{selector})\n      } catch (error) {\n        return false\n      }\n    })()\n    `\n}","arguments":[{"type":"Dom.Element","name":"dom"},{"type":"String","name":"selector"}]},{"type":"Promise(Void)","description":"<p>Scrolls the given element to the given position.</p>\n<pre><code>Dom.scrollTo(element, 10, 10)\n</code></pre>\n","name":"scrollTo","source":"/*\nScrolls the given element to the given position.\n\n  Dom.scrollTo(element, 10, 10)\n*/\nfun scrollTo (element : Dom.Element, left : Number, top : Number) : Promise(Void) {\n  `#{element}.scrollTo({\n        left: #{left},\n        top: #{top}\n      })`\n}","arguments":[{"type":"Dom.Element","name":"element"},{"type":"Number","name":"left"},{"type":"Number","name":"top"}]},{"type":"Dom.Element","description":"<p>Sets the given attribute to the given value of the given element and\nreturns the element.</p>\n<pre><code>&quot;a&quot;\n|&gt; Dom.createElement\n|&gt; Dom.setAttribute(&quot;name&quot;, &quot;test&quot;)\n</code></pre>\n","name":"setAttribute","source":"/*\nSets the given attribute to the given value of the given element and\nreturns the element.\n\n  \"a\"\n  |> Dom.createElement\n  |> Dom.setAttribute(\"name\", \"test\")\n*/\nfun setAttribute (\n  element : Dom.Element,\n  attribute : String,\n  value : String\n) : Dom.Element {\n  `#{element}.setAttribute(#{attribute}, #{value}) && element`\n}","arguments":[{"type":"Dom.Element","name":"element"},{"type":"String","name":"attribute"},{"type":"String","name":"value"}]},{"type":"Dom.Element","description":"<p>Sets the given style to the given value of the given element.</p>\n<pre><code>&quot;my-div&quot;\n|&gt; Dom.getElementById()\n|&gt; Dom.setStyle(&quot;background&quot;, &quot;red&quot;)\n|&gt; Dom.setStyle(&quot;color&quot;, &quot;white&quot;)\n</code></pre>\n","name":"setStyle","source":"/*\nSets the given style to the given value of the given element.\n\n  \"my-div\"\n  |> Dom.getElementById()\n  |> Dom.setStyle(\"background\", \"red\")\n  |> Dom.setStyle(\"color\", \"white\")\n*/\nfun setStyle (element : Dom.Element, name : String, value : String) : Dom.Element {\n  `\n    (() => {\n      #{element}.style[#{name}] = #{value}\n      return #{element}\n    })()\n    `\n}","arguments":[{"type":"Dom.Element","name":"element"},{"type":"String","name":"name"},{"type":"String","name":"value"}]},{"type":"Dom.Element","description":"<p>Sets the value property of a <code>Dom.Element</code>.</p>\n<p>It is used to set the value of <code>input</code> fields programmatically.</p>\n","name":"setValue","source":"/*\nSets the value property of a `Dom.Element`.\n\nIt is used to set the value of `input` fields programmatically.\n*/\nfun setValue (dom : Dom.Element, value : String) : Dom.Element {\n  `(#{dom}.value = #{value}) && #{dom}`\n}","arguments":[{"type":"Dom.Element","name":"dom"},{"type":"String","name":"value"}]},{"type":"Promise(Void)","description":"<p>Smooth scroll the given element to the given position.</p>\n<pre><code>Dom.smoothScrollTo(element, 10, 10)\n</code></pre>\n","name":"smoothScrollTo","source":"/*\nSmooth scroll the given element to the given position.\n\n  Dom.smoothScrollTo(element, 10, 10)\n*/\nfun smoothScrollTo (element : Dom.Element, left : Number, top : Number) : Promise(Void) {\n  `#{element}.scrollTo({\n        behavior: 'smooth',\n        left: #{left},\n        top: #{top}\n      })`\n}","arguments":[{"type":"Dom.Element","name":"element"},{"type":"Number","name":"left"},{"type":"Number","name":"top"}]}]},{"description":null,"name":"Dom.Dimensions","functions":[{"type":"Dom.Dimensions","description":"<p>Returns an empty Dom.Dimensions record.</p>\n","name":"empty","source":"/* Returns an empty Dom.Dimensions record. */\nfun empty : Dom.Dimensions {\n  {\n    bottom: 0,\n    height: 0,\n    width: 0,\n    right: 0,\n    left: 0,\n    top: 0,\n    x: 0,\n    y: 0\n  }\n}","arguments":[]}]},{"description":null,"name":"File","functions":[{"type":"Void","description":"<p>Prompts a dialog for the saving the given file.</p>\n<pre><code>file = await File.select(*)\n\nFile.download(file)\n</code></pre>\n","name":"download","source":"/*\nPrompts a dialog for the saving the given file.\n\n  file = await File.select(*)\n\n  File.download(file)\n*/\nfun download (file : File) : Void {\n  let url =\n    Url.createObjectUrlFromFile(file)\n\n  `\n    (() => {\n      const anchor = document.createElement('a')\n      anchor.download = #{file}.name\n      anchor.href = #{url}\n      anchor.click()\n    })()\n    `\n\n  Url.revokeObjectUrl(url)\n}","arguments":[{"type":"File","name":"file"}]},{"type":"File","description":"<p>Creates a new file from the contents, name and mime-type.</p>\n<pre><code>File.fromString(&quot;Some contents...&quot;, &quot;test.txt&quot;, &quot;text/plain&quot;)\n</code></pre>\n","name":"fromString","source":"/*\nCreates a new file from the contents, name and mime-type.\n\n  File.fromString(\"Some contents...\", \"test.txt\", \"text/plain\")\n*/\nfun fromString (contents : String, name : String, type : String) : File {\n  `new File([#{contents}], #{name}, { type: #{type} })`\n}","arguments":[{"type":"String","name":"contents"},{"type":"String","name":"name"},{"type":"String","name":"type"}]},{"type":"String","description":"<p>Returns the mime type of the file.</p>\n<pre><code>(File.fromString(&quot;Some contents...&quot;, &quot;test.txt&quot;, &quot;text/plain&quot;)\n|&gt; File.mimeType()) == &quot;text/plain&quot;\n</code></pre>\n","name":"mimeType","source":"/*\nReturns the mime type of the file.\n\n  (File.fromString(\"Some contents...\", \"test.txt\", \"text/plain\")\n  |> File.mimeType()) == \"text/plain\"\n*/\nfun mimeType (file : File) : String {\n  `#{file}.type`\n}","arguments":[{"type":"File","name":"file"}]},{"type":"String","description":"<p>Returns the name of the file.</p>\n<pre><code>(File.fromString(&quot;Some contents...&quot;, &quot;test.txt&quot;, &quot;text/plain&quot;)\n|&gt; File.name()) == &quot;test.txt&quot;\n</code></pre>\n","name":"name","source":"/*\nReturns the name of the file.\n\n  (File.fromString(\"Some contents...\", \"test.txt\", \"text/plain\")\n  |> File.name()) == \"test.txt\"\n*/\nfun name (file : File) : String {\n  `#{file}.name`\n}","arguments":[{"type":"File","name":"file"}]},{"type":"Promise(ArrayBuffer)","description":"<p>Reads the contents of the given file as a String.</p>\n<pre><code>file =\n  File.create(&quot;Some content...&quot;, &quot;test.txt&quot;, &quot;text/plain&quot;)\n\nFile.readAsArrayBuffer(file)\n</code></pre>\n","name":"readAsArrayBuffer","source":"/*\nReads the contents of the given file as a String.\n\n  file =\n    File.create(\"Some content...\", \"test.txt\", \"text/plain\")\n\n  File.readAsArrayBuffer(file)\n*/\nfun readAsArrayBuffer (file : File) : Promise(ArrayBuffer) {\n  `\n    (() => {\n      const reader = new FileReader()\n\n      return new Promise((resolve, reject) => {\n        reader.addEventListener('load', (event) => { resolve(reader.result) })\n        reader.readAsArrayBuffer(#{file})\n      })\n    })()\n    `\n}","arguments":[{"type":"File","name":"file"}]},{"type":"Promise(String)","description":"<p>Reads the contents of the given file as a Data URL.</p>\n<pre><code>files =\n  await File.select(&quot;text/plain&quot;)\n\nurl =\n  File.readAsDataURL(file)\n\nurl == &quot;data:text/plain;....&quot;\n</code></pre>\n","name":"readAsDataURL","source":"/*\nReads the contents of the given file as a Data URL.\n\n  files =\n    await File.select(\"text/plain\")\n\n  url =\n    File.readAsDataURL(file)\n\n  url == \"data:text/plain;....\"\n*/\nfun readAsDataURL (file : File) : Promise(String) {\n  `\n    (() => {\n      const reader = new FileReader()\n\n      return new Promise((resolve, reject) => {\n        reader.addEventListener('load', (event) => { resolve(reader.result) })\n        reader.readAsDataURL(#{file})\n      })\n    })()\n    `\n}","arguments":[{"type":"File","name":"file"}]},{"type":"Promise(String)","description":"<p>Reads the contents of the given file as a String.</p>\n<pre><code>file =\n  File.create(&quot;Some content...&quot;, &quot;test.txt&quot;, &quot;text/plain&quot;)\n\nurl =\n  await File.readAsString(file)\n\nurl == &quot;Some content...&quot;\n</code></pre>\n","name":"readAsString","source":"/*\nReads the contents of the given file as a String.\n\n  file =\n    File.create(\"Some content...\", \"test.txt\", \"text/plain\")\n\n  url =\n    await File.readAsString(file)\n\n  url == \"Some content...\"\n*/\nfun readAsString (file : File) : Promise(String) {\n  `\n    (() => {\n      const reader = new FileReader()\n\n      return new Promise((resolve, reject) => {\n        reader.addEventListener('load', (event) => { resolve(reader.result) })\n        reader.readAsText(#{file})\n      })\n    })()\n    `\n}","arguments":[{"type":"File","name":"file"}]},{"type":"Promise(File)","description":"<p>Opens the browsers file dialog for selecting a single file.</p>\n<ul>\n<li>\n<p>The mime type can be restricted to the given one.</p>\n</li>\n<li>\n<p>It might not resolve if the user cancels the dialog.</p>\n<p>file =\nawait File.select(&quot;application/json&quot;)</p>\n<p>Debug.log(file)</p>\n</li>\n</ul>\n","name":"select","source":"/*\nOpens the browsers file dialog for selecting a single file.\n\n* The mime type can be restricted to the given one.\n* It might not resolve if the user cancels the dialog.\n\n  file =\n    await File.select(\"application/json\")\n\n  Debug.log(file)\n*/\nfun select (accept : String) : Promise(File) {\n  `\n    (() => {\n      const input = document.createElement('input')\n\n      input.style.position = 'absolute'\n      input.style.height = '1px'\n      input.style.width = '1px'\n      input.style.left = '-1px'\n      input.style.top = '-1px'\n\n      input.accept = #{accept}\n      input.type = 'file'\n\n      document.body.appendChild(input)\n\n      return new Promise((resolve) => {\n        input.addEventListener('change', () => {\n          resolve(input.files[0])\n        })\n        input.click()\n        document.body.removeChild(input)\n      })\n    })()\n    `\n}","arguments":[{"type":"String","name":"accept"}]},{"type":"Promise(Array(File))","description":"<p>Opens the browsers file dialog for selecting multiple files.</p>\n<ul>\n<li>\n<p>The mime type can be restricted to the given one.</p>\n</li>\n<li>\n<p>It might not resolve if the user cancels the dialog.</p>\n<p>files =\nawait File.selectMultiple(&quot;application/json&quot;)</p>\n<p>Debug.log(files)</p>\n</li>\n</ul>\n","name":"selectMultiple","source":"/*\nOpens the browsers file dialog for selecting multiple files.\n\n* The mime type can be restricted to the given one.\n* It might not resolve if the user cancels the dialog.\n\n  files =\n    await File.selectMultiple(\"application/json\")\n\n  Debug.log(files)\n*/\nfun selectMultiple (accept : String) : Promise(Array(File)) {\n  `\n    (() => {\n      const input = document.createElement('input')\n\n      input.style.position = 'absolute'\n      input.style.height = '1px'\n      input.style.width = '1px'\n      input.style.left = '-1px'\n      input.style.top = '-1px'\n\n      input.accept = #{accept}\n      input.multiple = true\n      input.type = 'file'\n\n      document.body.appendChild(input)\n\n      return new Promise((resolve, reject) => {\n        input.addEventListener('change', () => {\n          resolve(Array.from(input.files))\n        })\n\n        input.click()\n        document.body.removeChild(input)\n      })\n    })()\n    `\n}","arguments":[{"type":"String","name":"accept"}]},{"type":"Number","description":"<p>Returns the size of the file in bytes.</p>\n<pre><code>(File.fromString(&quot;Some contents...&quot;, &quot;test.txt&quot;, &quot;text/plain&quot;)\n|&gt; File.size()) == 16\n</code></pre>\n","name":"size","source":"/*\nReturns the size of the file in bytes.\n\n  (File.fromString(\"Some contents...\", \"test.txt\", \"text/plain\")\n  |> File.size()) == 16\n*/\nfun size (file : File) : Number {\n  `#{file}.size`\n}","arguments":[{"type":"File","name":"file"}]}]},{"description":null,"name":"FileSize","functions":[{"type":"String","description":"<p>Formats a number as a file size.</p>\n<pre><code>FileSize.format(0) == &quot;0 B&quot;\nFileSize.format(1024) == &quot;1 kB&quot;\nFileSize.format(1048576) == &quot;1 MB&quot;\nFileSize.format(1073741824) == &quot;1 GB&quot;\n</code></pre>\n","name":"format","source":"/*\nFormats a number as a file size.\n\n  FileSize.format(0) == \"0 B\"\n  FileSize.format(1024) == \"1 kB\"\n  FileSize.format(1048576) == \"1 MB\"\n  FileSize.format(1073741824) == \"1 GB\"\n*/\nfun format (size : Number) : String {\n  `\n    (() => {\n      if (#{size} == 0){\n        return \"0 B\"\n      } else {\n        const index = Math.floor(Math.log(#{size}) / Math.log(1024));\n        const affix = ['B', 'kB', 'MB', 'GB', 'TB'][index]\n        return (#{size} / Math.pow(1024, index)).toFixed(2) * 1 + ' ' + affix;\n      }\n    })()\n    `\n}","arguments":[{"type":"Number","name":"size"}]}]},{"description":null,"name":"FormData","functions":[{"type":"FormData","description":"<p>Returns a new FormData object copying all values from the given one and\nadding the given file with the given key.</p>\n<pre><code>FormData.empty()\n|&gt; FormData.addFile(\n  &quot;key&quot;, File.fromString(&quot;Contents&quot;, &quot;text.txt&quot;, &quot;text/plain&quot;))\n</code></pre>\n","name":"addFile","source":"/*\nReturns a new FormData object copying all values from the given one and\nadding the given file with the given key.\n\n  FormData.empty()\n  |> FormData.addFile(\n    \"key\", File.fromString(\"Contents\", \"text.txt\", \"text/plain\"))\n*/\nfun addFile (formData : FormData, key : String, value : File) : FormData {\n  `\n     (() => {\n      var newFormData = new FormData();\n\n      for(let pair of #{formData}.entries()) {\n        newFormData.append(pair[0], pair[1])\n      }\n\n      newFormData.append(#{key}, #{value})\n\n      return newFormData\n    })()\n    `\n}","arguments":[{"type":"FormData","name":"formData"},{"type":"String","name":"key"},{"type":"File","name":"value"}]},{"type":"FormData","description":"<p>Returns a new FormData object copying all values from the given one and\nadding the given string with the given key.</p>\n<pre><code>FormData.empty()\n|&gt; FormData.addString(&quot;key&quot;, &quot;value&quot;)\n</code></pre>\n","name":"addString","source":"/*\nReturns a new FormData object copying all values from the given one and\nadding the given string with the given key.\n\n  FormData.empty()\n  |> FormData.addString(\"key\", \"value\")\n*/\nfun addString (formData : FormData, key : String, value : String) : FormData {\n  `\n     (() => {\n      var newFormData = new FormData();\n\n      for(let pair of #{formData}.entries()) {\n        newFormData.append(pair[0], pair[1])\n      }\n\n      newFormData.append(#{key}, #{value})\n\n      return newFormData\n    })()\n    `\n}","arguments":[{"type":"FormData","name":"formData"},{"type":"String","name":"key"},{"type":"String","name":"value"}]},{"type":"FormData","description":"<p>Returns an empty FormData object.</p>\n<pre><code>FormData.empty()\n|&gt; FormData.addString(&quot;key&quot;, &quot;value&quot;)\n</code></pre>\n","name":"empty","source":"/*\nReturns an empty FormData object.\n\n  FormData.empty()\n  |> FormData.addString(\"key\", \"value\")\n*/\nfun empty : FormData {\n  `new FormData`\n}","arguments":[]},{"type":"Array(String)","description":"<p>Returns the keys of a FormData object.</p>\n<pre><code>FormData.empty()\n|&gt; FormData.addString(&quot;key&quot;, &quot;value&quot;)\n|&gt; FormData.keys() == [&quot;key&quot;]\n</code></pre>\n","name":"keys","source":"/*\nReturns the keys of a FormData object.\n\n  FormData.empty()\n  |> FormData.addString(\"key\", \"value\")\n  |> FormData.keys() == [\"key\"]\n*/\nfun keys (formData : FormData) : Array(String) {\n  `Array.from(#{formData}.keys())`\n}","arguments":[{"type":"FormData","name":"formData"}]}]},{"description":null,"name":"Function","functions":[{"type":"Function(a)","description":"<p>Debounces a function without arguments.</p>\n<pre><code>Function.debounce(() { Debug.log(&quot;Hello World!&quot;) }, 100)\n</code></pre>\n","name":"debounce","source":"/*\nDebounces a function without arguments.\n\n  Function.debounce(() { Debug.log(\"Hello World!\") }, 100)\n*/\nfun debounce (method : Function(a), delay : Number) : Function(a) {\n  `\n    (() => {\n      let _id;\n\n      return () => {\n        clearTimeout(_id);\n        _id = setTimeout(() => #{method}(), #{delay});\n      }\n    })()\n    `\n}","arguments":[{"type":"Function(a)","name":"method"},{"type":"Number","name":"delay"}]},{"type":"Function(a, b)","description":"<p>Debounces a function with only one argument.</p>\n<pre><code>Function.debounce1((argument : String) { Debug.log(argument) }, 100)\n</code></pre>\n","name":"debounce1","source":"/*\nDebounces a function with only one argument.\n\n  Function.debounce1((argument : String) { Debug.log(argument) }, 100)\n*/\nfun debounce1 (method : Function(a, b), delay : Number) : Function(a, b) {\n  `\n    (() => {\n      let _id;\n\n      return _arg => {\n        clearTimeout(_id);\n        _id = setTimeout(() => #{method}(_arg), #{delay});\n      }\n    })()\n    `\n}","arguments":[{"type":"Function(a, b)","name":"method"},{"type":"Number","name":"delay"}]}]},{"description":null,"name":"Html","functions":[{"type":"Html","description":"<p>Returns an empty Html node. It is useful for example if you don't want to\nrender something conditionally.</p>\n<pre><code>if (Array.isEmpty(items)) {\n  Html.empty()\n} else {\n  &lt;div&gt;\n    &lt;{ items }&gt;\n  &lt;/div&gt;\n}\n</code></pre>\n","name":"empty","source":"/*\nReturns an empty Html node. It is useful for example if you don't want to\nrender something conditionally.\n\n  if (Array.isEmpty(items)) {\n    Html.empty()\n  } else {\n    <div>\n      <{ items }>\n    </div>\n  }\n*/\nfun empty : Html {\n  `false`\n}","arguments":[]},{"type":"Bool","description":null,"name":"isNotEmpty","source":"fun isNotEmpty (element : Html) : Bool {\n  `!!#{element}`\n}","arguments":[{"type":"Html","name":"element"}]}]},{"description":null,"name":"Html.DataTransfer","functions":[{"type":"Html.DataTransfer","description":"<p>Removes the attached data.</p>\n","name":"clearData","source":"/* Removes the attached data. */\nfun clearData (data : Html.DataTransfer) : Html.DataTransfer {\n  `#{data}.clearData() || #{data}`\n}","arguments":[{"type":"Html.DataTransfer","name":"data"}]},{"type":"String","description":"<p>Returns string data for the given format or an empty string if there is no data.</p>\n","name":"getData","source":"/* Returns string data for the given format or an empty string if there is no data. */\nfun getData (data : Html.DataTransfer, format : String) : String {\n  `#{data}.getData(#{format})`\n}","arguments":[{"type":"Html.DataTransfer","name":"data"},{"type":"String","name":"format"}]},{"type":"String","description":"<p>Gets the type of drag-and-drop operation which is currently selected.</p>\n","name":"getDropEffect","source":"/* Gets the type of drag-and-drop operation which is currently selected. */\nfun getDropEffect (data : Html.DataTransfer) : String {\n  `#{data}.dropEffect`\n}","arguments":[{"type":"Html.DataTransfer","name":"data"}]},{"type":"String","description":"<p>Returns the type of operation that is possible.</p>\n","name":"getEffectAllowed","source":"/* Returns the type of operation that is possible. */\nfun getEffectAllowed (data : Html.DataTransfer) : String {\n  `#{data}.effectAllowed`\n}","arguments":[{"type":"Html.DataTransfer","name":"data"}]},{"type":"Array(File)","description":"<p>Returns the files which is contained in the data transfer.</p>\n","name":"getFiles","source":"/* Returns the files which is contained in the data transfer. */\nfun getFiles (data : Html.DataTransfer) : Array(File) {\n  `#{data}.files || []`\n}","arguments":[{"type":"Html.DataTransfer","name":"data"}]},{"type":"Array(String)","description":"<p>Returns the types of the data which is available.</p>\n","name":"getTypes","source":"/* Returns the types of the data which is available. */\nfun getTypes (data : Html.DataTransfer) : Array(String) {\n  `#{data}.types || []`\n}","arguments":[{"type":"Html.DataTransfer","name":"data"}]},{"type":"Html.DataTransfer","description":"<p>Sets the data fro the data transfer.</p>\n","name":"setData","source":"/* Sets the data fro the data transfer. */\nfun setData (\n  data : Html.DataTransfer,\n  format : String,\n  value : String\n) : Html.DataTransfer {\n  `#{data}.setData(#{format}, #{value}) || #{data}`\n}","arguments":[{"type":"Html.DataTransfer","name":"data"},{"type":"String","name":"format"},{"type":"String","name":"value"}]},{"type":"Html.DataTransfer","description":"<p>Sets the element as the drag image of the data transfer.</p>\n","name":"setDragImage","source":"/* Sets the element as the drag image of the data transfer. */\nfun setDragImage (\n  data : Html.DataTransfer,\n  element : Dom.Element,\n  offsetX : Number,\n  offsetY : Number\n) : Html.DataTransfer {\n  `#{data}.setDragImage(#{element}, #{offsetX}, #{offsetY}) || #{data}`\n}","arguments":[{"type":"Html.DataTransfer","name":"data"},{"type":"Dom.Element","name":"element"},{"type":"Number","name":"offsetX"},{"type":"Number","name":"offsetY"}]},{"type":"Html.DataTransfer","description":"<p>Sets the operation to a new type. The value must be <code>none</code>, <code>copy</code>, <code>link</code> or <code>move</code>.</p>\n","name":"setDropEffect","source":"/* Sets the operation to a new type. The value must be `none`, `copy`, `link` or `move`. */\nfun setDropEffect (data : Html.DataTransfer, value : String) : Html.DataTransfer {\n  `(#{data}.dropEffect = #{value}) && #{data}`\n}","arguments":[{"type":"Html.DataTransfer","name":"data"},{"type":"String","name":"value"}]},{"type":"Html.DataTransfer","description":"<p>Sets of the type of operation that are possible.</p>\n","name":"setEffectAllowed","source":"/* Sets of the type of operation that are possible. */\nfun setEffectAllowed (data : Html.DataTransfer, value : String) : Html.DataTransfer {\n  `(#{data}.effectAllowed = #{value}) && #{data}`\n}","arguments":[{"type":"Html.DataTransfer","name":"data"},{"type":"String","name":"value"}]}]},{"description":null,"name":"Html.Event","functions":[{"type":"Html.Event","description":"<p>Converts a native event into a Mint one.</p>\n","name":"fromEvent","source":"/* Converts a native event into a Mint one. */\nfun fromEvent (event : Html.NativeEvent) : Html.Event {\n  {\n    bubbles: `#{event}.bubbles`,\n    cancelable: `#{event}.cancelable`,\n    currentTarget: `#{event}.currentTarget`,\n    defaultPrevented: `#{event}.defaultPrevented`,\n    dataTransfer: `#{event}.dataTransfer`,\n    clipboardData: `#{event}.clipboardData`,\n    eventPhase: `#{event}.eventPhase`,\n    isTrusted: `#{event}.isTrusted`,\n    target: `#{event}.target`,\n    timeStamp: `#{event}.timeStamp`,\n    type: `#{event}.type`,\n    data: `#{event}.data`,\n    altKey: `#{event}.altKey`,\n    charCode: `#{event}.charCode`,\n    ctrlKey: `#{event}.ctrlKey`,\n    key: `#{event}.key`,\n    keyCode: `#{event}.keyCode`,\n    locale: `#{event}.locale`,\n    location: `#{event}.location`,\n    metaKey: `#{event}.metaKey`,\n    repeat: `#{event}.repeat`,\n    shiftKey: `#{event}.shiftKey`,\n    which: `#{event}.which`,\n    button: `#{event}.button`,\n    buttons: `#{event}.buttons`,\n    clientX: `#{event}.clientX`,\n    clientY: `#{event}.clientY`,\n    pageX: `#{event}.pageX`,\n    pageY: `#{event}.pageY`,\n    screenX: `#{event}.screenX`,\n    screenY: `#{event}.screenY`,\n    detail: `#{event}.detail`,\n    deltaMode: `#{event}.deltaMode`,\n    deltaX: `#{event}.deltaX`,\n    deltaY: `#{event}.deltaY`,\n    deltaZ: `#{event}.deltaZ`,\n    animationName: `#{event}.animationName`,\n    pseudoElement: `#{event}.pseudoElement`,\n    propertyName: `#{event}.propertyName`,\n    elapsedTime: `#{event}.elapsedTime`,\n    event: event\n  }\n}","arguments":[{"type":"Html.NativeEvent","name":"event"}]},{"type":"Bool","description":"<p>Returns whether or not the events propagation is stopped or not.</p>\n<pre><code>Html.Event.isPropagationStopped(event)\n</code></pre>\n","name":"isPropagationStopped","source":"/*\nReturns whether or not the events propagation is stopped or not.\n\n  Html.Event.isPropagationStopped(event)\n*/\nfun isPropagationStopped (event : Html.Event) : Bool {\n  `#{event.event}.isPropagationStopped()`\n}","arguments":[{"type":"Html.Event","name":"event"}]},{"type":"Void","description":"<p>Prevents the default action of the event from happening.</p>\n<pre><code>Html.Event.preventDefault(event)\ndoSomethingElse()\n</code></pre>\n","name":"preventDefault","source":"/*\nPrevents the default action of the event from happening.\n\n  Html.Event.preventDefault(event)\n  doSomethingElse()\n*/\nfun preventDefault (event : Html.Event) : Void {\n  `#{event.event}.preventDefault()`\n}","arguments":[{"type":"Html.Event","name":"event"}]},{"type":"Void","description":"<p>Stops the propagation of the given event.</p>\n<pre><code>Html.Event.stopPropagation(event)\ndoSomethingElse()\n</code></pre>\n","name":"stopPropagation","source":"/*\nStops the propagation of the given event.\n\n  Html.Event.stopPropagation(event)\n  doSomethingElse()\n*/\nfun stopPropagation (event : Html.Event) : Void {\n  `#{event.event}.stopPropagation()`\n}","arguments":[{"type":"Html.Event","name":"event"}]}]},{"description":null,"name":"Http","functions":[{"type":"Void","description":"<p>Aborts all running requests.</p>\n<pre><code>Http.abortAll()\n</code></pre>\n","name":"abortAll","source":"/*\nAborts all running requests.\n\n  Http.abortAll()\n*/\nfun abortAll : Void {\n  `\n    this._requests && Object.keys(this._requests).forEach((uid) => {\n      this._requests[uid].abort()\n      delete this._requests[uid]\n    })\n    `\n}","arguments":[]},{"type":"Http.Request","description":"<p>Creates a request record where the method is DELETE</p>\n<pre><code>request =\n  Http.delete(&quot;https://httpbin.org/delete&quot;)\n\nrequest.method == &quot;DELETE&quot;\n</code></pre>\n","name":"delete","source":"/*\nCreates a request record where the method is DELETE\n\n  request =\n    Http.delete(\"https://httpbin.org/delete\")\n\n  request.method == \"DELETE\"\n*/\nfun delete (urlValue : String) : Http.Request {\n  empty()\n  |> method(\"DELETE\")\n  |> url(urlValue)\n}","arguments":[{"type":"String","name":"urlValue"}]},{"type":"Http.Request","description":"<p>Creates an empty request record. It is useful if you want to use a non-\nstandard HTTP method.</p>\n<pre><code>Http.empty() ==\n  {\n    withCredentials = false,\n    method = &quot;GET&quot;,\n    body = `null`,\n    headers = [],\n    url = &quot;&quot;\n  }\n</code></pre>\n","name":"empty","source":"/*\nCreates an empty request record. It is useful if you want to use a non-\nstandard HTTP method.\n\n  Http.empty() ==\n    {\n      withCredentials = false,\n      method = \"GET\",\n      body = `null`,\n      headers = [],\n      url = \"\"\n    }\n*/\nfun empty : Http.Request {\n  {\n    withCredentials: false,\n    method: \"GET\",\n    body: `null`,\n    headers: [],\n    url: \"\"\n  }\n}","arguments":[]},{"type":"Http.Request","description":"<p>Sets the body of the request to the given string</p>\n<pre><code>formData =\n  FormData.empty()\n  |&gt; FormData.addString(&quot;key&quot;, &quot;value&quot;)\n\n&quot;https://httpbin.org/anything&quot;\n|&gt; Http.post()\n|&gt; Http.formDataBody(formData)\n|&gt; Http.send()\n</code></pre>\n","name":"formDataBody","source":"/*\nSets the body of the request to the given string\n\n  formData =\n    FormData.empty()\n    |> FormData.addString(\"key\", \"value\")\n\n  \"https://httpbin.org/anything\"\n  |> Http.post()\n  |> Http.formDataBody(formData)\n  |> Http.send()\n*/\nfun formDataBody (request : Http.Request, body : FormData) : Http.Request {\n  { request | body: `#{body}` }\n}","arguments":[{"type":"Http.Request","name":"request"},{"type":"FormData","name":"body"}]},{"type":"Http.Request","description":"<p>Creates a request record where the method is GET</p>\n<pre><code>request =\n  Http.get(&quot;https://httpbin.org/get&quot;)\n\nrequest.method == &quot;GET&quot;\n</code></pre>\n","name":"get","source":"/*\nCreates a request record where the method is GET\n\n  request =\n    Http.get(\"https://httpbin.org/get\")\n\n  request.method == \"GET\"\n*/\nfun get (urlValue : String) : Http.Request {\n  empty()\n  |> method(\"GET\")\n  |> url(urlValue)\n}","arguments":[{"type":"String","name":"urlValue"}]},{"type":"Bool","description":"<p>Checks the prescence of a header with the given key.</p>\n<pre><code>Http.empty()\n|&gt; Http.header(&quot;Content-Type&quot;, &quot;application/json&quot;)\n|&gt; Http.hasHeader(&quot;Content-Type&quot;)\n</code></pre>\n","name":"hasHeader","source":"/*\nChecks the prescence of a header with the given key.\n\n  Http.empty()\n  |> Http.header(\"Content-Type\", \"application/json\")\n  |> Http.hasHeader(\"Content-Type\")\n*/\nfun hasHeader (request : Http.Request, key : String) : Bool {\n  request.headers\n  |> Array.any(\n    (header : Http.Header) : Bool {\n      String.toLowerCase(header.key) == String.toLowerCase(key)\n    })\n}","arguments":[{"type":"Http.Request","name":"request"},{"type":"String","name":"key"}]},{"type":"Http.Request","description":"<p>Adds a header to the request with the given key and value. Overwrites the value if key already exists.</p>\n<pre><code>Http.empty()\n|&gt; Http.header(&quot;Content-Type&quot;, &quot;application/json&quot;)\n</code></pre>\n","name":"header","source":"/*\nAdds a header to the request with the given key and value. Overwrites the value if key already exists.\n\n  Http.empty()\n  |> Http.header(\"Content-Type\", \"application/json\")\n*/\nfun header (request : Http.Request, key : String, value : String) : Http.Request {\n  { request |\n    headers:\n      request.headers\n      |> Array.reject(\n        (header : Http.Header) : Bool {\n          String.toLowerCase(header.key) == String.toLowerCase(key)\n        })\n      |> Array.push(\n        {\n          key: key,\n          value: value\n        })\n  }\n}","arguments":[{"type":"Http.Request","name":"request"},{"type":"String","name":"key"},{"type":"String","name":"value"}]},{"type":"Http.Request","description":"<p>Sets the body of the request to the given object encoded to JSON</p>\n<pre><code>&quot;https://httpbin.org/anything&quot;\n|&gt; Http.post()\n|&gt; Http.jsonBody(encode { name = &quot;John&quot; })\n|&gt; Http.send()\n</code></pre>\n","name":"jsonBody","source":"/*\nSets the body of the request to the given object encoded to JSON\n\n  \"https://httpbin.org/anything\"\n  |> Http.post()\n  |> Http.jsonBody(encode { name = \"John\" })\n  |> Http.send()\n*/\nfun jsonBody (request : Http.Request, body : Object) : Http.Request {\n  if hasHeader(request, \"Content-Type\") {\n    { request | body: `JSON.stringify(#{body})` }\n  } else {\n    { request | body: `JSON.stringify(#{body})` }\n    |> Http.header(\"Content-Type\", \"application/json\")\n  }\n}","arguments":[{"type":"Http.Request","name":"request"},{"type":"Object","name":"body"}]},{"type":"Http.Request","description":"<p>Sets the method of the request to the given one.</p>\n<pre><code>Http.empty()\n|&gt; Http.method(&quot;PATCH&quot;)\n</code></pre>\n","name":"method","source":"/*\nSets the method of the request to the given one.\n\n  Http.empty()\n  |> Http.method(\"PATCH\")\n*/\nfun method (request : Http.Request, method : String) : Http.Request {\n  { request | method: method }\n}","arguments":[{"type":"Http.Request","name":"request"},{"type":"String","name":"method"}]},{"type":"Http.Request","description":"<p>Creates a request record where the method is POST</p>\n<pre><code>request =\n  Http.post(&quot;https://httpbin.org/post&quot;)\n\nrequest.method == &quot;POST&quot;\n</code></pre>\n","name":"post","source":"/*\nCreates a request record where the method is POST\n\n  request =\n    Http.post(\"https://httpbin.org/post\")\n\n  request.method == \"POST\"\n*/\nfun post (urlValue : String) : Http.Request {\n  empty()\n  |> method(\"POST\")\n  |> url(urlValue)\n}","arguments":[{"type":"String","name":"urlValue"}]},{"type":"Http.Request","description":"<p>Creates a request record where the method is PUT</p>\n<pre><code>request =\n  Http.put(&quot;https://httpbin.org/put&quot;)\n\nrequest.method == &quot;PUT&quot;\n</code></pre>\n","name":"put","source":"/*\nCreates a request record where the method is PUT\n\n  request =\n    Http.put(\"https://httpbin.org/put\")\n\n  request.method == \"PUT\"\n*/\nfun put (urlValue : String) : Http.Request {\n  empty()\n  |> method(\"PUT\")\n  |> url(urlValue)\n}","arguments":[{"type":"String","name":"urlValue"}]},{"type":"Map(String, Http.NativeRequest)","description":"<p>Returns all running requests.</p>\n","name":"requests","source":"/* Returns all running requests. */\nfun requests : Map(String, Http.NativeRequest) {\n  `this._requests`\n}","arguments":[]},{"type":"Promise(Result(Http.ErrorResponse, Http.Response))","description":"<p>Sends the request with a unique ID (generated by default) so it could be aborted later.</p>\n<pre><code>&quot;https://httpbin.org/get&quot;\n|&gt; Http.get()\n|&gt; Http.sendWithId(&quot;my-request&quot;)\n</code></pre>\n","name":"send","source":"/*\nSends the request with a unique ID (generated by default) so it could be aborted later.\n\n  \"https://httpbin.org/get\"\n  |> Http.get()\n  |> Http.sendWithId(\"my-request\")\n*/\nfun send (\n  request : Http.Request,\n  uid : String = Uid.generate()\n) : Promise(Result(Http.ErrorResponse, Http.Response)) {\n  `\n    new Promise((resolve, reject) => {\n      if (!this._requests) { this._requests = {} }\n\n      let xhr = new XMLHttpRequest()\n\n      this._requests[#{uid}] = xhr\n\n      xhr.withCredentials = #{request.withCredentials}\n      xhr.responseType = \"blob\"\n\n      const getResponseHeaders = () => {\n        return xhr\n          .getAllResponseHeaders()\n          .trim()\n          .split(/[\\r\\n]+/)\n          .map((line) => {\n            const parts = line.split(': ');\n            return [parts.shift(), parts.join(': ')];\n          })\n      }\n\n      try {\n        xhr.open(#{request.method}.toUpperCase(), #{request.url}, true)\n      } catch (error) {\n        delete this._requests[#{uid}]\n\n        resolve(#{Result::Err({\n          headers: `getResponseHeaders()`,\n          type: Http.Error::BadUrl,\n          status: `xhr.status`,\n          url: request.url\n        })})\n      }\n\n      #{request.headers}.forEach((item) => {\n        xhr.setRequestHeader(item.key, item.value)\n      })\n\n      xhr.addEventListener('error', (event) => {\n        delete this._requests[#{uid}]\n\n        resolve(#{Result::Err({\n          headers: `getResponseHeaders()`,\n          type: Http.Error::NetworkError,\n          status: `xhr.status`,\n          url: request.url\n        })})\n      })\n\n      xhr.addEventListener('timeout', (event) => {\n        delete this._requests[#{uid}]\n\n        resolve(#{Result::Err({\n          headers: `getResponseHeaders()`,\n          type: Http.Error::Timeout,\n          status: `xhr.status`,\n          url: request.url\n        })})\n      })\n\n      xhr.addEventListener('load', async (event) => {\n        delete this._requests[#{uid}]\n\n        let contentType = xhr.getResponseHeader(\"Content-Type\");\n        let responseText = await xhr.response.text();\n        let body;\n\n        if (contentType.startsWith(\"text/html\")) {\n          const object =\n            (new DOMParser()).parseFromString(responseText, \"text/html\");\n\n          const errorNode =\n            object.querySelector(\"parsererror\");\n\n          if (errorNode) {\n            body = #{Http.ResponseBody::Text(`responseText`)};\n          } else {\n            body = #{Http.ResponseBody::HTML(`object`)};\n          }\n        } else if (contentType.startsWith(\"application/xml\")) {\n          const object =\n            (new DOMParser()).parseFromString(responseText, \"application/xml\");\n\n          const errorNode =\n            object.querySelector(\"parsererror\");\n\n          if (errorNode) {\n            body = #{Http.ResponseBody::Text(`responseText`)};\n          } else {\n            body = #{Http.ResponseBody::XML(`object`)};\n          }\n        } else if (contentType.startsWith(\"application/json\")) {\n          try {\n            body = #{Http.ResponseBody::JSON(`JSON.parse(responseText)`)};\n          } catch (e) {\n            body = #{Http.ResponseBody::Text(`responseText`)};\n          }\n        } else if (contentType.startsWith(\"text/\")) {\n          body = #{Http.ResponseBody::Text(`responseText`)};\n        }\n\n        if (!body) {\n          const parts = #{Url.parse(request.url).path}.split('/');\n          body = #{Http.ResponseBody::File(`new File([xhr.response], parts[parts.length - 1], { type: contentType })`)};\n        }\n\n        resolve(#{Result::Ok({\n          headers: `getResponseHeaders()`,\n          bodyString: `responseText`,\n          status: `xhr.status`,\n          body: `body`,\n        })})\n      })\n\n      xhr.addEventListener('abort', (event) => {\n        delete this._requests[#{uid}]\n\n        resolve(#{Result::Err({\n          headers: `getResponseHeaders()`,\n          type: Http.Error::Aborted,\n          status: `xhr.status`,\n          url: request.url\n        })})\n      })\n\n      xhr.send(#{request.body})\n    })\n    `\n}","arguments":[{"type":"Http.Request","name":"request"},{"type":"String","name":"uid"}]},{"type":"Http.Request","description":"<p>Sets the body of the request to the given string</p>\n<pre><code>&quot;https://httpbin.org/anything&quot;\n|&gt; Http.post()\n|&gt; Http.stringBody(&quot;Some string that will come back.&quot;)\n|&gt; Http.send()\n</code></pre>\n","name":"stringBody","source":"/*\nSets the body of the request to the given string\n\n  \"https://httpbin.org/anything\"\n  |> Http.post()\n  |> Http.stringBody(\"Some string that will come back.\")\n  |> Http.send()\n*/\nfun stringBody (request : Http.Request, body : String) : Http.Request {\n  { request | body: `#{body}` }\n}","arguments":[{"type":"Http.Request","name":"request"},{"type":"String","name":"body"}]},{"type":"Http.Request","description":"<p>Sets the URL of the request to the given one.</p>\n<pre><code>Http.empty()\n|&gt; Http.url(&quot;https://httpbin.org/anything&quot;)\n</code></pre>\n","name":"url","source":"/*\nSets the URL of the request to the given one.\n\n  Http.empty()\n  |> Http.url(\"https://httpbin.org/anything\")\n*/\nfun url (request : Http.Request, url : String) : Http.Request {\n  { request | url: url }\n}","arguments":[{"type":"Http.Request","name":"request"},{"type":"String","name":"url"}]},{"type":"Http.Request","description":"<p>Sets the withCredentials of the request to the given one.</p>\n<pre><code>Http.empty()\n|&gt; Http.withCredentials(true)\n</code></pre>\n","name":"withCredentials","source":"/*\nSets the withCredentials of the request to the given one.\n\n  Http.empty()\n  |> Http.withCredentials(true)\n*/\nfun withCredentials (request : Http.Request, value : Bool) : Http.Request {\n  { request | withCredentials: value }\n}","arguments":[{"type":"Http.Request","name":"request"},{"type":"Bool","name":"value"}]}]},{"description":null,"name":"IntersectionObserver","functions":[{"type":"IntersectionObserver","description":"<p>Unobserves all observed elements.</p>\n","name":"disconnect","source":"/* Unobserves all observed elements. */\nfun disconnect (observer : IntersectionObserver) : IntersectionObserver {\n  `#{observer}.disconnect() || #{observer}`\n}","arguments":[{"type":"IntersectionObserver","name":"observer"}]},{"type":"IntersectionObserver","description":"<p>Creates a new intersection observer.</p>\n<pre><code>observer =\n  IntersectionObserver.new(&quot;50px&quot;, 0.1,\n    (intersectionRatio : Number) {\n      if (intersectionRatio == 1) {\n        Debug.log(&quot;Fully visible!&quot;)\n      } else {\n        Debug.log(&quot;Not fully visible!&quot;)\n      }\n    })\n</code></pre>\n","name":"new","source":"/*\nCreates a new intersection observer.\n\n  observer =\n    IntersectionObserver.new(\"50px\", 0.1,\n      (intersectionRatio : Number) {\n        if (intersectionRatio == 1) {\n          Debug.log(\"Fully visible!\")\n        } else {\n          Debug.log(\"Not fully visible!\")\n        }\n      })\n*/\nfun new (\n  rootMargin : String,\n  threshold : Number,\n  callback : Function(Number, a)\n) : IntersectionObserver {\n  `\n    (() => {\n      return new IntersectionObserver((entries) => {\n        entries.forEach((entry) => {\n          #{callback(`entry.intersectionRatio`)}\n        })\n      }, {\n        rootMargin: #{rootMargin},\n        threshold: #{threshold}\n      });\n    })()\n    `\n}","arguments":[{"type":"String","name":"rootMargin"},{"type":"Number","name":"threshold"},{"type":"Function(Number, a)","name":"callback"}]},{"type":"IntersectionObserver","description":"<p>Observes the given element.</p>\n","name":"observe","source":"/* Observes the given element. */\nfun observe (\n  observer : IntersectionObserver,\n  element : Dom.Element\n) : IntersectionObserver {\n  `#{observer}.observe(#{element}) || #{observer}`\n}","arguments":[{"type":"IntersectionObserver","name":"observer"},{"type":"Dom.Element","name":"element"}]},{"type":"IntersectionObserver","description":"<p>Unobserves the given element.</p>\n","name":"unobserve","source":"/* Unobserves the given element. */\nfun unobserve (\n  observer : IntersectionObserver,\n  element : Dom.Element\n) : IntersectionObserver {\n  `#{observer}.unobserve(#{element}) || #{observer}`\n}","arguments":[{"type":"IntersectionObserver","name":"observer"},{"type":"Dom.Element","name":"element"}]}]},{"description":null,"name":"Json","functions":[{"type":"Result(String, Object)","description":"<p>Parses a string into an <code>Object</code>, returns <code>Maybe.nothing()</code>\nif the parsing failed.</p>\n<pre><code>Result.isOk(Json.parse(&quot;{}&quot;))\nResult.isError(Json.parse(&quot;{&quot;))\n</code></pre>\n","name":"parse","source":"/*\nParses a string into an `Object`, returns `Maybe.nothing()`\nif the parsing failed.\n\n  Result.isOk(Json.parse(\"{}\"))\n  Result.isError(Json.parse(\"{\"))\n*/\nfun parse (input : String) : Result(String, Object) {\n  `\n    (() => {\n      try {\n        return #{Result::Ok(`JSON.parse(#{input})`)}\n      } catch (error) {\n        return #{Result::Err(`error.message`)}\n      }\n    })()\n    `\n}","arguments":[{"type":"String","name":"input"}]},{"type":null,"description":"<p>Pretty stringyfies the given object.</p>\n<pre><code> Json.prettyStringify(`{ a: &quot;Hello&quot; }`, 2) == &quot;{\\n  \\&quot;a\\&quot;: \\&quot;Hello\\&quot;\\n}&quot;\n</code></pre>\n","name":"prettyStringify","source":"/*\nPretty stringyfies the given object.\n\n   Json.prettyStringify(`{ a: \"Hello\" }`, 2) == \"{\\n  \\\"a\\\": \\\"Hello\\\"\\n}\"\n*/\nfun prettyStringify (value : Object, spaces : Number) {\n  `JSON.stringify(#{value}, null, #{spaces})` as String\n}","arguments":[{"type":"Object","name":"value"},{"type":"Number","name":"spaces"}]},{"type":"String","description":"<p>Stringifies an <code>Object</code> into JSON string.</p>\n<pre><code>Json.stringify(`{ a: &quot;Hello&quot; }`) == &quot;{ \\&quot;a\\&quot;: \\&quot;Hello\\&quot; }&quot;\n</code></pre>\n","name":"stringify","source":"/*\nStringifies an `Object` into JSON string.\n\n  Json.stringify(`{ a: \"Hello\" }`) == \"{ \\\"a\\\": \\\"Hello\\\" }\"\n*/\nfun stringify (input : Object) : String {\n  `JSON.stringify(#{input})`\n}","arguments":[{"type":"Object","name":"input"}]}]},{"description":null,"name":"Locale","functions":[{"type":"Bool","description":"<p>Sets the current locale.</p>\n","name":"set","source":"/* Sets the current locale. */\nfun set (locale : String) : Bool {\n  `_L.set(#{locale})`\n}","arguments":[{"type":"String","name":"locale"}]},{"type":"Maybe(String)","description":"<p>Returns the current locale.</p>\n","name":"get","source":"/* Returns the current locale. */\nfun get : Maybe(String) {\n  `\n    (() => {\n      if (_L.locale) {\n        return #{Maybe::Just(`_L.locale`)}\n      } else {\n        return #{Maybe::Nothing}\n      }\n    })()\n    `\n}","arguments":[]}]},{"description":null,"name":"Map","functions":[{"type":"Map(key, value)","description":"<p>Removes the item with the key.</p>\n<pre><code>(Map.empty()\n|&gt; Map.set(&quot;a&quot;, 1)\n|&gt; Map.delete(&quot;a&quot;)) == Map.empty()\n</code></pre>\n","name":"delete","source":"/*\nRemoves the item with the key.\n\n  (Map.empty()\n  |> Map.set(\"a\", 1)\n  |> Map.delete(\"a\")) == Map.empty()\n*/\nfun delete (map : Map(key, value), keyToDelete : key) : Map(key, value) {\n  Map.fromArray(\n    for key, value of map {\n      #(key, value)\n    } when {\n      key != keyToDelete\n    })\n}","arguments":[{"type":"Map(key, value)","name":"map"},{"type":"key","name":"keyToDelete"}]},{"type":"Map(key, value)","description":"<p>Removes all keys which match the value.</p>\n<pre><code>(Map.empty()\n|&gt; Map.set(&quot;a&quot;, 1)\n|&gt; Map.set(&quot;b&quot;, 1)\n|&gt; Map.deleteValues(1)) == Map.empty()\n</code></pre>\n","name":"deleteValues","source":"/*\nRemoves all keys which match the value.\n\n  (Map.empty()\n  |> Map.set(\"a\", 1)\n  |> Map.set(\"b\", 1)\n  |> Map.deleteValues(1)) == Map.empty()\n*/\nfun deleteValues (map : Map(key, value), valueToDelete : value) : Map(key, value) {\n  Map.fromArray(\n    for key, value of map {\n      #(key, value)\n    } when {\n      value != valueToDelete\n    })\n}","arguments":[{"type":"Map(key, value)","name":"map"},{"type":"value","name":"valueToDelete"}]},{"type":"Map(x, z)","description":"<p>Returns an empty map.</p>\n","name":"empty","source":"/* Returns an empty map. */\nfun empty : Map(x, z) {\n  `[]`\n}","arguments":[]},{"type":"Array(Tuple(a, b))","description":"<p>Returns the map as an array of key/value tuples.</p>\n<pre><code>(Map.empty()\n|&gt; Map.set(&quot;a&quot;, 1)\n|&gt; Map.set(&quot;b&quot;, 2)\n|&gt; Map.entries()) == [{&quot;a&quot;, 1}, {&quot;b&quot;, 2}]\n</code></pre>\n","name":"entries","source":"/*\nReturns the map as an array of key/value tuples.\n\n  (Map.empty()\n  |> Map.set(\"a\", 1)\n  |> Map.set(\"b\", 2)\n  |> Map.entries()) == [{\"a\", 1}, {\"b\", 2}]\n*/\nfun entries (map : Map(a, b)) : Array(Tuple(a, b)) {\n  `#{map}`\n}","arguments":[{"type":"Map(a, b)","name":"map"}]},{"type":"Maybe(key)","description":"<p>Returns the first key which is matched by the function.</p>\n<pre><code>(Map.empty()\n|&gt; Map.set(&quot;a&quot;, 0)\n|&gt; Map.set(&quot;b&quot;, 1)\n|&gt; Map.findKeyBy((value : Number) : Bool {\n  value == 1\n})) == Maybe.just(&quot;b&quot;)\n</code></pre>\n","name":"findKeyBy","source":"/*\nReturns the first key which is matched by the function.\n\n  (Map.empty()\n  |> Map.set(\"a\", 0)\n  |> Map.set(\"b\", 1)\n  |> Map.findKeyBy((value : Number) : Bool {\n    value == 1\n  })) == Maybe.just(\"b\")\n*/\nfun findKeyBy (\n  map : Map(key, value),\n  function : Function(value, Bool)\n) : Maybe(key) {\n  Array.first(\n    for key, value of map {\n      key\n    } when {\n      function(value)\n    })\n}","arguments":[{"type":"Map(key, value)","name":"map"},{"type":"Function(value, Bool)","name":"function"}]},{"type":"Map(a, b)","description":"<p>Converts an array of key/value tuples into a Map.</p>\n<pre><code> (Map.empty()\n |&gt; Map.set(&quot;a&quot;, 1)\n |&gt; Map.set(&quot;b&quot;, 2)\n ) == Map.fromArray([{&quot;a&quot;, 1}, {&quot;b&quot;, 2}])\n</code></pre>\n","name":"fromArray","source":"/*\nConverts an array of key/value tuples into a Map.\n\n   (Map.empty()\n   |> Map.set(\"a\", 1)\n   |> Map.set(\"b\", 2)\n   ) == Map.fromArray([{\"a\", 1}, {\"b\", 2}])\n*/\nfun fromArray (array : Array(Tuple(a, b))) : Map(a, b) {\n  `#{array}`\n}","arguments":[{"type":"Array(Tuple(a, b))","name":"array"}]},{"type":"Maybe(value)","description":"<p>Gets the value of the key.</p>\n<pre><code>Map.empty()\n|&gt; Map.set(&quot;key&quot;, &quot;value&quot;)\n|&gt; Map.get(&quot;key&quot;) == Maybe.just(&quot;value&quot;)\n</code></pre>\n","name":"get","source":"/*\nGets the value of the key.\n\n  Map.empty()\n  |> Map.set(\"key\", \"value\")\n  |> Map.get(\"key\") == Maybe.just(\"value\")\n*/\nfun get (map : Map(key, value), search : key) : Maybe(value) {\n  Array.first(\n    for key, value of map {\n      value\n    } when {\n      key == search\n    })\n}","arguments":[{"type":"Map(key, value)","name":"map"},{"type":"key","name":"search"}]},{"type":"value","description":"<p>Gets the value of the key using the value as fallback.</p>\n<pre><code>(Map.empty()\n|&gt; Map.set(&quot;key&quot;, &quot;value&quot;)\n|&gt; Map.getWithDefault(&quot;key&quot;, &quot;fallback&quot;)) == &quot;value&quot;\n\n(Map.empty()\n|&gt; Map.getWithDefault(&quot;key&quot;, &quot;fallback&quot;)) == &quot;fallback&quot;\n</code></pre>\n","name":"getWithDefault","source":"/*\nGets the value of the key using the value as fallback.\n\n  (Map.empty()\n  |> Map.set(\"key\", \"value\")\n  |> Map.getWithDefault(\"key\", \"fallback\")) == \"value\"\n\n  (Map.empty()\n  |> Map.getWithDefault(\"key\", \"fallback\")) == \"fallback\"\n*/\nfun getWithDefault (map : Map(key, value), key : key, value : value) : value {\n  get(map, key) or value\n}","arguments":[{"type":"Map(key, value)","name":"map"},{"type":"key","name":"key"},{"type":"value","name":"value"}]},{"type":"Bool","description":"<p>Returns whether or not the map has the key.</p>\n<pre><code>(Map.empty()\n|&gt; Map.set(&quot;a&quot;, 1)\n|&gt; Map.has(&quot;a&quot;)) == true\n</code></pre>\n","name":"has","source":"/*\nReturns whether or not the map has the key.\n\n  (Map.empty()\n  |> Map.set(\"a\", 1)\n  |> Map.has(\"a\")) == true\n*/\nfun has (map : Map(key, value), search : key) : Bool {\n  Array.first(\n    for key, value of map {\n      true\n    } when {\n      key == search\n    }) or false\n}","arguments":[{"type":"Map(key, value)","name":"map"},{"type":"key","name":"search"}]},{"type":"Bool","description":"<p>Returns whether or not the map is empty.</p>\n<pre><code>(Map.empty()\n|&gt; Map.isEmpty()) == true\n\n(Map.empty()\n|&gt; Map.set(&quot;a&quot;, &quot;b&quot;)\n|&gt; Map.isEmpty()) == false\n</code></pre>\n","name":"isEmpty","source":"/*\nReturns whether or not the map is empty.\n\n  (Map.empty()\n  |> Map.isEmpty()) == true\n\n  (Map.empty()\n  |> Map.set(\"a\", \"b\")\n  |> Map.isEmpty()) == false\n*/\nfun isEmpty (map : Map(key, value)) : Bool {\n  `#{map}.length === 0`\n}","arguments":[{"type":"Map(key, value)","name":"map"}]},{"type":"Array(key)","description":"<p>Returns the keys of a map as an array.</p>\n<pre><code>(Map.empty()\n|&gt; Map.set(&quot;a&quot;, 1)\n|&gt; Map.set(&quot;b&quot;, 2)\n|&gt; Map.values()) == [&quot;a&quot;, &quot;b&quot;]\n</code></pre>\n","name":"keys","source":"/*\nReturns the keys of a map as an array.\n\n  (Map.empty()\n  |> Map.set(\"a\", 1)\n  |> Map.set(\"b\", 2)\n  |> Map.values()) == [\"a\", \"b\"]\n*/\nfun keys (map : Map(key, value)) : Array(key) {\n  for key, value of map {\n    key\n  }\n}","arguments":[{"type":"Map(key, value)","name":"map"}]},{"type":"Map(key, result)","description":"<p>Maps over the keys/values pairs with the function.</p>\n<pre><code>(Map.empty()\n|&gt; Map.set(&quot;a&quot;, 1)\n|&gt; Map.set(&quot;b&quot;, 2)\n|&gt; Map.map((key : String, value : Number) : Number { value * 2 })\n|&gt; Map.values()) == [2,4]\n</code></pre>\n","name":"map","source":"/*\nMaps over the keys/values pairs with the function.\n\n  (Map.empty()\n  |> Map.set(\"a\", 1)\n  |> Map.set(\"b\", 2)\n  |> Map.map((key : String, value : Number) : Number { value * 2 })\n  |> Map.values()) == [2,4]\n*/\nfun map (\n  map : Map(key, value),\n  function : Function(key, value, result)\n) : Map(key, result) {\n  Map.fromArray(\n    for key, value of map {\n      (#(key, function(key, value)))\n    })\n}","arguments":[{"type":"Map(key, value)","name":"map"},{"type":"Function(key, value, result)","name":"function"}]},{"type":"Map(key, value)","description":"<p>Merges two maps together where the second has the precedence.</p>\n<pre><code>a =\n  Map.empty()\n  |&gt; Map.set(&quot;a&quot;, &quot;b&quot;)\n\nb =\n  Map.empty()\n  |&gt; Map.set(&quot;a&quot;, &quot;y&quot;)\n\n(Map.merge(a, b)\n|&gt; Map.get(&quot;a&quot;)) == Maybe::Just(&quot;y&quot;)\n</code></pre>\n","name":"merge","source":"/*\nMerges two maps together where the second has the precedence.\n\n  a =\n    Map.empty()\n    |> Map.set(\"a\", \"b\")\n\n  b =\n    Map.empty()\n    |> Map.set(\"a\", \"y\")\n\n  (Map.merge(a, b)\n  |> Map.get(\"a\")) == Maybe::Just(\"y\")\n*/\nfun merge (map1 : Map(key, value), map2 : Map(key, value)) : Map(key, value) {\n  Map.reduce(\n    map2, \n    map1, \n    (memo : Map(key, value), key : key, value : value) {\n      Map.set(memo, key, value)\n    })\n}","arguments":[{"type":"Map(key, value)","name":"map1"},{"type":"Map(key, value)","name":"map2"}]},{"type":"memo","description":"<p>Reduces the map from the left using the accumulator function.</p>\n<pre><code>(Map.empty()\n|&gt; Map.set(&quot;a&quot;, 1)\n|&gt; Map.set(&quot;b&quot;, 2)\n|&gt; Map.reduce(\n  0,\n  (memo : Number, key : String, value : Number) : Number {\n    memo + value\n  })) == 3\n</code></pre>\n","name":"reduce","source":"/*\nReduces the map from the left using the accumulator function.\n\n  (Map.empty()\n  |> Map.set(\"a\", 1)\n  |> Map.set(\"b\", 2)\n  |> Map.reduce(\n    0,\n    (memo : Number, key : String, value : Number) : Number {\n      memo + value\n    })) == 3\n*/\nfun reduce (\n  map : Map(key, value),\n  memo : memo,\n  method : Function(memo, key, value, memo)\n) : memo {\n  `\n    (() => {\n      let memo = #{memo}\n\n      for (let item of #{map}) {\n        memo = #{method}(memo, item[0], item[1])\n      }\n\n      return memo\n    })()\n    `\n}","arguments":[{"type":"Map(key, value)","name":"map"},{"type":"memo","name":"memo"},{"type":"Function(memo, key, value, memo)","name":"method"}]},{"type":"Map(key, value)","description":"<p>Assigns the value to the key in the map.</p>\n<pre><code>Map.empty()\n|&gt; Map.set(&quot;key&quot;, &quot;value&quot;)\n</code></pre>\n","name":"set","source":"/*\nAssigns the value to the key in the map.\n\n  Map.empty()\n  |> Map.set(\"key\", \"value\")\n*/\nfun set (map : Map(key, value), key : key, value : value) : Map(key, value) {\n  `\n    (() => {\n      const result = []\n      let set = false\n\n      for (let item of #{map}) {\n        if (_compare(item[0], #{key})) {\n          set = true\n          result.push([#{key}, #{value}])\n        } else {\n          result.push(item)\n        }\n      }\n\n      if (!set) {\n        result.push([#{key}, #{value}])\n      }\n\n      return result\n    })()\n    `\n}","arguments":[{"type":"Map(key, value)","name":"map"},{"type":"key","name":"key"},{"type":"value","name":"value"}]},{"type":"Number","description":"<p>Returns the number of items in the map.</p>\n<pre><code>(Map.empty()\n|&gt; Map.set(&quot;a&quot;, 1)\n|&gt; Map.size()) == 1\n</code></pre>\n","name":"size","source":"/*\nReturns the number of items in the map.\n\n  (Map.empty()\n  |> Map.set(\"a\", 1)\n  |> Map.size()) == 1\n*/\nfun size (map : Map(key, value)) : Number {\n  `#{map}.length`\n}","arguments":[{"type":"Map(key, value)","name":"map"}]},{"type":"Map(key, value)","description":"<p>Sorts the map using the function.</p>\n<pre><code>(Map.empty()\n|&gt; Map.set(&quot;a&quot;, 1)\n|&gt; Map.set(&quot;b&quot;, 2)\n|&gt; Map.sortBy((key : String, value : Number) : Number {\n  value - 100\n})\n|&gt; Map.values()) == [&quot;b&quot;, &quot;a&quot;]\n</code></pre>\n","name":"sortBy","source":"/*\nSorts the map using the function.\n\n  (Map.empty()\n  |> Map.set(\"a\", 1)\n  |> Map.set(\"b\", 2)\n  |> Map.sortBy((key : String, value : Number) : Number {\n    value - 100\n  })\n  |> Map.values()) == [\"b\", \"a\"]\n*/\nfun sortBy (\n  map : Map(key, value),\n  method : Function(key, value, result)\n) : Map(key, value) {\n  `\n    Array.from(#{map}).sort((a, b) => {\n      let aVal = #{method}(a[0], a[1])\n      let bVal = #{method}(b[0], b[1])\n\n      if (aVal < bVal) {\n        return -1\n      }\n\n      if (aVal > bVal) {\n        return 1\n      }\n\n      return 0\n    })\n    `\n}","arguments":[{"type":"Map(key, value)","name":"map"},{"type":"Function(key, value, result)","name":"method"}]},{"type":"Array(value)","description":"<p>Returns the values of a map as an array.</p>\n<pre><code>(Map.empty()\n|&gt; Map.set(&quot;a&quot;, 1)\n|&gt; Map.set(&quot;b&quot;, 2)\n|&gt; Map.values()) == [1, 2]\n</code></pre>\n","name":"values","source":"/*\nReturns the values of a map as an array.\n\n  (Map.empty()\n  |> Map.set(\"a\", 1)\n  |> Map.set(\"b\", 2)\n  |> Map.values()) == [1, 2]\n*/\nfun values (map : Map(key, value)) : Array(value) {\n  for key, value of map {\n    value\n  }\n}","arguments":[{"type":"Map(key, value)","name":"map"}]}]},{"description":null,"name":"Math","functions":[{"type":"Number","description":"<p>Returns the absolute value of the given number.</p>\n<pre><code>Math.abs(1) == 1\nMath.abs(-1) == 1\n</code></pre>\n","name":"abs","source":"/*\nReturns the absolute value of the given number.\n\n  Math.abs(1) == 1\n  Math.abs(-1) == 1\n*/\nfun abs (number : Number) : Number {\n  `Math.abs(#{number})`\n}","arguments":[{"type":"Number","name":"number"}]},{"type":"Number","description":"<p>Returns the inverse cosine of the given angle in radians</p>\n","name":"acos","source":"/* Returns the inverse cosine of the given angle in radians */\nfun acos (number : Number) : Number {\n  `Math.acos(#{number})`\n}","arguments":[{"type":"Number","name":"number"}]},{"type":"Number","description":"<p>Returns the inverse hyperbolic cosine of the given angle in radians</p>\n","name":"acosh","source":"/* Returns the inverse hyperbolic cosine of the given angle in radians */\nfun acosh (number : Number) : Number {\n  `Math.acosh(#{number})`\n}","arguments":[{"type":"Number","name":"number"}]},{"type":"Number","description":"<p>Returns the inverse sine of the given angle in radians</p>\n","name":"asin","source":"/* Returns the inverse sine of the given angle in radians */\nfun asin (number : Number) : Number {\n  `Math.asin(#{number})`\n}","arguments":[{"type":"Number","name":"number"}]},{"type":"Number","description":"<p>Returns the inverse hyperbolic sine of the given angle in radians</p>\n","name":"asinh","source":"/* Returns the inverse hyperbolic sine of the given angle in radians */\nfun asinh (number : Number) : Number {\n  `Math.asinh(#{number})`\n}","arguments":[{"type":"Number","name":"number"}]},{"type":"Number","description":"<p>Returns the inverse tangent of the given angle in radians</p>\n","name":"atan","source":"/* Returns the inverse tangent of the given angle in radians */\nfun atan (number : Number) : Number {\n  `Math.atan(#{number})`\n}","arguments":[{"type":"Number","name":"number"}]},{"type":"Number","description":"<p>Returns the angle in the plane (in radians) between the positive x-axis and the ray from (0, 0) to the point (x, y)</p>\n","name":"atan2","source":"/* Returns the angle in the plane (in radians) between the positive x-axis and the ray from (0, 0) to the point (x, y) */\nfun atan2 (y : Number, x : Number) : Number {\n  `Math.atan2(#{y}, #{x})`\n}","arguments":[{"type":"Number","name":"y"},{"type":"Number","name":"x"}]},{"type":"Number","description":"<p>Returns the inverse hyperbolic tangent of the given angle in radians</p>\n","name":"atanh","source":"/* Returns the inverse hyperbolic tangent of the given angle in radians */\nfun atanh (number : Number) : Number {\n  `Math.atanh(#{number})`\n}","arguments":[{"type":"Number","name":"number"}]},{"type":"Number","description":"<p>Returns the cubic root of the given number</p>\n<pre><code>Math.cbrt(1) == 1\nMath.cbrt(64) == 4\n</code></pre>\n","name":"cbrt","source":"/*\nReturns the cubic root of the given number\n\n  Math.cbrt(1) == 1\n  Math.cbrt(64) == 4\n*/\nfun cbrt (number : Number) : Number {\n  `Math.cbrt(#{number})`\n}","arguments":[{"type":"Number","name":"number"}]},{"type":"Number","description":"<p>Returns the smallest integer greater than or equal to the given number.</p>\n<pre><code>Math.ceil(0.3) == 1\n</code></pre>\n","name":"ceil","source":"/*\nReturns the smallest integer greater than or equal to the given number.\n\n  Math.ceil(0.3) == 1\n*/\nfun ceil (number : Number) : Number {\n  `Math.ceil(#{number})`\n}","arguments":[{"type":"Number","name":"number"}]},{"type":"Number","description":"<p>Clamps the given number between the given upper and lower bounds.</p>\n<pre><code>Math.clamp(100, 0, 10) == 10\nMath.clamp(-100, 0, 10) == 0\n</code></pre>\n","name":"clamp","source":"/*\nClamps the given number between the given upper and lower bounds.\n\n  Math.clamp(100, 0, 10) == 10\n  Math.clamp(-100, 0, 10) == 0\n*/\nfun clamp (value : Number, lower : Number, upper : Number) : Number {\n  Math.min(upper, Math.max(lower, value))\n}","arguments":[{"type":"Number","name":"value"},{"type":"Number","name":"lower"},{"type":"Number","name":"upper"}]},{"type":"Number","description":"<p>Returns the number of leading zero bits in the 32-bit binary representation of a number</p>\n<p>00000000000000000000000000000100\nMath.clz32(4) == 29</p>\n","name":"clz32","source":"/*\nReturns the number of leading zero bits in the 32-bit binary representation of a number\n\n 00000000000000000000000000000100\n Math.clz32(4) == 29\n*/\nfun clz32 (number : Number) : Number {\n  `Math.clz32(#{number})`\n}","arguments":[{"type":"Number","name":"number"}]},{"type":"Number","description":"<p>Returns the cosine of the given angle in radians</p>\n","name":"cos","source":"/* Returns the cosine of the given angle in radians */\nfun cos (number : Number) : Number {\n  `Math.cos(#{number})`\n}","arguments":[{"type":"Number","name":"number"}]},{"type":"Number","description":"<p>Returns the hyperbolic cosine of the given angle in radians</p>\n","name":"cosh","source":"/* Returns the hyperbolic cosine of the given angle in radians */\nfun cosh (number : Number) : Number {\n  `Math.cosh(#{number})`\n}","arguments":[{"type":"Number","name":"number"}]},{"type":"Number","description":"<p>Returns the value of <code>Math:E</code> raised to the power x, where x is the given number</p>\n","name":"exp","source":"/* Returns the value of `Math:E` raised to the power x, where x is the given number */\nfun exp (x : Number) : Number {\n  `Math.exp(#{x})`\n}","arguments":[{"type":"Number","name":"x"}]},{"type":"Number","description":"<p>Returns the value of <code>Math:E</code> to the power x, minus 1</p>\n<pre><code>Math.exp(2) == 7.38905609893065\nMath.expm1(2) == 6.38905609893065\n</code></pre>\n","name":"expm1","source":"/*\nReturns the value of `Math:E` to the power x, minus 1\n\n  Math.exp(2) == 7.38905609893065\n  Math.expm1(2) == 6.38905609893065\n*/\nfun expm1 (x : Number) : Number {\n  `Math.expm1(#{x})`\n}","arguments":[{"type":"Number","name":"x"}]},{"type":"Number","description":"<p>Returns the largest integer less than or equal to the given number.</p>\n<pre><code>Math.floor(0.8) == 0\n</code></pre>\n","name":"floor","source":"/*\nReturns the largest integer less than or equal to the given number.\n\n  Math.floor(0.8) == 0\n*/\nfun floor (number : Number) : Number {\n  `Math.floor(#{number})`\n}","arguments":[{"type":"Number","name":"number"}]},{"type":"Number","description":"<p>Returns the floating-point remainder of two numbers.</p>\n<pre><code>Math.fmod(2, 5.3) == 1.3\nMath.fmod(4.2, 18.5) == 1.7\n</code></pre>\n","name":"fmod","source":"/*\nReturns the floating-point remainder of two numbers.\n\n  Math.fmod(2, 5.3) == 1.3\n  Math.fmod(4.2, 18.5) == 1.7\n*/\nfun fmod (a : Number, b : Number) : Number {\n  `Number((#{b} - (Math.floor(#{b} / #{a}) * #{a})).toPrecision(8))`\n}","arguments":[{"type":"Number","name":"a"},{"type":"Number","name":"b"}]},{"type":"Number","description":"<p>Returns the nearest 32-bit single precision float representation of the given number.</p>\n","name":"fround","source":"/* Returns the nearest 32-bit single precision float representation of the given number. */\nfun fround (number : Number) : Number {\n  `Math.fround(#{number})`\n}","arguments":[{"type":"Number","name":"number"}]},{"type":"Number","description":"<p>Returns the square root of the sum of squares of its arguments.</p>\n<pre><code>Math.hypot(3, 4) == 5\n</code></pre>\n","name":"hypot","source":"/*\nReturns the square root of the sum of squares of its arguments.\n\n  Math.hypot(3, 4) == 5\n*/\nfun hypot (a : Number, b : Number) : Number {\n  `Math.hypot(#{a}, #{b})`\n}","arguments":[{"type":"Number","name":"a"},{"type":"Number","name":"b"}]},{"type":"Number","description":"<p>Returns the result using C-like 32-bit multiplication of the two parameters.</p>\n<pre><code>Math.imul(3, 4) == 12\n</code></pre>\n","name":"imul","source":"/*\nReturns the result using C-like 32-bit multiplication of the two parameters.\n\n  Math.imul(3, 4) == 12\n*/\nfun imul (a : Number, b : number) : Number {\n  `Math.imul(#{a}, #{b})`\n}","arguments":[{"type":"Number","name":"a"},{"type":"number","name":"b"}]},{"type":"Number","description":"<p>Returns natural logarithm (base e) of the given value</p>\n<pre><code>Math.log(1) == 0\n</code></pre>\n","name":"log","source":"/*\nReturns natural logarithm (base e) of the given value\n\n  Math.log(1) == 0\n*/\nfun log (number : Number) : Number {\n  `Math.log(#{number})`\n}","arguments":[{"type":"Number","name":"number"}]},{"type":"Number","description":"<p>Returns natural logarithm (base 10) of the given value</p>\n<pre><code>Math.log10(100) == 10\n</code></pre>\n","name":"log10","source":"/*\nReturns natural logarithm (base 10) of the given value\n\n  Math.log10(100) == 10\n*/\nfun log10 (number : Number) : Number {\n  `Math.log10(#{number})`\n}","arguments":[{"type":"Number","name":"number"}]},{"type":"Number","description":"<p>Returns natural logarithm (base e) of the given value, plus 1</p>\n<pre><code>Math.log1p(1) == 0\n</code></pre>\n","name":"log1p","source":"/*\nReturns natural logarithm (base e) of the given value, plus 1\n\n  Math.log1p(1) == 0\n*/\nfun log1p (number : Number) : Number {\n  `Math.log1p(#{number})`\n}","arguments":[{"type":"Number","name":"number"}]},{"type":"Number","description":"<p>Returns natural logarithm (base 2) of the given value</p>\n<pre><code>Math.log2(8) == 3\n</code></pre>\n","name":"log2","source":"/*\nReturns natural logarithm (base 2) of the given value\n\n  Math.log2(8) == 3\n*/\nfun log2 (number : Number) : Number {\n  `Math.log2(#{number})`\n}","arguments":[{"type":"Number","name":"number"}]},{"type":"Number","description":"<p>Returns the highest-valued number from the arguments.</p>\n<pre><code>Math.max(1, 2) == 2\n</code></pre>\n","name":"max","source":"/*\nReturns the highest-valued number from the arguments.\n\n  Math.max(1, 2) == 2\n*/\nfun max (number1 : Number, number2 : Number) : Number {\n  `Math.max(#{number1}, #{number2})`\n}","arguments":[{"type":"Number","name":"number1"},{"type":"Number","name":"number2"}]},{"type":"Number","description":"<p>Returns the lowest-valued number from the arguments.</p>\n<pre><code>Math.min(1, 2) == 1\n</code></pre>\n","name":"min","source":"/*\nReturns the lowest-valued number from the arguments.\n\n  Math.min(1, 2) == 1\n*/\nfun min (number1 : Number, number2 : Number) : Number {\n  `Math.min(#{number1}, #{number2})`\n}","arguments":[{"type":"Number","name":"number1"},{"type":"Number","name":"number2"}]},{"type":"Number","description":"<p>Negates the given number.</p>\n<pre><code>Math.negate(1) == -1\n</code></pre>\n","name":"negate","source":"/*\nNegates the given number.\n\n  Math.negate(1) == -1\n*/\nfun negate (number : Number) : Number {\n  `-#{number}`\n}","arguments":[{"type":"Number","name":"number"}]},{"type":"Number","description":"<p>Returns the exponent power of the given number.</p>\n<pre><code>Math.pow(2, 2) == 4\n</code></pre>\n","name":"pow","source":"/*\nReturns the exponent power of the given number.\n\n  Math.pow(2, 2) == 4\n*/\nfun pow (value : Number, exponent : Number) : Number {\n  `Math.pow(#{value}, #{exponent})`\n}","arguments":[{"type":"Number","name":"value"},{"type":"Number","name":"exponent"}]},{"type":"Number","description":"<p>Returns a pseudo-random number in the range 0 to less than 1.</p>\n","name":"random","source":"/* Returns a pseudo-random number in the range 0 to less than 1. */\nfun random : Number {\n  `Math.random()`\n}","arguments":[]},{"type":"Number","description":"<p>Returns the value of a number rounded to the nearest integer.</p>\n<pre><code>Math.round(0.5) == 1\n</code></pre>\n","name":"round","source":"/*\nReturns the value of a number rounded to the nearest integer.\n\n  Math.round(0.5) == 1\n*/\nfun round (number : Number) : Number {\n  `Math.round(#{number})`\n}","arguments":[{"type":"Number","name":"number"}]},{"type":"Number","description":"<p>Returns the sign of the given number (1 or -1)</p>\n<pre><code>Math.sign(5) == 1\nMath.sign(-5) == -1\n</code></pre>\n","name":"sign","source":"/*\nReturns the sign of the given number (1 or -1)\n\n  Math.sign(5) == 1\n  Math.sign(-5) == -1\n*/\nfun sign (number : Number) : Number {\n  `Math.sign(#{number})`\n}","arguments":[{"type":"Number","name":"number"}]},{"type":"Number","description":"<p>Calculates the sine of the given angle in radians</p>\n","name":"sin","source":"/* Calculates the sine of the given angle in radians */\nfun sin (value : Number) : Number {\n  `Math.sin(#{value})`\n}","arguments":[{"type":"Number","name":"value"}]},{"type":"Number","description":"<p>Calculates the hyperbolic sine of the given angle in radians</p>\n","name":"sinh","source":"/* Calculates the hyperbolic sine of the given angle in radians */\nfun sinh (number : Number) : Number {\n  `Math.sinh(#{number})`\n}","arguments":[{"type":"Number","name":"number"}]},{"type":"Number","description":"<p>Returns the square root of the given number</p>\n<pre><code>Math.sqrt(4) == 2\n</code></pre>\n","name":"sqrt","source":"/*\nReturns the square root of the given number\n\n  Math.sqrt(4) == 2\n*/\nfun sqrt (value : Number) : Number {\n  `Math.sqrt(#{value})`\n}","arguments":[{"type":"Number","name":"value"}]},{"type":null,"description":"<p>Calculates the tangent of the given angle in radians</p>\n","name":"tan","source":"/* Calculates the tangent of the given angle in radians */\nfun tan (number : Number) {\n  `Math.tan(#{number})`\n}","arguments":[{"type":"Number","name":"number"}]},{"type":"Number","description":"<p>Calculates the hyperbolic tangent of the given angle in radians</p>\n","name":"tanh","source":"/* Calculates the hyperbolic tangent of the given angle in radians */\nfun tanh (number : Number) : Number {\n  `Math.tanh(#{number})`\n}","arguments":[{"type":"Number","name":"number"}]},{"type":null,"description":"<p>Returns the integer part of a number by removing any fractional digits.</p>\n<pre><code>Math.trunc(13.37) == 13\nMath.trunc(42.84) == 42\n</code></pre>\n","name":"trunc","source":"/*\nReturns the integer part of a number by removing any fractional digits.\n\n  Math.trunc(13.37) == 13\n  Math.trunc(42.84) == 42\n*/\nfun trunc (number : Number) {\n  `Math.trunc(#{number})`\n}","arguments":[{"type":"Number","name":"number"}]},{"type":"Number","description":"<p>Truncates the given number to the given amount.</p>\n<pre><code>Math.truncate(0.123456, 2) == 0.12\n</code></pre>\n","name":"truncate","source":"/*\nTruncates the given number to the given amount.\n\n  Math.truncate(0.123456, 2) == 0.12\n*/\nfun truncate (value : Number, to : Number) : Number {\n  let multiplier =\n    if to == 0 {\n      1\n    } else {\n      to * 100\n    }\n\n  `Math.trunc(#{value} * #{multiplier}) / #{multiplier}`\n}","arguments":[{"type":"Number","name":"value"},{"type":"Number","name":"to"}]}]},{"description":null,"name":"Maybe","functions":[{"type":"Maybe(result)","description":"<p>Maps the value of a maybe with a possibility to discard it.</p>\n<pre><code>Maybe::Just(4)\n|&gt; Maybe.andThen((num : Number) : Maybe(String) {\n  if (num &gt; 4) {\n    Maybe::Just(Number.toString(num))\n  } else {\n    Maybe::Nothing\n  }\n})\n</code></pre>\n","name":"andThen","source":"/*\nMaps the value of a maybe with a possibility to discard it.\n\n  Maybe::Just(4)\n  |> Maybe.andThen((num : Number) : Maybe(String) {\n    if (num > 4) {\n      Maybe::Just(Number.toString(num))\n    } else {\n      Maybe::Nothing\n    }\n  })\n*/\nfun andThen (\n  maybe : Maybe(value),\n  transform : Function(value, Maybe(result))\n) : Maybe(result) {\n  case maybe {\n    Maybe.Just(value) => transform(value)\n    Maybe.Nothing => Maybe.Nothing\n  }\n}","arguments":[{"type":"Maybe(value)","name":"maybe"},{"type":"Function(value, Maybe(result))","name":"transform"}]},{"type":"Maybe(value)","description":"<p>Flattens a nested maybe.</p>\n<pre><code>(Maybe.just(&quot;A&quot;)\n|&gt; Maybe.just()\n|&gt; Maybe.flatten()) == Maybe.just(&quot;A&quot;)\n</code></pre>\n","name":"flatten","source":"/*\nFlattens a nested maybe.\n\n  (Maybe.just(\"A\")\n  |> Maybe.just()\n  |> Maybe.flatten()) == Maybe.just(\"A\")\n*/\nfun flatten (maybe : Maybe(Maybe(value))) : Maybe(value) {\n  case maybe {\n    Maybe.Nothing => Maybe.Nothing\n    Maybe.Just(value) => value\n  }\n}","arguments":[{"type":"Maybe(Maybe(value))","name":"maybe"}]},{"type":"Bool","description":"<p>Returns whether or not the maybe is just a value or not.</p>\n<pre><code> Maybe.isJust(Maybe.just(&quot;A&quot;)) == true\n Maybe.isJust(Maybe.nothing()) == false\n</code></pre>\n","name":"isJust","source":"/*\nReturns whether or not the maybe is just a value or not.\n\n   Maybe.isJust(Maybe.just(\"A\")) == true\n   Maybe.isJust(Maybe.nothing()) == false\n*/\nfun isJust (maybe : Maybe(value)) : Bool {\n  maybe != Maybe.Nothing\n}","arguments":[{"type":"Maybe(value)","name":"maybe"}]},{"type":"Bool","description":"<p>Returns whether or not the maybe is just nothing or not.</p>\n<pre><code>Maybe.isNothing(Maybe.just(&quot;A&quot;)) == false\nMaybe.isNothing(Maybe.nothing(&quot;A&quot;)) == false\n</code></pre>\n","name":"isNothing","source":"/*\nReturns whether or not the maybe is just nothing or not.\n\n  Maybe.isNothing(Maybe.just(\"A\")) == false\n  Maybe.isNothing(Maybe.nothing(\"A\")) == false\n*/\nfun isNothing (maybe : Maybe(value)) : Bool {\n  maybe == Maybe.Nothing\n}","arguments":[{"type":"Maybe(value)","name":"maybe"}]},{"type":"Maybe(value)","description":"<p>Returns a maybe containing just the given value.</p>\n","name":"just","source":"/* Returns a maybe containing just the given value. */\nfun just (value : value) : Maybe(value) {\n  Maybe.Just(value)\n}","arguments":[{"type":"value","name":"value"}]},{"type":"Maybe(result)","description":"<p>Maps the value of a maybe.</p>\n<pre><code>(Maybe.just(1)\n|&gt; Maybe.map((number : Number) : Number { number + 2 })) == 3\n</code></pre>\n","name":"map","source":"/*\nMaps the value of a maybe.\n\n  (Maybe.just(1)\n  |> Maybe.map((number : Number) : Number { number + 2 })) == 3\n*/\nfun map (maybe : Maybe(value), func : Function(value, result)) : Maybe(result) {\n  case maybe {\n    Maybe.Just(value) => Maybe.Just(func(value))\n    Maybe.Nothing => Maybe.Nothing\n  }\n}","arguments":[{"type":"Maybe(value)","name":"maybe"},{"type":"Function(value, result)","name":"func"}]},{"type":"Maybe(value)","description":"<p>Returns nothing.</p>\n","name":"nothing","source":"/* Returns nothing. */\nfun nothing : Maybe(value) {\n  Maybe.Nothing\n}","arguments":[]},{"type":"Maybe(value)","description":"<p>Returns the first maybe with value of the array or nothing if all are nothing.</p>\n<pre><code>Maybe.oneOf([Maybe.just(&quot;A&quot;), Maybe.nothing()]) == Maybe.just(&quot;A&quot;)\n</code></pre>\n","name":"oneOf","source":"/*\nReturns the first maybe with value of the array or nothing if all are nothing.\n\n  Maybe.oneOf([Maybe.just(\"A\"), Maybe.nothing()]) == Maybe.just(\"A\")\n*/\nfun oneOf (array : Array(Maybe(value))) : Maybe(value) {\n  array\n  |> Array.find((item : Maybe(value)) : Bool { Maybe.isJust(item) })\n  |> flatten()\n}","arguments":[{"type":"Array(Maybe(value))","name":"array"}]},{"type":"Result(error, value)","description":"<p>Converts the maybe to a result using the given value as the error.</p>\n<pre><code>Maybe.toResult(Maybe.nothing(), &quot;Error&quot;) == Result.error(&quot;Error&quot;)\nMaybe.toResult(Maybe.just(&quot;A&quot;), &quot;Error&quot;) == Result.ok(&quot;A&quot;)\n</code></pre>\n","name":"toResult","source":"/*\nConverts the maybe to a result using the given value as the error.\n\n  Maybe.toResult(Maybe.nothing(), \"Error\") == Result.error(\"Error\")\n  Maybe.toResult(Maybe.just(\"A\"), \"Error\") == Result.ok(\"A\")\n*/\nfun toResult (maybe : Maybe(value), error : error) : Result(error, value) {\n  case maybe {\n    Maybe.Just(value) => Result.Ok(value)\n    Maybe.Nothing => Result.Err(error)\n  }\n}","arguments":[{"type":"Maybe(value)","name":"maybe"},{"type":"error","name":"error"}]},{"type":"value","description":"<p>Returns the value of a maybe or the given value if it's nothing.</p>\n<pre><code>Maybe.withDefault(Maybe.nothing(), &quot;A&quot;) == &quot;A&quot;\nMaybe.withDefault(Maybe.just(&quot;B&quot;), &quot;A&quot;) == &quot;B&quot;\n</code></pre>\n","name":"withDefault","source":"/*\nReturns the value of a maybe or the given value if it's nothing.\n\n  Maybe.withDefault(Maybe.nothing(), \"A\") == \"A\"\n  Maybe.withDefault(Maybe.just(\"B\"), \"A\") == \"B\"\n*/\nfun withDefault (maybe : Maybe(value), defaultValue : value) : value {\n  maybe or defaultValue\n}","arguments":[{"type":"Maybe(value)","name":"maybe"},{"type":"value","name":"defaultValue"}]},{"type":"value","description":"<p>Returns the value of a <em>maybe</em>, or calls the given <em>func</em> otherwise.</p>\n<pre><code>Maybe.withLazyDefault(Maybe.nothing(), () { &quot;A&quot; }) == &quot;A&quot;\nMaybe.withLazyDefault(Maybe.just(&quot;B&quot;), () { &quot;A&quot; }) == &quot;B&quot;\n</code></pre>\n","name":"withLazyDefault","source":"/*\nReturns the value of a *maybe*, or calls the given *func* otherwise.\n\n  Maybe.withLazyDefault(Maybe.nothing(), () { \"A\" }) == \"A\"\n  Maybe.withLazyDefault(Maybe.just(\"B\"), () { \"A\" }) == \"B\"\n*/\nfun withLazyDefault (maybe : Maybe(value), func : Function(value)) : value {\n  case maybe {\n    Maybe.Nothing => func()\n    Maybe.Just(value) => value\n  }\n}","arguments":[{"type":"Maybe(value)","name":"maybe"},{"type":"Function(value)","name":"func"}]}]},{"description":null,"name":"MutationObserver","functions":[{"type":"MutationObserver","description":"<p>Creates a new resize observer.</p>\n<pre><code>observer =\n  MutationObserver.new((entries : MutationObserver.Entry) {\n    for (entry of entries) {\n      Debug.log(entry)\n    }\n  })\n</code></pre>\n","name":"new","source":"/*\nCreates a new resize observer.\n\n  observer =\n    MutationObserver.new((entries : MutationObserver.Entry) {\n      for (entry of entries) {\n        Debug.log(entry)\n      }\n    })\n*/\nfun new (\n  callback : Function(Array(MutationObserver.Entry), a)\n) : MutationObserver {\n  `new MutationObserver(#{callback})`\n}","arguments":[{"type":"Function(Array(MutationObserver.Entry), a)","name":"callback"}]},{"type":"MutationObserver","description":"<p>Observes the given element.</p>\n","name":"observe","source":"/* Observes the given element. */\nfun observe (\n  observer : MutationObserver,\n  element : Dom.Element,\n  subtree : Bool,\n  childList : Bool\n) : MutationObserver {\n  `\n    #{observer}.observe(#{element}, {\n      childList: #{childList},\n      subtree: #{subtree}\n    }) || #{observer}\n    `\n}","arguments":[{"type":"MutationObserver","name":"observer"},{"type":"Dom.Element","name":"element"},{"type":"Bool","name":"subtree"},{"type":"Bool","name":"childList"}]},{"type":"MutationObserver","description":"<p>Unobserves the given element.</p>\n","name":"unobserve","source":"/* Unobserves the given element. */\nfun unobserve (observer : MutationObserver, element : Dom.Element) : MutationObserver {\n  `#{observer}.disconnect(#{element}) || #{observer}`\n}","arguments":[{"type":"MutationObserver","name":"observer"},{"type":"Dom.Element","name":"element"}]}]},{"description":null,"name":"Number","functions":[{"type":"String","description":"<p>Formats the given number using the given prefix and separating the digits\nby 3 with a comma.</p>\n<pre><code>Number.format(&quot;$ &quot;, 1034150) == &quot;$ 1,034,150&quot;\n</code></pre>\n","name":"format","source":"/*\nFormats the given number using the given prefix and separating the digits\nby 3 with a comma.\n\n  Number.format(\"$ \", 1034150) == \"$ 1,034,150\"\n*/\nfun format (number : Number, prefix : String) : String {\n  let string =\n    Number.toFixed(number, 2)\n\n  let parts =\n    String.split(string, \".\")\n\n  let digits =\n    parts[0]\n    |> Maybe.withDefault(\"\")\n    |> String.chopStart(\"-\")\n    |> String.split(\"\")\n    |> Array.groupsOfFromEnd(3)\n    |> Array.map((items : Array(String)) { String.join(items, \"\") })\n    |> String.join(\",\")\n\n  let decimals =\n    parts[1]\n    |> Maybe.withDefault(\"\")\n    |> String.chopEnd(\"0\")\n\n  if String.isEmpty(decimals) {\n    prefix + digits\n  } else {\n    prefix + digits + \".\" + decimals\n  }\n}","arguments":[{"type":"Number","name":"number"},{"type":"String","name":"prefix"}]},{"type":"Maybe(Number)","description":"<p>Tries to parse the given string into a number.</p>\n<pre><code>Number.fromString(&quot;asd&quot;) == Maybe.nothing()\nNumber.fromString(&quot;012&quot;) == Maybe.just(12)\n</code></pre>\n","name":"fromString","source":"/*\nTries to parse the given string into a number.\n\n  Number.fromString(\"asd\") == Maybe.nothing()\n  Number.fromString(\"012\") == Maybe.just(12)\n*/\nfun fromString (input : String) : Maybe(Number) {\n  `\n    (() => {\n      if (#{input}.trim() === '') {\n        return #{Maybe::Nothing}\n      }\n\n      let value = Number(#{input})\n\n      if (Number.isNaN(value)) {\n        return #{Maybe::Nothing}\n      }\n\n      return #{Maybe::Just(`value`)}\n    })()\n    `\n}","arguments":[{"type":"String","name":"input"}]},{"type":"Bool","description":"<p>Returns true if given number is even.</p>\n<pre><code>Number.isEven(1) == true\nNumber.isEven(2) == false\n</code></pre>\n","name":"isEven","source":"/*\nReturns true if given number is even.\n\n  Number.isEven(1) == true\n  Number.isEven(2) == false\n*/\nfun isEven (input : Number) : Bool {\n  `Math.abs(#{input} % 2) === 0`\n}","arguments":[{"type":"Number","name":"input"}]},{"type":"Bool","description":"<p>Returns true if given number is <code>NaN</code>.</p>\n<pre><code>Number.isNaN(`NaN`) == true\nNumber.isNaN(0) == false\n</code></pre>\n","name":"isNaN","source":"/*\nReturns true if given number is `NaN`.\n\n  Number.isNaN(`NaN`) == true\n  Number.isNaN(0) == false\n*/\nfun isNaN (input : Number) : Bool {\n  `isNaN(#{input})`\n}","arguments":[{"type":"Number","name":"input"}]},{"type":"Bool","description":"<p>Returns true if given number is odd.</p>\n<pre><code>Number.isOdd(1) == false\nNumber.isOdd(2) == true\n</code></pre>\n","name":"isOdd","source":"/*\nReturns true if given number is odd.\n\n  Number.isOdd(1) == false\n  Number.isOdd(2) == true\n*/\nfun isOdd (input : Number) : Bool {\n  `#{input} % 2 === 1`\n}","arguments":[{"type":"Number","name":"input"}]},{"type":"String","description":"<p>Formats a number using fixed-point notation.</p>\n<p>The first arguments specifies the number of digits to appear after the decimal\npoint, it can be between 0 and 20.</p>\n<pre><code>Number.toFixed(2, 0.1234567) == &quot;0.12&quot;\n</code></pre>\n","name":"toFixed","source":"/*\nFormats a number using fixed-point notation.\n\nThe first arguments specifies the number of digits to appear after the decimal\npoint, it can be between 0 and 20.\n\n  Number.toFixed(2, 0.1234567) == \"0.12\"\n*/\nfun toFixed (input : Number, decimalPlaces : Number) : String {\n  `#{input}.toFixed(#{decimalPlaces})`\n}","arguments":[{"type":"Number","name":"input"},{"type":"Number","name":"decimalPlaces"}]},{"type":"String","description":"<p>Returns the string representation of the given number.</p>\n<pre><code>Number.toString(123) == 123\n</code></pre>\n","name":"toString","source":"/*\nReturns the string representation of the given number.\n\n  Number.toString(123) == 123\n*/\nfun toString (input : Number) : String {\n  `#{input}.toString()`\n}","arguments":[{"type":"Number","name":"input"}]}]},{"description":null,"name":"Object.Decode","functions":[{"type":"Result(Object.Error, Array(a))","description":"<p>Decodes the object as an <code>Array</code> using the given decoder.</p>\n<pre><code>Object.Decode.array(`[&quot;A&quot;, &quot;B&quot;]`, Object.Decode.string) == Result::Ok([&quot;a&quot;, &quot;b&quot;])\n</code></pre>\n","name":"array","source":"/*\nDecodes the object as an `Array` using the given decoder.\n\n  Object.Decode.array(`[\"A\", \"B\"]`, Object.Decode.string) == Result::Ok([\"a\", \"b\"])\n*/\nfun array (\n  input : Object,\n  decoder : Function(Object, Result(Object.Error, a))\n) : Result(Object.Error, Array(a)) {\n  `Decoder.array(#{decoder})(#{input})`\n}","arguments":[{"type":"Object","name":"input"},{"type":"Function(Object, Result(Object.Error, a))","name":"decoder"}]},{"type":"Result(Object.Error, Bool)","description":"<p>Decodes the object as a <code>Bool</code></p>\n<pre><code>Object.Decode.boolean(`true`) == Result::Ok(true)\n</code></pre>\n","name":"boolean","source":"/*\nDecodes the object as a `Bool`\n\n  Object.Decode.boolean(`true`) == Result::Ok(true)\n*/\nfun boolean (input : Object) : Result(Object.Error, Bool) {\n  `Decoder.boolean(#{input})`\n}","arguments":[{"type":"Object","name":"input"}]},{"type":"Result(Object.Error, a)","description":"<p>Decodes a field from an object using the given decoder.</p>\n<pre><code>Object.Decode.field(\n  `{field: &quot;Value&quot;}`, &quot;field&quot;, Object.Decode.string) == Result::Ok(&quot;Value&quot;)\n</code></pre>\n","name":"field","source":"/*\nDecodes a field from an object using the given decoder.\n\n  Object.Decode.field(\n    `{field: \"Value\"}`, \"field\", Object.Decode.string) == Result::Ok(\"Value\")\n*/\nfun field (\n  input : Object,\n  key : String,\n  decoder : Function(Object, Result(Object.Error, a))\n) : Result(Object.Error, a) {\n  `Decoder.field(#{key}, #{decoder})(#{input})`\n}","arguments":[{"type":"Object","name":"input"},{"type":"String","name":"key"},{"type":"Function(Object, Result(Object.Error, a))","name":"decoder"}]},{"type":"Result(Object.Error, Maybe(a))","description":"<p>Decodes the object as a <code>Maybe(a)</code> using the given decoder.</p>\n<pre><code>Object.Decode.maybe(`&quot;A&quot;`, Object.Decode.String) == Result::Ok(Maybe::Just(&quot;A&quot;))\nObject.Decode.maybe(`null`, Object.Decode.String) == Result::Ok(Maybe::Nothing)\n</code></pre>\n","name":"maybe","source":"/*\nDecodes the object as a `Maybe(a)` using the given decoder.\n\n  Object.Decode.maybe(`\"A\"`, Object.Decode.String) == Result::Ok(Maybe::Just(\"A\"))\n  Object.Decode.maybe(`null`, Object.Decode.String) == Result::Ok(Maybe::Nothing)\n*/\nfun maybe (\n  input : Object,\n  decoder : Function(Object, Result(Object.Error, a))\n) : Result(Object.Error, Maybe(a)) {\n  `Decoder.maybe(#{decoder})(#{input})`\n}","arguments":[{"type":"Object","name":"input"},{"type":"Function(Object, Result(Object.Error, a))","name":"decoder"}]},{"type":"Result(Object.Error, Number)","description":"<p>Decodes the object as a <code>Number</code></p>\n<pre><code>Object.Decode.number(`0`) == Result::Ok(0)\n</code></pre>\n","name":"number","source":"/*\nDecodes the object as a `Number`\n\n  Object.Decode.number(`0`) == Result::Ok(0)\n*/\nfun number (input : Object) : Result(Object.Error, Number) {\n  `Decoder.number(#{input})`\n}","arguments":[{"type":"Object","name":"input"}]},{"type":"Result(Object.Error, String)","description":"<p>Decodes the object as a <code>String</code></p>\n<pre><code>Object.Decode.string(`&quot;A&quot;`) == Result::Ok(&quot;A&quot;)\n</code></pre>\n","name":"string","source":"/*\nDecodes the object as a `String`\n\n  Object.Decode.string(`\"A\"`) == Result::Ok(\"A\")\n*/\nfun string (input : Object) : Result(Object.Error, String) {\n  `Decoder.string(#{input})`\n}","arguments":[{"type":"Object","name":"input"}]},{"type":"Result(Object.Error, Time)","description":"<p>Decodes the object as a <code>Time</code></p>\n<pre><code>Object.Decode.time(`&quot;new Date()&quot;`)\n</code></pre>\n","name":"time","source":"/*\nDecodes the object as a `Time`\n\n  Object.Decode.time(`\"new Date()\"`)\n*/\nfun time (input : Object) : Result(Object.Error, Time) {\n  `Decoder.time(#{input})`\n}","arguments":[{"type":"Object","name":"input"}]}]},{"description":null,"name":"Object.Encode","functions":[{"type":"Object","description":"<p>Encodes an <code>Array</code> of objects.</p>\n<pre><code>Object.Encode.array([&quot;Hello&quot;, &quot;World&quot;])\n</code></pre>\n","name":"array","source":"/*\nEncodes an `Array` of objects.\n\n  Object.Encode.array([\"Hello\", \"World\"])\n*/\nfun array (input : Array(Object)) : Object {\n  `#{input}`\n}","arguments":[{"type":"Array(Object)","name":"input"}]},{"type":"Object","description":"<p>Encodes a <code>Bool</code>.</p>\n<pre><code>Object.Encode.bool(true)\n</code></pre>\n","name":"boolean","source":"/*\nEncodes a `Bool`.\n\n  Object.Encode.bool(true)\n*/\nfun boolean (input : Bool) : Object {\n  `#{input}`\n}","arguments":[{"type":"Bool","name":"input"}]},{"type":"Object.Field","description":"<p>Encodes a field of an object.</p>\n<pre><code>Object.Encode.field(&quot;key&quot;, Object.Encode.string(&quot;value&quot;))\n</code></pre>\n","name":"field","source":"/*\nEncodes a field of an object.\n\n  Object.Encode.field(\"key\", Object.Encode.string(\"value\"))\n*/\nfun field (name : String, value : Object) : Object.Field {\n  `{ name: #{name}, value: #{value} }`\n}","arguments":[{"type":"String","name":"name"},{"type":"Object","name":"value"}]},{"type":"Object","description":"<p>Encodes a <code>Number</code>.</p>\n<pre><code>Object.Encode.number(10)\n</code></pre>\n","name":"number","source":"/*\nEncodes a `Number`.\n\n  Object.Encode.number(10)\n*/\nfun number (input : Number) : Object {\n  `#{input}`\n}","arguments":[{"type":"Number","name":"input"}]},{"type":"Object","description":"<p>Encodes an array of fields as an object.</p>\n<pre><code>Object.Encode.object([\n  Object.Encode.field(&quot;key&quot;, Object.Encode.string(&quot;value&quot;)),\n  Object.Encode.field(&quot;key2&quot;, Object.Encode.string(&quot;value2&quot;))\n])\n</code></pre>\n","name":"object","source":"/*\nEncodes an array of fields as an object.\n\n  Object.Encode.object([\n    Object.Encode.field(\"key\", Object.Encode.string(\"value\")),\n    Object.Encode.field(\"key2\", Object.Encode.string(\"value2\"))\n  ])\n*/\nfun object (fields : Array(Object.Field)) : Object {\n  `\n    (() => {\n      let result = {}\n\n      for (let item of #{fields}) {\n        result[item.name] = item.value\n      }\n\n      return result\n    })()\n    `\n}","arguments":[{"type":"Array(Object.Field)","name":"fields"}]},{"type":"Object","description":"<p>Encodes a <code>String</code>.</p>\n<pre><code>Object.Encode.string(&quot;Hello&quot;)\n</code></pre>\n","name":"string","source":"/*\nEncodes a `String`.\n\n  Object.Encode.string(\"Hello\")\n*/\nfun string (input : String) : Object {\n  `#{input}`\n}","arguments":[{"type":"String","name":"input"}]},{"type":"Object","description":"<p>Encodes a <code>Time</code>.</p>\n<pre><code>Object.Encode.time(Time.now())\n</code></pre>\n","name":"time","source":"/*\nEncodes a `Time`.\n\n  Object.Encode.time(Time.now())\n*/\nfun time (input : Time) : Object {\n  `#{input}.toISOString()`\n}","arguments":[{"type":"Time","name":"input"}]}]},{"description":null,"name":"Object.Error","functions":[{"type":"String","description":"<p>Formats the error as string.</p>\n","name":"toString","source":"/* Formats the error as string. */\nfun toString (error : Object.Error) : String {\n  `#{error}.toString()`\n}","arguments":[{"type":"Object.Error","name":"error"}]}]},{"description":null,"name":"Promise","functions":[{"type":"Promise(Void)","description":"<p>Returns a resolved promise with <code>Void</code> which never fails.</p>\n","name":"never","source":"/* Returns a resolved promise with `Void` which never fails. */\nfun never : Promise(Void) {\n  resolve(void)\n}","arguments":[]},{"type":"Promise(Void)","description":"<p>Returns a resolved promise with <code>Void</code> which never fails with one\nargument which is ignored.</p>\n<pre><code>Promise.never1(&quot;Value&quot;)\n</code></pre>\n","name":"never1","source":"/*\nReturns a resolved promise with `Void` which never fails with one\nargument which is ignored.\n\n  Promise.never1(\"Value\")\n*/\nfun never1 (param1 : a) : Promise(Void) {\n  Promise.resolve(void)\n}","arguments":[{"type":"a","name":"param1"}]},{"type":"Promise(Void)","description":"<p>Returns a resolved promise with <code>Void</code> which never fails with two\narguments which are ignored.</p>\n<pre><code>Promise.never1(&quot;Value1&quot;, &quot;Value2&quot;)\n</code></pre>\n","name":"never2","source":"/*\nReturns a resolved promise with `Void` which never fails with two\narguments which are ignored.\n\n  Promise.never1(\"Value1\", \"Value2\")\n*/\nfun never2 (param1 : a, param2 : b) : Promise(Void) {\n  Promise.resolve(void)\n}","arguments":[{"type":"a","name":"param1"},{"type":"b","name":"param2"}]},{"type":"Promise(Void)","description":"<p>Returns a resolved promise with <code>Void</code> which never fails with three\narguments which are ignored.</p>\n<pre><code>Promise.never1(&quot;Value1&quot;, &quot;Value2&quot;, &quot;Value3&quot;)\n</code></pre>\n","name":"never3","source":"/*\nReturns a resolved promise with `Void` which never fails with three\narguments which are ignored.\n\n  Promise.never1(\"Value1\", \"Value2\", \"Value3\")\n*/\nfun never3 (param1 : a, param2 : b, param3 : c) : Promise(Void) {\n  Promise.resolve(void)\n}","arguments":[{"type":"a","name":"param1"},{"type":"b","name":"param2"},{"type":"c","name":"param3"}]},{"type":"Promise(a)","description":"<p>Creates an already resolved <code>Promise</code></p>\n","name":"resolve","source":"/* Creates an already resolved `Promise` */\nfun resolve (input : a) : Promise(a) {\n  `Promise.resolve(#{input})`\n}","arguments":[{"type":"a","name":"input"}]},{"type":"Tuple(Function(value, Void), Promise(value))","description":"<p>Create a promise with manual resolve.</p>\n<pre><code>{resolve, promise} = Promise.create()\n</code></pre>\n","name":"create","source":"/*\nCreate a promise with manual resolve.\n\n  {resolve, promise} = Promise.create()\n*/\nfun create : Tuple(Function(value, Void), Promise(value)) {\n  `\n    (() => {\n      let resolve;\n\n      const promise = new Promise((a) => { resolve = a })\n\n      return [\n        (value) => resolve(value),\n        promise\n      ]\n    })()\n    `\n}","arguments":[]}]},{"description":null,"name":"Regexp","functions":[{"type":"Regexp","description":"<p>Creates a new regular expression from a string.</p>\n<pre><code>(Regexp.create(&quot;test&quot;)\n|&gt; Regexp.toString()) == &quot;/test/&quot;\n</code></pre>\n","name":"create","source":"/*\nCreates a new regular expression from a string.\n\n  (Regexp.create(\"test\")\n  |> Regexp.toString()) == \"/test/\"\n*/\nfun create (input : String) : Regexp {\n  `new RegExp(#{input})`\n}","arguments":[{"type":"String","name":"input"}]},{"type":"Regexp","description":"<p>Creates a new regular expression using the given options.</p>\n<pre><code>(Regexp.createWithOptions(\n  &quot;test&quot;,\n  {\n    caseInsensitive = true,\n    multiline = true,\n    unicode = true,\n    global = true,\n    sticky = true\n  })\n|&gt; Regexp.toString()) == &quot;/test/gimuy&quot;\n</code></pre>\n","name":"createWithOptions","source":"/*\nCreates a new regular expression using the given options.\n\n  (Regexp.createWithOptions(\n    \"test\",\n    {\n      caseInsensitive = true,\n      multiline = true,\n      unicode = true,\n      global = true,\n      sticky = true\n    })\n  |> Regexp.toString()) == \"/test/gimuy\"\n*/\nfun createWithOptions (input : String, options : Regexp.Options) : Regexp {\n  `\n    (() => {\n      let flags = \"\"\n\n      if (#{options.caseInsensitive}) { flags += \"i\" }\n      if (#{options.multiline}) { flags += \"m\" }\n      if (#{options.unicode}) { flags += \"u\" }\n      if (#{options.global}) { flags += \"g\" }\n      if (#{options.sticky}) { flags += \"y\" }\n\n      return new RegExp(#{input}, flags)\n    })()\n    `\n}","arguments":[{"type":"String","name":"input"},{"type":"Regexp.Options","name":"options"}]},{"type":"String","description":"<p>Escapes the given input to use in the regular expression.</p>\n<pre><code>Regexp.escape(&quot;-{&quot;) == &quot;\\\\-\\\\{&quot;\n</code></pre>\n","name":"escape","source":"/*\nEscapes the given input to use in the regular expression.\n\n  Regexp.escape(\"-{\") == \"\\\\-\\\\{\"\n*/\nfun escape (input : String) : String {\n  `#{input}.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&')`\n}","arguments":[{"type":"String","name":"input"}]},{"type":"Bool","description":"<p>Returns whether or not the given regular expression matches the given string.</p>\n<pre><code>(Regexp.create(&quot;,&quot;)\n|&gt; Regexp.match(&quot;asd,asd&quot;)) == true\n</code></pre>\n","name":"match","source":"/*\nReturns whether or not the given regular expression matches the given string.\n\n  (Regexp.create(\",\")\n  |> Regexp.match(\"asd,asd\")) == true\n*/\nfun match (regexp : Regexp, input : String) : Bool {\n  `#{regexp}.test(#{input})`\n}","arguments":[{"type":"Regexp","name":"regexp"},{"type":"String","name":"input"}]},{"type":"Array(Regexp.Match)","description":"<p>Returns all of the matches of the given regular expression against the\ngiven string.</p>\n<pre><code>(Regexp.createWithOptions(\n  &quot;\\\\w&quot;,\n  {\n    caseInsensitive = true,\n    multiline = false,\n    unicode = false,\n    global = true,\n    sticky = false\n  })\n|&gt; Regexp.matces(&quot;a,b,c,d&quot;) == [\n  {\n    submatches = [],\n    match = &quot;a&quot;,\n    index = 0\n  }\n]\n  \\match : Regexp.Match =&gt; match.match + &quot;1&quot;)) == &quot;a1,b1,c1,d1&quot;\n</code></pre>\n","name":"matches","source":"/*\nReturns all of the matches of the given regular expression against the\ngiven string.\n\n  (Regexp.createWithOptions(\n    \"\\\\w\",\n    {\n      caseInsensitive = true,\n      multiline = false,\n      unicode = false,\n      global = true,\n      sticky = false\n    })\n  |> Regexp.matces(\"a,b,c,d\") == [\n    {\n      submatches = [],\n      match = \"a\",\n      index = 0\n    }\n  ]\n    \\match : Regexp.Match => match.match + \"1\")) == \"a1,b1,c1,d1\"\n*/\nfun matches (regexp : Regexp, input : String) : Array(Regexp.Match) {\n  `\n    (() => {\n      let results = []\n      let index = 0\n\n      #{input}.replace(#{regexp}, function() {\n        const args =\n          Array.from(arguments)\n\n        const match =\n          args.shift()\n\n        const submatches =\n          args.slice(0, -2)\n\n        index += 1\n\n        results.push(#{{\n          submatches: `submatches`,\n          index: `index`,\n          match: `match`\n        }})\n      })\n\n      return results\n    })()\n    `\n}","arguments":[{"type":"Regexp","name":"regexp"},{"type":"String","name":"input"}]},{"type":"String","description":"<p>Replaces the matches of the given regular expression using the given function\nto calculate the replacement string.</p>\n<pre><code>(Regexp.createWithOptions(\n  &quot;\\\\w&quot;,\n  {\n    caseInsensitive = true,\n    multiline = false,\n    unicode = false,\n    global = true,\n    sticky = false\n  })\n|&gt; Regexp.replace(\n  &quot;a,b,c,d&quot;,\n  \\match : Regexp.Match =&gt; match.match + &quot;1&quot;)) == &quot;a1,b1,c1,d1&quot;\n</code></pre>\n","name":"replace","source":"/*\nReplaces the matches of the given regular expression using the given function\nto calculate the replacement string.\n\n  (Regexp.createWithOptions(\n    \"\\\\w\",\n    {\n      caseInsensitive = true,\n      multiline = false,\n      unicode = false,\n      global = true,\n      sticky = false\n    })\n  |> Regexp.replace(\n    \"a,b,c,d\",\n    \\match : Regexp.Match => match.match + \"1\")) == \"a1,b1,c1,d1\"\n*/\nfun replace (\n  regexp : Regexp,\n  input : String,\n  replacer : Function(Regexp.Match, String)\n) : String {\n  `\n    (() => {\n      let index = 0\n\n      return #{input}.replace(#{regexp}, function() {\n        const args =\n          Array.from(arguments)\n\n        const match =\n          args.shift()\n\n        const submatches =\n          args.slice(0, -2)\n\n        index += 1\n\n        return #{replacer}(#{{\n          submatches: `submatches`,\n          index: `index`,\n          match: `match`\n        }})\n      })\n    })()\n    `\n}","arguments":[{"type":"Regexp","name":"regexp"},{"type":"String","name":"input"},{"type":"Function(Regexp.Match, String)","name":"replacer"}]},{"type":"Array(String)","description":"<p>Splits the given string by the given regular expression.</p>\n<pre><code>(Regexp.create(&quot;,&quot;)\n|&gt; Regexp.split(&quot;a,b,c,d&quot;)) == [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]\n</code></pre>\n","name":"split","source":"/*\nSplits the given string by the given regular expression.\n\n  (Regexp.create(\",\")\n  |> Regexp.split(\"a,b,c,d\")) == [\"a\", \"b\", \"c\", \"d\"]\n*/\nfun split (regexp : Regexp, input : String) : Array(String) {\n  `#{input}.split(#{regexp})`\n}","arguments":[{"type":"Regexp","name":"regexp"},{"type":"String","name":"input"}]},{"type":"String","description":"<p>Returns the string representation of the given regular expression.</p>\n<pre><code>(Regexp.create(&quot;test&quot;)\n|&gt; Regexp.toString()) == &quot;/test/&quot;\n</code></pre>\n","name":"toString","source":"/*\nReturns the string representation of the given regular expression.\n\n  (Regexp.create(\"test\")\n  |> Regexp.toString()) == \"/test/\"\n*/\nfun toString (regexp : Regexp) : String {\n  `#{regexp}.toString()`\n}","arguments":[{"type":"Regexp","name":"regexp"}]}]},{"description":null,"name":"ResizeObserver","functions":[{"type":"ResizeObserver","description":"<p>Creates a new resize observer.</p>\n<pre><code>observer =\n  ResizeObserver.new((entries : ResizeObserver.Entry) {\n    for (entry of entries) {\n      Debug.log(entry)\n    }\n  })\n</code></pre>\n","name":"new","source":"/*\nCreates a new resize observer.\n\n  observer =\n    ResizeObserver.new((entries : ResizeObserver.Entry) {\n      for (entry of entries) {\n        Debug.log(entry)\n      }\n    })\n*/\nfun new (\n  callback : Function(Array(ResizeObserver.Entry), a)\n) : ResizeObserver {\n  `\n    new ResizeObserver((entries) => {\n      const values = entries.map((item) => {\n        return #{\n          {\n            let dimensions =\n              decode (`item.contentRect`) as Dom.Dimensions\n              |> Result.withDefault(Dom.Dimensions.empty())\n\n            {\n              dimensions: dimensions,\n              target: `item.target`\n            }\n          }\n        }\n      })\n\n      #{callback(`values`)}\n    })\n    `\n}","arguments":[{"type":"Function(Array(ResizeObserver.Entry), a)","name":"callback"}]},{"type":"ResizeObserver","description":"<p>Observes the given element.</p>\n","name":"observe","source":"/* Observes the given element. */\nfun observe (observer : ResizeObserver, element : Dom.Element) : ResizeObserver {\n  `#{observer}.observe(#{element}) || #{observer}`\n}","arguments":[{"type":"ResizeObserver","name":"observer"},{"type":"Dom.Element","name":"element"}]},{"type":"ResizeObserver","description":"<p>Unobserves the given element.</p>\n","name":"unobserve","source":"/* Unobserves the given element. */\nfun unobserve (observer : ResizeObserver, element : Dom.Element) : ResizeObserver {\n  `#{observer}.unobserve(#{element}) || #{observer}`\n}","arguments":[{"type":"ResizeObserver","name":"observer"},{"type":"Dom.Element","name":"element"}]}]},{"description":null,"name":"Result","functions":[{"type":"Result(a, b)","description":"<p>Returns a new error result.</p>\n<pre><code>(Result.error(&quot;error&quot;)\n|&gt; Result.isError()) == true\n</code></pre>\n","name":"error","source":"/*\nReturns a new error result.\n\n  (Result.error(\"error\")\n  |> Result.isError()) == true\n*/\nfun error (input : a) : Result(a, b) {\n  Result.Err(input)\n}","arguments":[{"type":"a","name":"input"}]},{"type":"Result(error, b)","description":"<p>Maps over the value of the result to an other result and flattens it.</p>\n<pre><code>(Result.error(&quot;error&quot;)\n|&gt; Result.flatMap(\\item : String =&gt; Result::Ok(item + &quot;1&quot;))) == Result.error(&quot;error&quot;)\n\n(Result.ok(&quot;ok&quot;)\n|&gt; Result.map(\\item : String =&gt; Result::Ok(item + &quot;1&quot;))) == Result.ok(&quot;ok1&quot;)\n</code></pre>\n","name":"flatMap","source":"/*\nMaps over the value of the result to an other result and flattens it.\n\n  (Result.error(\"error\")\n  |> Result.flatMap(\\item : String => Result::Ok(item + \"1\"))) == Result.error(\"error\")\n\n  (Result.ok(\"ok\")\n  |> Result.map(\\item : String => Result::Ok(item + \"1\"))) == Result.ok(\"ok1\")\n*/\nfun flatMap (\n  input : Result(error, a),\n  func : Function(a, Result(error, b))\n) : Result(error, b) {\n  Result.map(input, func)\n  |> Result.join()\n}","arguments":[{"type":"Result(error, a)","name":"input"},{"type":"Function(a, Result(error, b))","name":"func"}]},{"type":"Bool","description":"<p>Returns true if the result is an error.</p>\n<pre><code>(Result.error(&quot;error&quot;)\n|&gt; Result.isError()) == true\n</code></pre>\n","name":"isError","source":"/*\nReturns true if the result is an error.\n\n  (Result.error(\"error\")\n  |> Result.isError()) == true\n*/\nfun isError (input : Result(a, b)) : Bool {\n  case input {\n    Result.Err => true\n    Result.Ok => false\n  }\n}","arguments":[{"type":"Result(a, b)","name":"input"}]},{"type":"Bool","description":"<p>Returns true if the result is ok.</p>\n<pre><code>(Result.ok(&quot;ok&quot;)\n|&gt; Result.isOk()) == true\n</code></pre>\n","name":"isOk","source":"/*\nReturns true if the result is ok.\n\n  (Result.ok(\"ok\")\n  |> Result.isOk()) == true\n*/\nfun isOk (input : Result(a, b)) : Bool {\n  case input {\n    Result.Err => false\n    Result.Ok => true\n  }\n}","arguments":[{"type":"Result(a, b)","name":"input"}]},{"type":"Result(error, value)","description":"<p>Joins two results together.</p>\n<pre><code>Result.join(Result::Ok(Result::Ok(&quot;Hello&quot;))) == Result::Ok(&quot;Hello&quot;)\nResult.join(Result::Err(&quot;Error&quot;) == Result::Err(&quot;Error&quot;)\n</code></pre>\n","name":"join","source":"/*\nJoins two results together.\n\n  Result.join(Result::Ok(Result::Ok(\"Hello\"))) == Result::Ok(\"Hello\")\n  Result.join(Result::Err(\"Error\") == Result::Err(\"Error\")\n*/\nfun join (input : Result(error, Result(error, value))) : Result(error, value) {\n  case input {\n    Result.Err(error) => Result.Err(error)\n    Result.Ok(value) => value\n  }\n}","arguments":[{"type":"Result(error, Result(error, value))","name":"input"}]},{"type":"Result(a, c)","description":"<p>Maps over the value of the result.</p>\n<pre><code>(Result.error(&quot;error&quot;)\n|&gt; Result.map(\\item : String =&gt; item + &quot;1&quot;)) == Result.error(&quot;error&quot;)\n\n(Result.ok(&quot;ok&quot;)\n|&gt; Result.map(\\item : String =&gt; item + &quot;1&quot;)) == Result.ok(&quot;ok1&quot;)\n</code></pre>\n","name":"map","source":"/*\nMaps over the value of the result.\n\n  (Result.error(\"error\")\n  |> Result.map(\\item : String => item + \"1\")) == Result.error(\"error\")\n\n  (Result.ok(\"ok\")\n  |> Result.map(\\item : String => item + \"1\")) == Result.ok(\"ok1\")\n*/\nfun map (input : Result(a, b), func : Function(b, c)) : Result(a, c) {\n  case input {\n    Result.Ok(value) => Result.Ok(func(value))\n    Result.Err => input\n  }\n}","arguments":[{"type":"Result(a, b)","name":"input"},{"type":"Function(b, c)","name":"func"}]},{"type":"Result(c, b)","description":"<p>Maps over the error of the result.</p>\n<pre><code>(Result.error(&quot;error&quot;)\n|&gt; Result.mapError(\\item : String =&gt; item + &quot;1&quot;)) == Result.error(&quot;error1&quot;)\n\n(Result.ok(&quot;ok&quot;)\n|&gt; Result.mapError(\\item : String =&gt; item + &quot;1&quot;)) == Result.ok(&quot;ok&quot;)\n</code></pre>\n","name":"mapError","source":"/*\nMaps over the error of the result.\n\n  (Result.error(\"error\")\n  |> Result.mapError(\\item : String => item + \"1\")) == Result.error(\"error1\")\n\n  (Result.ok(\"ok\")\n  |> Result.mapError(\\item : String => item + \"1\")) == Result.ok(\"ok\")\n*/\nfun mapError (input : Result(a, b), func : Function(a, c)) : Result(c, b) {\n  case input {\n    Result.Err(value) => Result.Err(func(value))\n    Result.Ok => input\n  }\n}","arguments":[{"type":"Result(a, b)","name":"input"},{"type":"Function(a, c)","name":"func"}]},{"type":"Result(b, a)","description":"<p>Returns a new ok result.</p>\n<pre><code>(Result.ok(&quot;ok&quot;)\n|&gt; Result.isOk()) == true\n</code></pre>\n","name":"ok","source":"/*\nReturns a new ok result.\n\n  (Result.ok(\"ok\")\n  |> Result.isOk()) == true\n*/\nfun ok (input : a) : Result(b, a) {\n  Result.Ok(input)\n}","arguments":[{"type":"a","name":"input"}]},{"type":"Maybe(b)","description":"<p>Converts the result into a maybe.</p>\n<pre><code>(Result.ok(&quot;blah&quot;)\n|&gt; Result.toMaybe()) == Maybe.just(&quot;blah&quot;)\n\n(Result.error(&quot;blah&quot;)\n|&gt; Result.toMaybe()) == Maybe.nothing()\n</code></pre>\n","name":"toMaybe","source":"/*\nConverts the result into a maybe.\n\n  (Result.ok(\"blah\")\n  |> Result.toMaybe()) == Maybe.just(\"blah\")\n\n  (Result.error(\"blah\")\n  |> Result.toMaybe()) == Maybe.nothing()\n*/\nfun toMaybe (result : Result(a, b)) : Maybe(b) {\n  case result {\n    Result.Ok(value) => Maybe.Just(value)\n    Result.Err => Maybe.Nothing\n  }\n}","arguments":[{"type":"Result(a, b)","name":"result"}]},{"type":"b","description":"<p>Returns the value of the result or the default value if it's an error.</p>\n<pre><code>(Result.error(&quot;error&quot;)\n|&gt; Result.withDefault(&quot;a&quot;)) == &quot;a&quot;\n\n(Result.ok(&quot;ok&quot;)\n|&gt; Result.withDefault(&quot;a&quot;)) == &quot;ok&quot;\n</code></pre>\n","name":"withDefault","source":"/*\nReturns the value of the result or the default value if it's an error.\n\n  (Result.error(\"error\")\n  |> Result.withDefault(\"a\")) == \"a\"\n\n  (Result.ok(\"ok\")\n  |> Result.withDefault(\"a\")) == \"ok\"\n*/\nfun withDefault (input : Result(a, b), defaultValue : b) : b {\n  case input {\n    Result.Ok(value) => value\n    Result.Err => defaultValue\n  }\n}","arguments":[{"type":"Result(a, b)","name":"input"},{"type":"b","name":"defaultValue"}]},{"type":"a","description":"<p>Returns the error of the result or the default value if it's an ok.</p>\n<pre><code>(Result.error(&quot;error&quot;)\n|&gt; Result.withError(&quot;a&quot;)) == &quot;error&quot;\n\n(Result.ok(&quot;ok&quot;)\n|&gt; Result.withError(&quot;a&quot;)) == &quot;a&quot;\n</code></pre>\n","name":"withError","source":"/*\nReturns the error of the result or the default value if it's an ok.\n\n  (Result.error(\"error\")\n  |> Result.withError(\"a\")) == \"error\"\n\n  (Result.ok(\"ok\")\n  |> Result.withError(\"a\")) == \"a\"\n*/\nfun withError (input : Result(a, b), defaultError : a) : a {\n  case input {\n    Result.Err(value) => value\n    Result.Ok => defaultError\n  }\n}","arguments":[{"type":"Result(a, b)","name":"input"},{"type":"a","name":"defaultError"}]}]},{"description":null,"name":"SearchParams","functions":[{"type":"SearchParams","description":"<p>Appends a specified key/value pair as a new search parameter.</p>\n<pre><code>SearchParams.empty()\n|&gt; SearchParams.append(&quot;key&quot;, &quot;value&quot;)\n</code></pre>\n","name":"append","source":"/*\nAppends a specified key/value pair as a new search parameter.\n\n  SearchParams.empty()\n  |> SearchParams.append(\"key\", \"value\")\n*/\nfun append (params : SearchParams, key : String, value : String) : SearchParams {\n  `\n    (() => {\n      let newParams = new URLSearchParams(#{params}.toString())\n      newParams.append(#{key}, #{value})\n      return newParams\n    })()\n    `\n}","arguments":[{"type":"SearchParams","name":"params"},{"type":"String","name":"key"},{"type":"String","name":"value"}]},{"type":"Bool","description":"<p>Returns a <code>Bool</code> indicating if such a search parameter exists.</p>\n<pre><code>(SearchParams.fromString(&quot;key=value&quot;)\n |&gt; SearchParams.contains(&quot;key&quot;)) == true\n</code></pre>\n","name":"contains","source":"/*\nReturns a `Bool` indicating if such a search parameter exists.\n\n  (SearchParams.fromString(\"key=value\")\n   |> SearchParams.contains(\"key\")) == true\n*/\nfun contains (params : SearchParams, key : String) : Bool {\n  `#{params}.has(#{key})`\n}","arguments":[{"type":"SearchParams","name":"params"},{"type":"String","name":"key"}]},{"type":"SearchParams","description":"<p>Deletes the given search parameter, and its associated value, from the\nlist of all search parameters.</p>\n<pre><code>SearchParams.fromString(&quot;key=value&quot;)\n|&gt; SearchParams.delete(&quot;key&quot;)\n</code></pre>\n","name":"delete","source":"/*\nDeletes the given search parameter, and its associated value, from the\nlist of all search parameters.\n\n  SearchParams.fromString(\"key=value\")\n  |> SearchParams.delete(\"key\")\n*/\nfun delete (params : SearchParams, key : String) : SearchParams {\n  `\n    (() => {\n      let newParams = new URLSearchParams(#{params}.toString())\n      newParams.delete(#{key})\n      return newParams\n    })()\n    `\n}","arguments":[{"type":"SearchParams","name":"params"},{"type":"String","name":"key"}]},{"type":"SearchParams","description":"<p>Returns an empty search parameters object.</p>\n<pre><code>SearchParams.empty()\n</code></pre>\n","name":"empty","source":"/*\nReturns an empty search parameters object.\n\n  SearchParams.empty()\n*/\nfun empty : SearchParams {\n  `new URLSearchParams()`\n}","arguments":[]},{"type":"SearchParams","description":"<p>Parses a string into a search parameters object.</p>\n<pre><code>SearchParams.fromString(&quot;key=value&quot;)\n</code></pre>\n","name":"fromString","source":"/*\nParses a string into a search parameters object.\n\n  SearchParams.fromString(\"key=value\")\n*/\nfun fromString (value : String) : SearchParams {\n  `new URLSearchParams(#{value})`\n}","arguments":[{"type":"String","name":"value"}]},{"type":"Maybe(String)","description":"<p>Returns the first value associated to the given search parameter.</p>\n<pre><code>(SearchParams.fromString(&quot;key=value&quot;)\n |&gt; SearchParams.get(&quot;key&quot;)) == &quot;value&quot;\n</code></pre>\n","name":"get","source":"/*\nReturns the first value associated to the given search parameter.\n\n  (SearchParams.fromString(\"key=value\")\n   |> SearchParams.get(\"key\")) == \"value\"\n*/\nfun get (params : SearchParams, key : String) : Maybe(String) {\n  `\n    (() => {\n      let value = #{params}.get(#{key})\n\n      if (value === null) {\n        return #{Maybe::Nothing}\n      } else {\n        return #{Maybe::Just(`value`)}\n      }\n    })()\n    `\n}","arguments":[{"type":"SearchParams","name":"params"},{"type":"String","name":"key"}]},{"type":"SearchParams","description":"<p>Sets the value associated to a given search parameter to the given value.\nIf there were several values, delete the others.</p>\n<pre><code>SearchParams.empty()\n|&gt; SearchParams.set(&quot;key&quot;, &quot;value&quot;)\n</code></pre>\n","name":"set","source":"/*\nSets the value associated to a given search parameter to the given value.\nIf there were several values, delete the others.\n\n  SearchParams.empty()\n  |> SearchParams.set(\"key\", \"value\")\n*/\nfun set (params : SearchParams, key : String, value : String) : SearchParams {\n  `\n    (() => {\n      let newParams = new URLSearchParams(#{params}.toString())\n      newParams.set(#{key}, #{value})\n      return newParams\n    })()\n    `\n}","arguments":[{"type":"SearchParams","name":"params"},{"type":"String","name":"key"},{"type":"String","name":"value"}]},{"type":"String","description":"<p>Returns a string containing a query string suitable for use in a URL.</p>\n<pre><code>(SearchParams.empty()\n |&gt; SearchParams.set(&quot;key&quot;, &quot;value&quot;)\n |&gt; SearchParams.toString()) == &quot;key=value&quot;\n</code></pre>\n","name":"toString","source":"/*\nReturns a string containing a query string suitable for use in a URL.\n\n  (SearchParams.empty()\n   |> SearchParams.set(\"key\", \"value\")\n   |> SearchParams.toString()) == \"key=value\"\n*/\nfun toString (params : SearchParams) : String {\n  `#{params}.toString()`\n}","arguments":[{"type":"SearchParams","name":"params"}]}]},{"description":null,"name":"Set","functions":[{"type":"Set(item)","description":"<p>Adds the given value to the set.</p>\n<pre><code>(Set.empty()\n|&gt; Set.add(&quot;value&quot;)) == Set.fromArray([&quot;value&quot;])\n</code></pre>\n","name":"add","source":"/*\nAdds the given value to the set.\n\n  (Set.empty()\n  |> Set.add(\"value\")) == Set.fromArray([\"value\"])\n*/\nfun add (set : Set(item), value : item) : Set(item) {\n  `\n    (() => {\n      if (#{has(set, value)}) { return #{set} }\n\n      const newSet = Array.from(#{set})\n      newSet.push(#{value})\n\n      return newSet\n    })()\n    `\n}","arguments":[{"type":"Set(item)","name":"set"},{"type":"item","name":"value"}]},{"type":"Set(item)","description":"<p>Deletes the given value from the set.</p>\n<pre><code>(Set.empty()\n|&gt; Set.add(&quot;value&quot;)\n|&gt; Set.delete(&quot;value&quot;)) == Set.empty()\n</code></pre>\n","name":"delete","source":"/*\nDeletes the given value from the set.\n\n  (Set.empty()\n  |> Set.add(\"value\")\n  |> Set.delete(\"value\")) == Set.empty()\n*/\nfun delete (set : Set(item), value : item) : Set(item) {\n  `\n    (() => {\n      const newSet = []\n\n      #{set}.forEach((item) => {\n        if (_compare(item, #{value})) { return }\n        newSet.push(item)\n      })\n\n      return newSet\n    })()\n    `\n}","arguments":[{"type":"Set(item)","name":"set"},{"type":"item","name":"value"}]},{"type":"Set(item)","description":"<p>Returns an empty set.</p>\n","name":"empty","source":"/* Returns an empty set. */\nfun empty : Set(item) {\n  `[]`\n}","arguments":[]},{"type":"Set(item)","description":"<p>Converts an Array to a Set.</p>\n<pre><code>(Set.empty()\n|&gt; Set.add(&quot;value&quot;)) == Set.fromArray([&quot;value&quot;])\n</code></pre>\n","name":"fromArray","source":"/*\nConverts an Array to a Set.\n\n  (Set.empty()\n  |> Set.add(\"value\")) == Set.fromArray([\"value\"])\n*/\nfun fromArray (array : Array(item)) : Set(item) {\n  `#{Array.uniq(array)}`\n}","arguments":[{"type":"Array(item)","name":"array"}]},{"type":"Bool","description":"<p>Returns whether or not the given set has the given value.</p>\n<pre><code>(Set.empty()\n|&gt; Set.add(Maybe.just(&quot;value&quot;))\n|&gt; Set.has(Maybe.just(&quot;value&quot;))) == true\n</code></pre>\n","name":"has","source":"/*\nReturns whether or not the given set has the given value.\n\n  (Set.empty()\n  |> Set.add(Maybe.just(\"value\"))\n  |> Set.has(Maybe.just(\"value\"))) == true\n*/\nfun has (set : Set(item), value : item) : Bool {\n  `\n    (() => {\n      for (let item of #{set}) {\n        if (_compare(item, #{value})) {\n          return true\n        }\n      }\n\n      return false\n    })()\n    `\n}","arguments":[{"type":"Set(item)","name":"set"},{"type":"item","name":"value"}]},{"type":"Set(b)","description":"<p>Maps over the items of the set to return a new set.</p>\n<pre><code>(Set.fromArray([0])\n|&gt; Set.map(Number.toString)) == Set.fromArray([&quot;0&quot;])\n</code></pre>\n","name":"map","source":"/*\nMaps over the items of the set to return a new set.\n\n  (Set.fromArray([0])\n  |> Set.map(Number.toString)) == Set.fromArray([\"0\"])\n*/\nfun map (set : Set(item), method : Function(item, b)) : Set(b) {\n  `\n    (() => {\n      const newSet = []\n\n      #{set}.forEach((item) => {\n        newSet.push(#{method}(item))\n      })\n\n      return newSet\n    })()\n    `\n}","arguments":[{"type":"Set(item)","name":"set"},{"type":"Function(item, b)","name":"method"}]},{"type":"Number","description":"<p>Returns the size of a set</p>\n<pre><code>Set.size(Set.fromArray([0,1,2])) == 3\n</code></pre>\n","name":"size","source":"/*\nReturns the size of a set\n\n  Set.size(Set.fromArray([0,1,2])) == 3\n*/\nfun size (set : Set(item)) : Number {\n  `#{set}.length`\n}","arguments":[{"type":"Set(item)","name":"set"}]},{"type":"Array(item)","description":"<p>Converts the Set to an Array.</p>\n<pre><code>(Set.empty()\n|&gt; Set.add(&quot;value&quot;)\n|&gt; Set.toArray()) == [&quot;value&quot;]\n</code></pre>\n","name":"toArray","source":"/*\nConverts the Set to an Array.\n\n  (Set.empty()\n  |> Set.add(\"value\")\n  |> Set.toArray()) == [\"value\"]\n*/\nfun toArray (set : Set(item)) : Array(item) {\n  `#{set}`\n}","arguments":[{"type":"Set(item)","name":"set"}]}]},{"description":null,"name":"Storage.Common","functions":[{"type":"Result(Storage.Error, Void)","description":"<p>Clears the given storage.</p>\n","name":"clear","source":"/* Clears the given storage. */\nfun clear (storage : Storage) : Result(Storage.Error, Void) {\n  `\n    (() => {\n      try {\n        #{storage}.clear()\n        return #{Result::Ok(void)}\n      } catch (error) {\n        switch(error.name) {\n          case 'SecurityError':\n            return #{Result::Err(Storage.Error::SecurityError)}\n          default:\n            return #{Result::Err(Storage.Error::Unknown)}\n        }\n      }\n    })()\n    `\n}","arguments":[{"type":"Storage","name":"storage"}]},{"type":"Result(Storage.Error, Void)","description":"<p>Deletes the value with the given key from the given storage.</p>\n","name":"delete","source":"/* Deletes the value with the given key from the given storage. */\nfun delete (storage : Storage, key : String) : Result(Storage.Error, Void) {\n  `\n    (() => {\n      try {\n        #{storage}.removeItem(#{key})\n        return #{Result::Ok(void)}\n      } catch (error) {\n        switch(error.name) {\n          case 'SecurityError':\n            return #{Result::Err(Storage.Error::SecurityError)}\n          default:\n            return #{Result::Err(Storage.Error::Unknown)}\n        }\n      }\n    })()\n    `\n}","arguments":[{"type":"Storage","name":"storage"},{"type":"String","name":"key"}]},{"type":"Result(Storage.Error, String)","description":"<p>Gets the value of given key in the given storage.</p>\n","name":"get","source":"/* Gets the value of given key in the given storage. */\nfun get (storage : Storage, key : String) : Result(Storage.Error, String) {\n  `\n    (() => {\n      try {\n        let value = #{storage}.getItem(#{key})\n\n        if (typeof value === \"string\") {\n          return #{Result::Ok(`value`)}\n        } else {\n          return #{Result::Err(Storage.Error::NotFound)}\n        }\n      } catch (error) {\n        switch(error.name) {\n          case 'SecurityError':\n            return #{Result::Err(Storage.Error::SecurityError)}\n          default:\n            return #{Result::Err(Storage.Error::Unknown)}\n        }\n      }\n    })()\n    `\n}","arguments":[{"type":"Storage","name":"storage"},{"type":"String","name":"key"}]},{"type":"Result(Storage.Error, Array(String))","description":"<p>Returns the keys in the given storage.</p>\n","name":"keys","source":"/* Returns the keys in the given storage. */\nfun keys (storage : Storage) : Result(Storage.Error, Array(String)) {\n  `\n    (() => {\n      try {\n        return #{Result::Ok(`Object.keys(#{storage}).sort()`)}\n      } catch (error) {\n        switch(error.name) {\n          case 'SecurityError':\n            return #{Result::Err(Storage.Error::SecurityError)}\n          default:\n            return #{Result::Err(Storage.Error::Unknown)}\n        }\n      }\n    })()\n    `\n}","arguments":[{"type":"Storage","name":"storage"}]},{"type":"Result(Storage.Error, Void)","description":"<p>Sets the given key to the given value in the given storage.</p>\n","name":"set","source":"/* Sets the given key to the given value in the given storage. */\nfun set (storage : Storage, key : String, value : String) : Result(Storage.Error, Void) {\n  `\n    (() => {\n      try {\n        #{storage}.setItem(#{key}, #{value})\n        return #{Result::Ok(void)}\n      } catch (error) {\n        switch(error.name) {\n          case 'SecurityError':\n            return #{Result::Err(Storage.Error::SecurityError)}\n          case 'QUOTA_EXCEEDED_ERR':\n            return #{Result::Err(Storage.Error::QuotaExceeded)}\n          case 'QuotaExceededError':\n            return #{Result::Err(Storage.Error::QuotaExceeded)}\n          case 'NS_ERROR_DOM_QUOTA_REACHED':\n            return #{Result::Err(Storage.Error::QuotaExceeded)}\n          default:\n            return #{Result::Err(Storage.Error::Unknown)}\n        }\n      }\n    })()\n    `\n}","arguments":[{"type":"Storage","name":"storage"},{"type":"String","name":"key"},{"type":"String","name":"value"}]},{"type":"Result(Storage.Error, Number)","description":"<p>Returns the number of items in the storage.</p>\n","name":"size","source":"/* Returns the number of items in the storage. */\nfun size (storage : Storage) : Result(Storage.Error, Number) {\n  `\n    (() => {\n      try {\n        return #{Result::Ok(`#{storage}.length`)}\n      } catch (error) {\n        switch(error.name) {\n          case 'SecurityError':\n            return #{Result::Err(Storage.Error::SecurityError)}\n          default:\n            return #{Result::Err(Storage.Error::Unknown)}\n        }\n      }\n    })()\n    `\n}","arguments":[{"type":"Storage","name":"storage"}]}]},{"description":null,"name":"Storage.Local","functions":[{"type":"Result(Storage.Error, Void)","description":"<p>Clears the local storage.</p>\n<pre><code>Storage.Local.clear()\n</code></pre>\n","name":"clear","source":"/*\nClears the local storage.\n\n  Storage.Local.clear()\n*/\nfun clear : Result(Storage.Error, Void) {\n  Storage.Common.clear(`localStorage`)\n}","arguments":[]},{"type":"Result(Storage.Error, Void)","description":"<p>Delete the value with the given key.</p>\n<pre><code>Storage.Local.delete(&quot;key&quot;)\n</code></pre>\n","name":"delete","source":"/*\nDelete the value with the given key.\n\n  Storage.Local.delete(\"key\")\n*/\nfun delete (key : String) : Result(Storage.Error, Void) {\n  Storage.Common.delete(`localStorage`, key)\n}","arguments":[{"type":"String","name":"key"}]},{"type":"Result(Storage.Error, String)","description":"<p>Gets the value of given key.</p>\n<pre><code>Storage.Local.get(&quot;key&quot;)\n</code></pre>\n","name":"get","source":"/*\nGets the value of given key.\n\n  Storage.Local.get(\"key\")\n*/\nfun get (key : String) : Result(Storage.Error, String) {\n  Storage.Common.get(`localStorage`, key)\n}","arguments":[{"type":"String","name":"key"}]},{"type":"Result(Storage.Error, Array(String))","description":"<p>Returns the keys in the local storage.</p>\n<pre><code>Storage.Local.keys() == []\n</code></pre>\n","name":"keys","source":"/*\nReturns the keys in the local storage.\n\n  Storage.Local.keys() == []\n*/\nfun keys : Result(Storage.Error, Array(String)) {\n  Storage.Common.keys(`localStorage`)\n}","arguments":[]},{"type":"Result(Storage.Error, Void)","description":"<p>Sets the given key to the given value.</p>\n<pre><code>Storage.Local.set(&quot;key&quot;, &quot;value&quot;)\n</code></pre>\n","name":"set","source":"/*\nSets the given key to the given value.\n\n  Storage.Local.set(\"key\", \"value\")\n*/\nfun set (key : String, value : String) : Result(Storage.Error, Void) {\n  Storage.Common.set(`localStorage`, key, value)\n}","arguments":[{"type":"String","name":"key"},{"type":"String","name":"value"}]},{"type":"Result(Storage.Error, Number)","description":"<p>Returns the number of items in the local storage.</p>\n<pre><code>Storage.Local.size() == 0\n</code></pre>\n","name":"size","source":"/*\nReturns the number of items in the local storage.\n\n  Storage.Local.size() == 0\n*/\nfun size : Result(Storage.Error, Number) {\n  Storage.Common.size(`localStorage`)\n}","arguments":[]}]},{"description":null,"name":"Storage.Session","functions":[{"type":"Result(Storage.Error, Void)","description":"<p>Clears the session storage.</p>\n<pre><code>Storage.Session.clear()\n</code></pre>\n","name":"clear","source":"/*\nClears the session storage.\n\n  Storage.Session.clear()\n*/\nfun clear : Result(Storage.Error, Void) {\n  Storage.Common.clear(`sessionStorage`)\n}","arguments":[]},{"type":"Result(Storage.Error, Void)","description":"<p>Delete the value with the given key.</p>\n<pre><code>Storage.Session.delete(&quot;key&quot;)\n</code></pre>\n","name":"delete","source":"/*\nDelete the value with the given key.\n\n  Storage.Session.delete(\"key\")\n*/\nfun delete (key : String) : Result(Storage.Error, Void) {\n  Storage.Common.delete(`sessionStorage`, key)\n}","arguments":[{"type":"String","name":"key"}]},{"type":"Result(Storage.Error, String)","description":"<p>Gets the value of given key.</p>\n<pre><code>Storage.Session.get(&quot;key&quot;)\n</code></pre>\n","name":"get","source":"/*\nGets the value of given key.\n\n  Storage.Session.get(\"key\")\n*/\nfun get (key : String) : Result(Storage.Error, String) {\n  Storage.Common.get(`sessionStorage`, key)\n}","arguments":[{"type":"String","name":"key"}]},{"type":"Result(Storage.Error, Array(String))","description":"<p>Returns the keys in the session storage.</p>\n<pre><code>Storage.Session.keys() == []\n</code></pre>\n","name":"keys","source":"/*\nReturns the keys in the session storage.\n\n  Storage.Session.keys() == []\n*/\nfun keys : Result(Storage.Error, Array(String)) {\n  Storage.Common.keys(`sessionStorage`)\n}","arguments":[]},{"type":"Result(Storage.Error, Void)","description":"<p>Sets the given key to the given value.</p>\n<pre><code>Storage.Session.set(&quot;key&quot;, &quot;value&quot;)\n</code></pre>\n","name":"set","source":"/*\nSets the given key to the given value.\n\n  Storage.Session.set(\"key\", \"value\")\n*/\nfun set (key : String, value : String) : Result(Storage.Error, Void) {\n  Storage.Common.set(`sessionStorage`, key, value)\n}","arguments":[{"type":"String","name":"key"},{"type":"String","name":"value"}]},{"type":"Result(Storage.Error, Number)","description":"<p>Returns the number of items in the session storage.</p>\n<pre><code>Storage.Session.size() == 0\n</code></pre>\n","name":"size","source":"/*\nReturns the number of items in the session storage.\n\n  Storage.Session.size() == 0\n*/\nfun size : Result(Storage.Error, Number) {\n  Storage.Common.size(`sessionStorage`)\n}","arguments":[]}]},{"description":null,"name":"String","functions":[{"type":"String","description":"<p>Capitalizes each letter in the given string.</p>\n<pre><code>String.capitalize(&quot;The quick brown fox jumps.&quot;) == &quot;The Quick Brown Fox Jumps.&quot;\n</code></pre>\n","name":"capitalize","source":"/*\nCapitalizes each letter in the given string.\n\n  String.capitalize(\"The quick brown fox jumps.\") == \"The Quick Brown Fox Jumps.\"\n*/\nfun capitalize (string : String) : String {\n  `#{string}.replace(/\\b[a-z]/g, char => char.toUpperCase())`\n}","arguments":[{"type":"String","name":"string"}]},{"type":"String","description":"<p>Returns a string representing the character (exactly one UTF-16 code unit) at\nthe specified index. If index is out of range, it returns an empty string.</p>\n<pre><code>String.charAt(&quot;The quick brown fox jumps over the lazy dog.&quot;, 4) == &quot;q&quot;\n</code></pre>\n","name":"charAt","source":"/*\nReturns a string representing the character (exactly one UTF-16 code unit) at\nthe specified index. If index is out of range, it returns an empty string.\n\n  String.charAt(\"The quick brown fox jumps over the lazy dog.\", 4) == \"q\"\n*/\nfun charAt (string : String, index : Number) : String {\n  `#{string}.charAt(#{index})`\n}","arguments":[{"type":"String","name":"string"},{"type":"Number","name":"index"}]},{"type":"Maybe(Number)","description":"<p>Returns an integer between 0 and 65535 representing the UTF-16 code unit at\nthe given index.</p>\n<pre><code>String.charCodeAt(&quot;The quick brown fox jumps over the lazy dog.&quot;, 4) == Maybe::Just(113)\n</code></pre>\n","name":"charCodeAt","source":"/*\nReturns an integer between 0 and 65535 representing the UTF-16 code unit at\nthe given index.\n\n  String.charCodeAt(\"The quick brown fox jumps over the lazy dog.\", 4) == Maybe::Just(113)\n*/\nfun charCodeAt (string : String, index : Number) : Maybe(Number) {\n  `\n    (() => {\n      const result = #{string}.charCodeAt(#{index});\n\n      if (isNaN(result)) {\n        return #{Maybe::Nothing}\n      } else {\n        return #{Maybe::Just(`result`)}\n      }\n    })()\n    `\n}","arguments":[{"type":"String","name":"string"},{"type":"Number","name":"index"}]},{"type":"String","description":"<p>Removes all occurrences of the given character from the end of the\ngiven string.</p>\n<pre><code>String.chopEnd(&quot;The quick brown fox jumps.&quot;, &quot;.&quot;) == &quot;The quick brown fox jumps&quot;\n</code></pre>\n","name":"chopEnd","source":"/*\nRemoves all occurrences of the given character from the end of the\ngiven string.\n\n  String.chopEnd(\"The quick brown fox jumps.\", \".\") == \"The quick brown fox jumps\"\n*/\nfun chopEnd (string : String, char : String) : String {\n  `\n    (() => {\n      while (#{string}.slice(-#{char}.length) == #{char}) {\n        #{string} = #{string}.slice(0,-#{char}.length)\n      }\n\n      return #{string}\n    })()\n    `\n}","arguments":[{"type":"String","name":"string"},{"type":"String","name":"char"}]},{"type":"String","description":"<p>Removes all occurrences of the given character from the start of the\ngiven string.</p>\n<pre><code>String.chopStart(&quot;The quick brown fox jumps.&quot;, &quot;T&quot;) == &quot;he quick brown fox jumps.&quot;\n</code></pre>\n","name":"chopStart","source":"/*\nRemoves all occurrences of the given character from the start of the\ngiven string.\n\n  String.chopStart(\"The quick brown fox jumps.\", \"T\") == \"he quick brown fox jumps.\"\n*/\nfun chopStart (string : String, char : String) : String {\n  `\n    (() => {\n      while (#{string}.slice(0, #{char}.length) == #{char}) {\n        #{string} = #{string}.slice(#{char}.length)\n      }\n\n      return #{string}\n    })()\n    `\n}","arguments":[{"type":"String","name":"string"},{"type":"String","name":"char"}]},{"type":"Maybe(Number)","description":"<p>Returns a non-negative integer that is the UTF-16 code point value.</p>\n<ul>\n<li>\n<p>If there is no element at pos, returns <code>Maybe::Nothing</code>.</p>\n</li>\n<li>\n<p>If the element at pos is a UTF-16 high surrogate, returns the code point of the surrogate pair.</p>\n</li>\n<li>\n<p>If the element at pos is a UTF-16 low surrogate, returns only the low surrogate code point.</p>\n<p>String.codePointAt(&quot;&quot;, 1) == Maybe::Just(9733)</p>\n</li>\n</ul>\n","name":"codePointAt","source":"/*\nReturns a non-negative integer that is the UTF-16 code point value.\n\n* If there is no element at pos, returns `Maybe::Nothing`.\n* If the element at pos is a UTF-16 high surrogate, returns the code point of the surrogate pair.\n* If the element at pos is a UTF-16 low surrogate, returns only the low surrogate code point.\n\n\n  String.codePointAt(\"\", 1) == Maybe::Just(9733)\n*/\nfun codePointAt (string : String, index : Number) : Maybe(Number) {\n  `\n    (() => {\n      const result = #{string}.codePointAt(#{index});\n\n      if (result === undefined) {\n        return #{Maybe::Nothing}\n      } else {\n        return #{Maybe::Just(`result`)}\n      }\n    })()\n    `\n}","arguments":[{"type":"String","name":"string"},{"type":"Number","name":"index"}]},{"type":"String","description":"<p>Joins the given array of strings.</p>\n<pre><code>String.concat([&quot;The&quot;, &quot;quick&quot;, &quot;brown&quot;, &quot;fox&quot;, &quot;jumps.&quot;]) == &quot;Thequickbrownfoxjumps.&quot;\n</code></pre>\n","name":"concat","source":"/*\nJoins the given array of strings.\n\n  String.concat([\"The\", \"quick\", \"brown\", \"fox\", \"jumps.\"]) == \"Thequickbrownfoxjumps.\"\n*/\nfun concat (array : Array(String)) : String {\n  join(array, \"\")\n}","arguments":[{"type":"Array(String)","name":"array"}]},{"type":"Bool","description":"<p>Performs a case-sensitive search to determine whether one string may be found\nwithin another string, returning true or false as appropriate.</p>\n<pre><code>String.contains(&quot;The quick brown fox jumps over the lazy dog.&quot;, &quot;fox&quot;) == true\n</code></pre>\n","name":"contains","source":"/*\nPerforms a case-sensitive search to determine whether one string may be found\nwithin another string, returning true or false as appropriate.\n\n  String.contains(\"The quick brown fox jumps over the lazy dog.\", \"fox\") == true\n*/\nfun contains (string : String, search : String) : Bool {\n  `#{string}.includes(#{search})`\n}","arguments":[{"type":"String","name":"string"},{"type":"String","name":"search"}]},{"type":"String","description":"<p>Drops the number of characters from the end of the string.</p>\n<pre><code>String.dropEnd(&quot;The quick brown fox jumps.&quot;, 1) == &quot;The quick brown fox jumps&quot;\nString.dropEnd(&quot;The quick brown fox jumps.&quot;, 2) == &quot;The quick brown fox jump&quot;\n</code></pre>\n","name":"dropEnd","source":"/*\nDrops the number of characters from the end of the string.\n\n  String.dropEnd(\"The quick brown fox jumps.\", 1) == \"The quick brown fox jumps\"\n  String.dropEnd(\"The quick brown fox jumps.\", 2) == \"The quick brown fox jump\"\n*/\nfun dropEnd (string : String, number : Number) : String {\n  `#{string}.slice(0, -Math.abs(#{number}))`\n}","arguments":[{"type":"String","name":"string"},{"type":"Number","name":"number"}]},{"type":"String","description":"<p>Drops the number of characters from the start of the string.</p>\n<pre><code>String.dropStart(&quot;The quick brown fox jumps.&quot;, 1) == &quot;he quick brown fox jumps.&quot;\nString.dropStart(&quot;The quick brown fox jumps.&quot;, 2) == &quot;e quick brown fox jumps.&quot;\n</code></pre>\n","name":"dropStart","source":"/*\nDrops the number of characters from the start of the string.\n\n  String.dropStart(\"The quick brown fox jumps.\", 1) == \"he quick brown fox jumps.\"\n  String.dropStart(\"The quick brown fox jumps.\", 2) == \"e quick brown fox jumps.\"\n*/\nfun dropStart (string : String, number : Number) : String {\n  `#{string}.slice(#{Math.clamp(0, number, String.size(string))})`\n}","arguments":[{"type":"String","name":"string"},{"type":"Number","name":"number"}]},{"type":"Bool","description":"<p>Determines whether a string ends with the characters of a specified string,\nreturning <code>true</code> or <code>false</code> as appropriate.</p>\n<pre><code>String.endsWith(&quot;The quick brown fox jumps.&quot;, &quot;jumps.&quot;) == true\n</code></pre>\n","name":"endsWith","source":"/*\nDetermines whether a string ends with the characters of a specified string,\nreturning `true` or `false` as appropriate.\n\n  String.endsWith(\"The quick brown fox jumps.\", \"jumps.\") == true\n*/\nfun endsWith (string : String, end : String) : Bool {\n  `#{string}.endsWith(#{end})`\n}","arguments":[{"type":"String","name":"string"},{"type":"String","name":"end"}]},{"type":"String","description":"<p>Returns a string created from the specified UTF-16 code unit.</p>\n<pre><code>String.fromCharCode(65) == &quot;A&quot;\n</code></pre>\n","name":"fromCharCode","source":"/*\nReturns a string created from the specified UTF-16 code unit.\n\n  String.fromCharCode(65) == \"A\"\n*/\nfun fromCharCode (charCode : Number) : String {\n  `String.fromCharCode(#{charCode})`\n}","arguments":[{"type":"Number","name":"charCode"}]},{"type":"String","description":"<p>Returns a string created by using the specified code point.</p>\n<pre><code>String.fromCodePoint(9731) == &quot;&quot;\n</code></pre>\n","name":"fromCodePoint","source":"/*\nReturns a string created by using the specified code point.\n\n  String.fromCodePoint(9731) == \"\"\n*/\nfun fromCodePoint (charCode : Number) : String {\n  `String.fromCodePoint(#{charCode})`\n}","arguments":[{"type":"Number","name":"charCode"}]},{"type":"String","description":"<p>Indents the string with the given number of spaces.</p>\n<pre><code>String.indent(&quot;The quick brown fox jumps.&quot;, 2) == &quot;  The quick brown fox jumps.&quot;\nString.indent(&quot;The quick brown fox jumps.&quot;, 2, &quot;-&quot;, false) == &quot;--The quick brown fox jumps.&quot;\n</code></pre>\n","name":"indent","source":"/*\nIndents the string with the given number of spaces.\n\n  String.indent(\"The quick brown fox jumps.\", 2) == \"  The quick brown fox jumps.\"\n  String.indent(\"The quick brown fox jumps.\", 2, \"-\", false) == \"--The quick brown fox jumps.\"\n*/\nfun indent (\n  string : String,\n  by : Number = 2,\n  character : String = \" \",\n  includeEmptyLines : Bool = true\n) : String {\n  `#{string}.replace(#{includeEmptyLines} ? /^/gm : /^(?!\\s*$)/gm, #{repeat(character, by)})`\n}","arguments":[{"type":"String","name":"string"},{"type":"Number","name":"by"},{"type":"String","name":"character"},{"type":"Bool","name":"includeEmptyLines"}]},{"type":"Maybe(Number)","description":"<p>Returns the index within the calling String object of the first occurrence of\nthe specified value, returns <code>Maybe::Nothing</code> if the value is not found.</p>\n<pre><code>String.indexOf(&quot;The quick brown fox jumps over the lazy dog.&quot;, &quot;whale&quot;) == Maybe::Nothing\nString.indexOf(&quot;The quick brown fox jumps over the lazy dog.&quot;, &quot;fox&quot;) == Maybe::Just(16)\n</code></pre>\n","name":"indexOf","source":"/*\nReturns the index within the calling String object of the first occurrence of\nthe specified value, returns `Maybe::Nothing` if the value is not found.\n\n  String.indexOf(\"The quick brown fox jumps over the lazy dog.\", \"whale\") == Maybe::Nothing\n  String.indexOf(\"The quick brown fox jumps over the lazy dog.\", \"fox\") == Maybe::Just(16)\n*/\nfun indexOf (string : String, search : String) : Maybe(Number) {\n  `\n    (() => {\n      const result = #{string}.indexOf(#{search});\n\n      if (result == -1) {\n        return #{Maybe::Nothing}\n      } else {\n        return #{Maybe::Just(`result`)}\n      }\n    })()\n    `\n}","arguments":[{"type":"String","name":"string"},{"type":"String","name":"search"}]},{"type":"Bool","description":"<p>Returns if the given string is an anagram of the other string.</p>\n<pre><code>String.isAnagram(&quot;The&quot;, &quot;quick&quot;) == false\nString.isAnagram(&quot;rail safety&quot;, &quot;fairy tales&quot;) == true\n</code></pre>\n","name":"isAnagram","source":"/*\nReturns if the given string is an anagram of the other string.\n\n  String.isAnagram(\"The\", \"quick\") == false\n  String.isAnagram(\"rail safety\", \"fairy tales\") == true\n*/\nfun isAnagram (string1 : String, string2 : String) : Bool {\n  `\n    (() => {\n      const normalize = string =>\n        string\n          .toLowerCase()\n          .replace(/[^a-z0-9]/gi, '')\n          .split('')\n          .sort()\n          .join('');\n\n      return normalize(#{string1}) === normalize(#{string2});\n    })()\n    `\n}","arguments":[{"type":"String","name":"string1"},{"type":"String","name":"string2"}]},{"type":"Bool","description":"<p>Returns whether or not the string is blank (only contains whitespace).</p>\n<pre><code> String.isBlank(&quot;&quot;) == true\n String.isBlank(&quot; &quot;) == true\n String.isBlank(&quot;The quick brown fox jumps.&quot;) == false\n</code></pre>\n","name":"isBlank","source":"/*\nReturns whether or not the string is blank (only contains whitespace).\n\n   String.isBlank(\"\") == true\n   String.isBlank(\" \") == true\n   String.isBlank(\"The quick brown fox jumps.\") == false\n*/\nfun isBlank (string : String) : Bool {\n  String.trim(string) == \"\"\n}","arguments":[{"type":"String","name":"string"}]},{"type":"Bool","description":"<p>Returns whether or not the string is empty (&quot;&quot;).</p>\n<pre><code> String.isEmpty(&quot;&quot;) == true\n String.isEmpty(&quot; &quot;) == false\n String.isEmpty(&quot;The quick brown fox jumps.&quot;) == false\n</code></pre>\n","name":"isEmpty","source":"/*\nReturns whether or not the string is empty (\"\").\n\n   String.isEmpty(\"\") == true\n   String.isEmpty(\" \") == false\n   String.isEmpty(\"The quick brown fox jumps.\") == false\n*/\nfun isEmpty (string : String) : Bool {\n  string == \"\"\n}","arguments":[{"type":"String","name":"string"}]},{"type":"Bool","description":"<p>Returns whether or not the string is not blank.</p>\n<pre><code>String.isNotBlank(&quot;   &quot;) == false\nString.isNotBlank(&quot;The quick brown fox jumps.&quot;) == true\n</code></pre>\n","name":"isNotBlank","source":"/*\nReturns whether or not the string is not blank.\n\n  String.isNotBlank(\"   \") == false\n  String.isNotBlank(\"The quick brown fox jumps.\") == true\n*/\nfun isNotBlank (string : String) : Bool {\n  !String.isBlank(string)\n}","arguments":[{"type":"String","name":"string"}]},{"type":"Bool","description":"<p>Returns whether or not the string is not empty.</p>\n<pre><code>String.isNotEmpty(&quot;   &quot;) == true\nString.isNotEmpty(&quot;The quick brown fox jumps.&quot;) == true\n</code></pre>\n","name":"isNotEmpty","source":"/*\nReturns whether or not the string is not empty.\n\n  String.isNotEmpty(\"   \") == true\n  String.isNotEmpty(\"The quick brown fox jumps.\") == true\n*/\nfun isNotEmpty (string : String) : Bool {\n  !String.isEmpty(string)\n}","arguments":[{"type":"String","name":"string"}]},{"type":"String","description":"<p>Joins the given array of string into a single string using the separator.</p>\n<pre><code>String.join([&quot;The&quot;,&quot;quick&quot;,&quot;brown&quot;, &quot;fox&quot;, &quot;jumps.&quot;], &quot; &quot;) == &quot;The quick brown fox jumps.&quot;\n</code></pre>\n","name":"join","source":"/*\nJoins the given array of string into a single string using the separator.\n\n  String.join([\"The\",\"quick\",\"brown\", \"fox\", \"jumps.\"], \" \") == \"The quick brown fox jumps.\"\n*/\nfun join (array : Array(String), separator : String) : String {\n  `#{array}.join(#{separator})`\n}","arguments":[{"type":"Array(String)","name":"array"},{"type":"String","name":"separator"}]},{"type":"Maybe(Number)","description":"<p>Returns the index within the calling String object of the last occurrence of\nthe specified value, returns <code>Maybe::Nothing</code> if the value is not found.</p>\n<pre><code>String.lastIndexOf(&quot;The quick brown fox jumps over the lazy dog.&quot;, &quot;whale&quot;) == Maybe::Nothing\nString.lastIndexOf(&quot;The quick brown fox jumps over the lazy dog.&quot;, &quot;the&quot;) == Maybe::Just(31)\n</code></pre>\n","name":"lastIndexOf","source":"/*\nReturns the index within the calling String object of the last occurrence of\nthe specified value, returns `Maybe::Nothing` if the value is not found.\n\n  String.lastIndexOf(\"The quick brown fox jumps over the lazy dog.\", \"whale\") == Maybe::Nothing\n  String.lastIndexOf(\"The quick brown fox jumps over the lazy dog.\", \"the\") == Maybe::Just(31)\n*/\nfun lastIndexOf (string : String, search : String) : Maybe(Number) {\n  `\n    (() => {\n      const result = #{string}.lastIndexOf(#{search});\n\n      if (result == -1) {\n        return #{Maybe::Nothing}\n      } else {\n        return #{Maybe::Just(`result`)}\n      }\n    })()\n    `\n}","arguments":[{"type":"String","name":"string"},{"type":"String","name":"search"}]},{"type":"String","description":"<p>Returns the Unicode Normalization Form of the string.</p>\n<pre><code>String.normalize(&quot;\\u0041\\u006d\\u0065\\u0301\\u006c\\u0069\\u0065&quot;) == &quot;\\u0041\\u006d\\u00e9\\u006c\\u0069\\u0065&quot;\n</code></pre>\n","name":"normalize","source":"/*\nReturns the Unicode Normalization Form of the string.\n\n  String.normalize(\"\\u0041\\u006d\\u0065\\u0301\\u006c\\u0069\\u0065\") == \"\\u0041\\u006d\\u00e9\\u006c\\u0069\\u0065\"\n*/\nfun normalize (string : String) : String {\n  `#{string}.normalize()`\n}","arguments":[{"type":"String","name":"string"}]},{"type":"String","description":"<p>Pads the current string with another string (multiple times, if needed) until\nthe resulting string reaches the given length. The padding is applied from\nthe end of the current string.</p>\n<pre><code>String.padEnd(&quot;5&quot;, &quot;0&quot;, 2) == &quot;50&quot;\n</code></pre>\n","name":"padEnd","source":"/*\nPads the current string with another string (multiple times, if needed) until\nthe resulting string reaches the given length. The padding is applied from\nthe end of the current string.\n\n  String.padEnd(\"5\", \"0\", 2) == \"50\"\n*/\nfun padEnd (\n  string : String,\n  padString : String,\n  targetLength : Number\n) : String {\n  `#{string}.padEnd(#{targetLength}, #{padString})`\n}","arguments":[{"type":"String","name":"string"},{"type":"String","name":"padString"},{"type":"Number","name":"targetLength"}]},{"type":"String","description":"<p>Pads the current string with another string (multiple times, if needed) until\nthe resulting string reaches the given length. The padding is applied from\nthe start of the current string.</p>\n<pre><code>String.padStart(&quot;5&quot;, &quot;0&quot;, 2) == &quot;05&quot;\n</code></pre>\n","name":"padStart","source":"/*\nPads the current string with another string (multiple times, if needed) until\nthe resulting string reaches the given length. The padding is applied from\nthe start of the current string.\n\n  String.padStart(\"5\", \"0\", 2) == \"05\"\n*/\nfun padStart (\n  string : String,\n  padString : String,\n  targetLength : Number\n) : String {\n  `#{string}.padStart(#{targetLength}, #{padString})`\n}","arguments":[{"type":"String","name":"string"},{"type":"String","name":"padString"},{"type":"Number","name":"targetLength"}]},{"type":"String","description":"<p>Parameterizes the string:</p>\n<ul>\n<li>\n<p>replaces non alphanumeric, dash and underscore characters with dash</p>\n</li>\n<li>\n<p>converts title case to dash case (TitleCase -&gt; title-case)</p>\n</li>\n<li>\n<p>collapses multiple dashes into a single one</p>\n</li>\n<li>\n<p>removes the leading and trailing dash(es)</p>\n</li>\n<li>\n<p>converts to lowercase</p>\n<p>String.parameterize(&quot;The quick brown fox jumps.&quot;) == &quot;the-quick-brown-fox-jumps&quot;</p>\n</li>\n</ul>\n","name":"parameterize","source":"/*\nParameterizes the string:\n- replaces non alphanumeric, dash and underscore characters with dash\n- converts title case to dash case (TitleCase -> title-case)\n- collapses multiple dashes into a single one\n- removes the leading and trailing dash(es)\n- converts to lowercase\n\n  String.parameterize(\"The quick brown fox jumps.\") == \"the-quick-brown-fox-jumps\"\n*/\nfun parameterize (string : String) : String {\n  `\n    #{string}\n      .replace(/[^\\p{Lu}\\p{Ll}0-9\\-_]+/gu, '-') // Replace non alphanumerical with dashes\n      .replace(/\\p{Lu}([\\p{Ll}0-9]+|[\\p{Lu}0-9]+)?/gu, '-$&')\n      .replace(/-{2,}/g, '-')\n      .replace(/^-+/i, '')\n      .replace(/-+$/i, '')\n      .toLowerCase()\n    `\n}","arguments":[{"type":"String","name":"string"}]},{"type":"String","description":"<p>Repeats the given string the given number of times.</p>\n<pre><code>String.repeat(3, &quot;The&quot;) == &quot;TheTheThe&quot;\n</code></pre>\n","name":"repeat","source":"/*\nRepeats the given string the given number of times.\n\n  String.repeat(3, \"The\") == \"TheTheThe\"\n*/\nfun repeat (string : String, times : Number) : String {\n  `#{string}.repeat(#{times})`\n}","arguments":[{"type":"String","name":"string"},{"type":"Number","name":"times"}]},{"type":"String","description":"<p>Returns a new string with the first matches of a pattern replaced by a\nreplacement.</p>\n<pre><code>String.replace(&quot;The quick brown fox jumps.&quot;, &quot;fox&quot;, &quot;bear&quot;) ==\n  &quot;The quick brown bear jumps.&quot;\n</code></pre>\n","name":"replace","source":"/*\nReturns a new string with the first matches of a pattern replaced by a\nreplacement.\n\n  String.replace(\"The quick brown fox jumps.\", \"fox\", \"bear\") ==\n    \"The quick brown bear jumps.\"\n*/\nfun replace (\n  string : String,\n  pattern : String,\n  replacement : String\n) : String {\n  `#{string}.replace(#{pattern}, #{replacement})`\n}","arguments":[{"type":"String","name":"string"},{"type":"String","name":"pattern"},{"type":"String","name":"replacement"}]},{"type":"String","description":"<p>Returns a new string with all matches of a pattern replaced by a replacement.</p>\n<pre><code>String.replaceAll(&quot;The quick brown fox jumps over the lazy fox.&quot;, &quot;fox&quot;, &quot;bear&quot;) ==\n  &quot;The quick brown bear jumps over the lazy bear.&quot;\n</code></pre>\n","name":"replaceAll","source":"/*\nReturns a new string with all matches of a pattern replaced by a replacement.\n\n  String.replaceAll(\"The quick brown fox jumps over the lazy fox.\", \"fox\", \"bear\") ==\n    \"The quick brown bear jumps over the lazy bear.\"\n*/\nfun replaceAll (\n  string : String,\n  pattern : String,\n  replacement : String\n) : String {\n  `#{string}.replaceAll(#{pattern}, #{replacement})`\n}","arguments":[{"type":"String","name":"string"},{"type":"String","name":"pattern"},{"type":"String","name":"replacement"}]},{"type":"String","description":"<p>Reverses the given string.</p>\n<pre><code> String.reverse(&quot;The quick brown fox jumps.&quot;) == &quot;.spmuj xof nworb kciuq ehT&quot;\n</code></pre>\n","name":"reverse","source":"/*\nReverses the given string.\n\n   String.reverse(\"The quick brown fox jumps.\") == \".spmuj xof nworb kciuq ehT\"\n*/\nfun reverse (string : String) : String {\n  `[...#{string}].reverse().join('')`\n}","arguments":[{"type":"String","name":"string"}]},{"type":"Number","description":"<p>Returns number of characters in the given string.</p>\n<pre><code>String.size(&quot;The quick brown fox jumps.&quot;) == 26\n</code></pre>\n","name":"size","source":"/*\nReturns number of characters in the given string.\n\n  String.size(\"The quick brown fox jumps.\") == 26\n*/\nfun size (string : String) : Number {\n  `#{string}.length`\n}","arguments":[{"type":"String","name":"string"}]},{"type":"Array(String)","description":"<p>Splits the given string using the given separator.</p>\n<pre><code>String.split(&quot;The quick brown fox jumps.&quot;, &quot; &quot;) ==\n  [&quot;The&quot;, &quot;quick&quot;, &quot;brown&quot;, &quot;fox&quot;, &quot;jumps.&quot;]\n</code></pre>\n","name":"split","source":"/*\nSplits the given string using the given separator.\n\n  String.split(\"The quick brown fox jumps.\", \" \") ==\n    [\"The\", \"quick\", \"brown\", \"fox\", \"jumps.\"]\n*/\nfun split (string : String, separator : String) : Array(String) {\n  `#{string}.split(#{separator})`\n}","arguments":[{"type":"String","name":"string"},{"type":"String","name":"separator"}]},{"type":"Bool","description":"<p>Determines whether a string starts with the characters of a specified string,\nreturning <code>true</code> or <code>false</code> as appropriate.</p>\n<pre><code>String.startsWith(&quot;The quick brown fox jumps.&quot;, &quot;The&quot;) == true\n</code></pre>\n","name":"startsWith","source":"/*\nDetermines whether a string starts with the characters of a specified string,\nreturning `true` or `false` as appropriate.\n\n  String.startsWith(\"The quick brown fox jumps.\", \"The\") == true\n*/\nfun startsWith (string : String, end : String) : Bool {\n  `#{string}.startsWith(#{end})`\n}","arguments":[{"type":"String","name":"string"},{"type":"String","name":"end"}]},{"type":"String","description":"<p>Returns the given number of characters from the end of the string.</p>\n<pre><code>String.takeEnd(&quot;The quick brown fox jumps.&quot;, 2) == &quot;s.&quot;\n</code></pre>\n","name":"takeEnd","source":"/*\nReturns the given number of characters from the end of the string.\n\n  String.takeEnd(\"The quick brown fox jumps.\", 2) == \"s.\"\n*/\nfun takeEnd (string : String, length : Number) : String {\n  `#{string}.slice(#{string}.length - #{length})`\n}","arguments":[{"type":"String","name":"string"},{"type":"Number","name":"length"}]},{"type":"String","description":"<p>Returns the given number of characters from the start of the string.</p>\n<pre><code>String.takeStart(&quot;The quick brown fox jumps.&quot;, 2) == &quot;Th&quot;\n</code></pre>\n","name":"takeStart","source":"/*\nReturns the given number of characters from the start of the string.\n\n  String.takeStart(\"The quick brown fox jumps.\", 2) == \"Th\"\n*/\nfun takeStart (string : String, length : Number) : String {\n  `#{string}.slice(0, #{length})`\n}","arguments":[{"type":"String","name":"string"},{"type":"Number","name":"length"}]},{"type":"Array(String)","description":"<p>Convert the given string into an array of strings.</p>\n<pre><code>String.toArray(&quot;Hello&quot;) == [&quot;H&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;]\n</code></pre>\n","name":"toArray","source":"/*\nConvert the given string into an array of strings.\n\n  String.toArray(\"Hello\") == [\"H\", \"e\", \"l\", \"l\", \"o\"]\n*/\nfun toArray (string : String) : Array(String) {\n  split(string, \"\")\n}","arguments":[{"type":"String","name":"string"}]},{"type":"String","description":"<p>Converts the given string to lowercase.</p>\n<pre><code> String.toLowerCase(&quot;HELLO&quot;) == &quot;hello&quot;\n</code></pre>\n","name":"toLowerCase","source":"/*\nConverts the given string to lowercase.\n\n   String.toLowerCase(\"HELLO\") == \"hello\"\n*/\nfun toLowerCase (string : String) : String {\n  `#{string}.toLowerCase()`\n}","arguments":[{"type":"String","name":"string"}]},{"type":"String","description":"<p>Converts the given string to lowercase.</p>\n<pre><code> String.toUpperCase(&quot;hello&quot;) == &quot;HELLO&quot;\n</code></pre>\n","name":"toUpperCase","source":"/*\nConverts the given string to lowercase.\n\n   String.toUpperCase(\"hello\") == \"HELLO\"\n*/\nfun toUpperCase (string : String) : String {\n  `#{string}.toUpperCase()`\n}","arguments":[{"type":"String","name":"string"}]},{"type":"String","description":"<p>Removes whitespace from the beginning and end of the string.</p>\n<pre><code>String.trim(&quot;  The quick brown fox jumps.  &quot;) == &quot;The quick brown fox jumps.&quot;\n</code></pre>\n","name":"trim","source":"/*\nRemoves whitespace from the beginning and end of the string.\n\n  String.trim(\"  The quick brown fox jumps.  \") == \"The quick brown fox jumps.\"\n*/\nfun trim (value : String) : String {\n  `#{value}.trim()`\n}","arguments":[{"type":"String","name":"value"}]},{"type":"String","description":"<p>Returns the given string or the given default value if the string is empty.</p>\n<pre><code>String.withDefault(&quot;&quot;, &quot;The quick brown fox jumps.&quot;) == &quot;The quick brown fox jumps.&quot;\nString.withDefault(&quot;Hello&quot;, &quot;The quick brown fox jumps.&quot;) == &quot;Hello&quot;\n</code></pre>\n","name":"withDefault","source":"/*\nReturns the given string or the given default value if the string is empty.\n\n  String.withDefault(\"\", \"The quick brown fox jumps.\") == \"The quick brown fox jumps.\"\n  String.withDefault(\"Hello\", \"The quick brown fox jumps.\") == \"Hello\"\n*/\nfun withDefault (string : String, value : String) : String {\n  if String.isEmpty(string) {\n    value\n  } else {\n    string\n  }\n}","arguments":[{"type":"String","name":"string"},{"type":"String","name":"value"}]},{"type":"String","description":"<p>Wraps the string with the given start and end characters.</p>\n<pre><code>String.wrap(&quot;The quick brown fox jumps.&quot;, &quot;{&quot;,&quot;}&quot;) == &quot;{The quick brown fox jumps.}&quot;\n</code></pre>\n","name":"wrap","source":"/*\nWraps the string with the given start and end characters.\n\n  String.wrap(\"The quick brown fox jumps.\", \"{\",\"}\") == \"{The quick brown fox jumps.}\"\n*/\nfun wrap (string : String, start : String, end : String) : String {\n  \"#{start}#{string}#{end}\"\n}","arguments":[{"type":"String","name":"string"},{"type":"String","name":"start"},{"type":"String","name":"end"}]}]},{"description":null,"name":"Test.Context","functions":[{"type":"Test.Context(a)","description":"<p>Asserts the equality of the current value of the test with the given one.</p>\n<pre><code>test {\n  Test.Context.of(5)\n  |&gt; Test.Context.assertEqual(5)\n}\n</code></pre>\n","name":"assertEqual","source":"/*\nAsserts the equality of the current value of the test with the given one.\n\n  test {\n    Test.Context.of(5)\n    |> Test.Context.assertEqual(5)\n  }\n*/\nfun assertEqual (context : Test.Context(a), value : a) : Test.Context(a) {\n  `\n    #{context}.step((subject) => {\n      if (!_compare(#{value}, subject)) {\n        throw \\`Assertion failed: ${#{value}} === ${subject}\\`\n      }\n      return subject\n    })\n    `\n}","arguments":[{"type":"Test.Context(a)","name":"context"},{"type":"a","name":"value"}]},{"type":"Test.Context(c)","description":"<p>Asserts that a given spy (function) was called.</p>\n","name":"assertFunctionCalled","source":"/* Asserts that a given spy (function) was called. */\nfun assertFunctionCalled (context : Test.Context(c), entity : a) : Test.Context(c) {\n  `\n    #{context}.step((subject) => {\n      if (!#{entity}._called) {\n        throw \"The given function was not called!\"\n      }\n      return subject\n    })\n    `\n}","arguments":[{"type":"Test.Context(c)","name":"context"},{"type":"a","name":"entity"}]},{"type":"Test.Context(c)","description":"<p>Asserts that a given spy (function) was not called.</p>\n","name":"assertFunctionNotCalled","source":"/* Asserts that a given spy (function) was not called. */\nfun assertFunctionNotCalled (context : Test.Context(c), entity : a) : Test.Context(c) {\n  `\n    #{context}.step((subject) => {\n      if (#{entity}._called) {\n        throw \"The given function was called!\"\n      }\n      return subject\n    })\n    `\n}","arguments":[{"type":"Test.Context(c)","name":"context"},{"type":"a","name":"entity"}]},{"type":"Test.Context(a)","description":"<p>Asserts if the given value equals of the returned value from the given\nfunction.</p>\n<pre><code>test {\n  Test.Context.of(5)\n  |&gt; Test.Context.assertOf(&quot;5&quot;, Number.toString)\n}\n</code></pre>\n","name":"assertOf","source":"/*\nAsserts if the given value equals of the returned value from the given\nfunction.\n\n  test {\n    Test.Context.of(5)\n    |> Test.Context.assertOf(\"5\", Number.toString)\n  }\n*/\nfun assertOf (\n  context : Test.Context(a),\n  value : b,\n  method : Function(a, b)\n) : Test.Context(a) {\n  `\n    #{context}.step((subject) => {\n      const actual = #{method}(subject)\n\n      if (!_compare(#{value}, actual)) {\n        throw \\`Assertion failed: ${actual} === ${#{value}}\\`\n      }\n      return subject\n    })\n    `\n}","arguments":[{"type":"Test.Context(a)","name":"context"},{"type":"b","name":"value"},{"type":"Function(a, b)","name":"method"}]},{"type":"Test.Context(b)","description":"<p>Maps the given subject to a new subject.</p>\n<pre><code>test {\n  Test.Context.of(5)\n  |&gt; Test.Context.map(Number.toString)\n}\n</code></pre>\n","name":"map","source":"/*\nMaps the given subject to a new subject.\n\n  test {\n    Test.Context.of(5)\n    |> Test.Context.map(Number.toString)\n  }\n*/\nfun map (context : Test.Context(a), method : Function(a, b)) : Test.Context(b) {\n  then(context, (item : a) : Promise(b) { Promise.resolve(method(item)) })\n}","arguments":[{"type":"Test.Context(a)","name":"context"},{"type":"Function(a, b)","name":"method"}]},{"type":"Test.Context(a)","description":"<p>Starts a test using the given value.</p>\n<pre><code>test {\n  Test.Context.of(5)\n  |&gt; assertEqual(5)\n}\n</code></pre>\n","name":"of","source":"/*\nStarts a test using the given value.\n\n  test {\n    Test.Context.of(5)\n    |> assertEqual(5)\n  }\n*/\nfun of (a : a) : Test.Context(a) {\n  `new TestContext(#{a})`\n}","arguments":[{"type":"a","name":"a"}]},{"type":"a","description":"<p>Spies on the given entity if it's a function.</p>\n","name":"spyOn","source":"/* Spies on the given entity if it's a function. */\nfun spyOn (entity : a) : a {\n  `\n    (() => {\n      if (typeof #{entity} == \"function\") {\n        let _\n\n        _ = function (...args) {\n          _._called = true\n          return #{entity}(...args)\n        }\n\n        return _\n      } else {\n        return #{entity}\n      }\n    })()\n    `\n}","arguments":[{"type":"a","name":"entity"}]},{"type":"Test.Context(b)","description":"<p>Adds a transformation step to the test.</p>\n<pre><code>test {\n  Test.Context.of(5)\n  |&gt; Test.Context.then((number : Number) { Promise.resolve(number + 2) })\n  |&gt; Test.Context.assertEqual(7)\n}\n</code></pre>\n","name":"then","source":"/*\nAdds a transformation step to the test.\n\n  test {\n    Test.Context.of(5)\n    |> Test.Context.then((number : Number) { Promise.resolve(number + 2) })\n    |> Test.Context.assertEqual(7)\n  }\n*/\nfun then (\n  context : Test.Context(a),\n  proc : Function(a, Promise(b))\n) : Test.Context(b) {\n  `\n    #{context}.step((subject) => {\n      return #{proc}(subject)\n    })\n    `\n}","arguments":[{"type":"Test.Context(a)","name":"context"},{"type":"Function(a, Promise(b))","name":"proc"}]},{"type":"Test.Context(a)","description":"<p>Adds a timeout to the test using the given duration (in milliseconds).</p>\n<pre><code>test {\n  Test.Context.of(5)\n  |&gt; Test.Context.timeout(1000)\n  |&gt; Test.Context.assertEqual(5)\n}\n</code></pre>\n","name":"timeout","source":"/*\nAdds a timeout to the test using the given duration (in milliseconds).\n\n  test {\n    Test.Context.of(5)\n    |> Test.Context.timeout(1000)\n    |> Test.Context.assertEqual(5)\n  }\n*/\nfun timeout (context : Test.Context(a), duration : Number) : Test.Context(a) {\n  then(\n    context, \n    (subject : a) : Promise(a) {\n      await Timer.timeout(duration)\n      subject\n    })\n}","arguments":[{"type":"Test.Context(a)","name":"context"},{"type":"Number","name":"duration"}]}]},{"description":null,"name":"Test.Html","functions":[{"type":"Test.Context(Dom.Element)","description":"<p>Starts a test of an <code>Html</code> node.</p>\n<pre><code>Test.Html.start(&lt;div&gt;&lt;{ &quot;Content&quot; }&gt;&lt;/div&gt;)\n</code></pre>\n","name":"start","source":"/*\nStarts a test of an `Html` node.\n\n  Test.Html.start(<div><{ \"Content\" }></div>)\n*/\nfun start (node : Html) : Test.Context(Dom.Element) {\n  `\n    (() => {\n      const root = document.createElement(\"div\")\n      document.body.appendChild(root)\n      ReactDOM.render(#{node}, root)\n      return new TestContext(root, () => {\n        ReactDOM.unmountComponentAtNode(root)\n        document.body.removeChild(root)\n      })\n    })()\n    `\n}","arguments":[{"type":"Html","name":"node"}]},{"type":"Test.Context(Dom.Element)","description":null,"name":"find","source":"fun find (\n  context : Test.Context(Dom.Element),\n  selector : String\n) : Test.Context(Dom.Element) {\n  `\n    #{context}.step((element) => {\n      const subject = element.querySelector(#{selector})\n\n      if (!subject) {\n        throw \\`Could not find element with selector: ${#{selector}}\\`\n      }\n      return subject\n    })\n    `\n}","arguments":[{"type":"Test.Context(Dom.Element)","name":"context"},{"type":"String","name":"selector"}]},{"type":"Test.Context(Dom.Element)","description":null,"name":"findGlobally","source":"fun findGlobally (\n  context : Test.Context(Dom.Element),\n  selector : String\n) : Test.Context(Dom.Element) {\n  `\n    #{context}.step((element) => {\n      const subject = document.querySelector(#{selector})\n\n      if (!subject) {\n        throw \\`Could not find element with selector: ${#{selector}}\\`\n      }\n      return subject\n    })\n    `\n}","arguments":[{"type":"Test.Context(Dom.Element)","name":"context"},{"type":"String","name":"selector"}]},{"type":"Test.Context(Dom.Element)","description":null,"name":"assertTop","source":"fun assertTop (context : Test.Context(Dom.Element), top : Number) : Test.Context(Dom.Element) {\n  Test.Context.assertOf(\n    context, \n    top, \n    (element : Dom.Element) : Number { Dom.getDimensions(element).top })\n}","arguments":[{"type":"Test.Context(Dom.Element)","name":"context"},{"type":"Number","name":"top"}]},{"type":"Test.Context(Dom.Element)","description":null,"name":"assertLeft","source":"fun assertLeft (context : Test.Context(Dom.Element), left : Number) : Test.Context(Dom.Element) {\n  Test.Context.assertOf(\n    context, \n    left, \n    (element : Dom.Element) : Number { Dom.getDimensions(element).left })\n}","arguments":[{"type":"Test.Context(Dom.Element)","name":"context"},{"type":"Number","name":"left"}]},{"type":"Test.Context(Dom.Element)","description":null,"name":"assertHeight","source":"fun assertHeight (context : Test.Context(Dom.Element), height : Number) : Test.Context(Dom.Element) {\n  Test.Context.assertOf(\n    context, \n    height, \n    (element : Dom.Element) : Number { Dom.getDimensions(element).height })\n}","arguments":[{"type":"Test.Context(Dom.Element)","name":"context"},{"type":"Number","name":"height"}]},{"type":"Test.Context(Dom.Element)","description":null,"name":"assertWidth","source":"fun assertWidth (context : Test.Context(Dom.Element), width : Number) : Test.Context(Dom.Element) {\n  Test.Context.assertOf(\n    context, \n    width, \n    (element : Dom.Element) : Number { Dom.getDimensions(element).width })\n}","arguments":[{"type":"Test.Context(Dom.Element)","name":"context"},{"type":"Number","name":"width"}]},{"type":"Test.Context(Dom.Element)","description":"<p>Triggers a click event on the element that matches the given selector.</p>\n","name":"triggerClick","source":"/* Triggers a click event on the element that matches the given selector. */\nfun triggerClick (\n  context : Test.Context(Dom.Element),\n  selector : String\n) : Test.Context(Dom.Element) {\n  `\n    #{context}.step((element) => {\n      element.querySelector(#{selector}).click()\n      return element\n    })\n    `\n}","arguments":[{"type":"Test.Context(Dom.Element)","name":"context"},{"type":"String","name":"selector"}]},{"type":"Test.Context(Dom.Element)","description":"<p>Triggers a mouse down event on the element that matches the given selector.</p>\n","name":"triggerMouseDown","source":"/* Triggers a mouse down event on the element that matches the given selector. */\nfun triggerMouseDown (\n  context : Test.Context(Dom.Element),\n  selector : String\n) : Test.Context(Dom.Element) {\n  `\n    #{context}.step((element) => {\n      const event = document.createEvent(\"MouseEvents\")\n      event.initEvent(\"mousedown\", true, true)\n      element.querySelector(#{selector}).dispatchEvent(event)\n      return element\n    })\n    `\n}","arguments":[{"type":"Test.Context(Dom.Element)","name":"context"},{"type":"String","name":"selector"}]},{"type":"Test.Context(Dom.Element)","description":"<p>Triggers a mouse move event on the element that matches the given selector.</p>\n","name":"triggerMouseMove","source":"/* Triggers a mouse move event on the element that matches the given selector. */\nfun triggerMouseMove (\n  context : Test.Context(Dom.Element),\n  selector : String\n) : Test.Context(Dom.Element) {\n  `\n    #{context}.step((element) => {\n      const event = document.createEvent(\"MouseEvents\")\n      event.initEvent(\"mousemove\", true, true)\n      element.querySelector(#{selector}).dispatchEvent(event)\n      return element\n    })\n    `\n}","arguments":[{"type":"Test.Context(Dom.Element)","name":"context"},{"type":"String","name":"selector"}]},{"type":"Test.Context(Dom.Element)","description":"<p>Triggers a mouse up event on the element that matches the given selector.</p>\n","name":"triggerMouseUp","source":"/* Triggers a mouse up event on the element that matches the given selector. */\nfun triggerMouseUp (\n  context : Test.Context(Dom.Element),\n  selector : String\n) : Test.Context(Dom.Element) {\n  `\n    #{context}.step((element) => {\n      const event = document.createEvent(\"MouseEvents\")\n      event.initEvent(\"mouseup\", true, true)\n      element.querySelector(#{selector}).dispatchEvent(event)\n      return element\n    })\n    `\n}","arguments":[{"type":"Test.Context(Dom.Element)","name":"context"},{"type":"String","name":"selector"}]},{"type":"Test.Context(Dom.Element)","description":"<p>Triggers a keydown event with the specified key on the element that matches the given selector.</p>\n","name":"triggerKeyDown","source":"/* Triggers a keydown event with the specified key on the element that matches the given selector. */\nfun triggerKeyDown (\n  context : Test.Context(Dom.Element),\n  selector : String,\n  key : String\n) : Test.Context(Dom.Element) {\n  `\n    #{context}.step((element) => {\n      const event = new KeyboardEvent('keydown', { key: #{key} });\n      element.querySelector(#{selector}).dispatchEvent(event)\n      return element\n    })\n    `\n}","arguments":[{"type":"Test.Context(Dom.Element)","name":"context"},{"type":"String","name":"selector"},{"type":"String","name":"key"}]},{"type":"Test.Context(Dom.Element)","description":"<p>Triggers a keyup event with the specified key on the element that matches the given selector.</p>\n","name":"triggerKeyUp","source":"/* Triggers a keyup event with the specified key on the element that matches the given selector. */\nfun triggerKeyUp (\n  context : Test.Context(Dom.Element),\n  selector : String,\n  key : String\n) : Test.Context(Dom.Element) {\n  `\n    #{context}.step((element) => {\n      const event = new KeyboardEvent('keyup', { key: #{key} });\n      element.querySelector(#{selector}).dispatchEvent(event)\n      return element\n    })\n    `\n}","arguments":[{"type":"Test.Context(Dom.Element)","name":"context"},{"type":"String","name":"selector"},{"type":"String","name":"key"}]},{"type":"Test.Context(Dom.Element)","description":"<p>Asserts the text of the element that matches the given selector.</p>\n","name":"assertTextOf","source":"/* Asserts the text of the element that matches the given selector. */\nfun assertTextOf (\n  context : Test.Context(Dom.Element),\n  selector : String,\n  value : String\n) : Test.Context(Dom.Element) {\n  `\n    #{context}.step((element) => {\n      let text\n\n      try {\n        text = element.querySelector(#{selector}).textContent\n      } catch (error) {\n        throw \\`Could not find element with selector: ${#{selector}}\\`\n      }\n\n      if (!(text == #{value})) {\n        throw \\`Assertion failed: ${text} === ${#{value}}\\`\n      }\n      return element\n    })\n    `\n}","arguments":[{"type":"Test.Context(Dom.Element)","name":"context"},{"type":"String","name":"selector"},{"type":"String","name":"value"}]},{"type":"Test.Context(Dom.Element)","description":null,"name":"assertActiveElement","source":"fun assertActiveElement (\n  context : Test.Context(Dom.Element),\n  selector : String\n) : Test.Context(Dom.Element) {\n  `\n    #{context}.step((element) => {\n      const subject = element.querySelector(#{selector})\n\n      if (!subject) {\n        throw \\`Could not find element with selector: ${#{selector}}\\`\n      }\n      if (subject != document.activeElement) {\n        throw \\`Element is not active\\`\n      }\n      return subject\n    })\n    `\n}","arguments":[{"type":"Test.Context(Dom.Element)","name":"context"},{"type":"String","name":"selector"}]},{"type":"Test.Context(Dom.Element)","description":"<p>Asserts that there is an element that matches the given selector.</p>\n","name":"assertElementExists","source":"/* Asserts that there is an element that matches the given selector. */\nfun assertElementExists (\n  context : Test.Context(Dom.Element),\n  selector : String\n) : Test.Context(Dom.Element) {\n  `\n    #{context}.step((element) => {\n      const subject = element.querySelector(#{selector})\n\n      if (!subject) {\n        throw \\`Could not find element with selector: ${#{selector}}\\`\n      }\n      return element\n    })\n    `\n}","arguments":[{"type":"Test.Context(Dom.Element)","name":"context"},{"type":"String","name":"selector"}]},{"type":"Test.Context(Dom.Element)","description":"<p>Asserts the value of a CSS property on the element that matches the given selector.</p>\n","name":"assertCssOf","source":"/* Asserts the value of a CSS property on the element that matches the given selector. */\nfun assertCssOf (\n  context : Test.Context(Dom.Element),\n  selector : String,\n  property : String,\n  value : String\n) : Test.Context(Dom.Element) {\n  `\n    #{context}.step((element) => {\n      const subject = element.querySelector(#{selector})\n\n      if (!subject) {\n        throw \\`Could not find element with selector: ${#{selector}}\\`\n      }\n\n      const actual = getComputedStyle(subject)[#{property}]\n\n      if (!(actual == #{value})) {\n        throw \\`Assertion failed: ${actual} === ${#{value}}\\`\n      }\n      return element\n    })\n    `\n}","arguments":[{"type":"Test.Context(Dom.Element)","name":"context"},{"type":"String","name":"selector"},{"type":"String","name":"property"},{"type":"String","name":"value"}]}]},{"description":null,"name":"Test.Window","functions":[{"type":"Test.Context(a)","description":"<p>Sets the horizontal scroll position of the window during a test.</p>\n","name":"setScrollLeft","source":"/* Sets the horizontal scroll position of the window during a test. */\nfun setScrollLeft (context : Test.Context(a), to : Number) : Test.Context(a) {\n  Test.Context.then(\n    context, \n    (subject : Dom.Element) : Promise(a) {\n      Window.setScrollLeft(100)\n      Promise.resolve(subject)\n    })\n}","arguments":[{"type":"Test.Context(a)","name":"context"},{"type":"Number","name":"to"}]},{"type":"Test.Context(a)","description":"<p>Sets the vertical scroll position of the window during a test.</p>\n","name":"setScrollTop","source":"/* Sets the vertical scroll position of the window during a test. */\nfun setScrollTop (context : Test.Context(a), to : Number) : Test.Context(a) {\n  Test.Context.then(\n    context, \n    (subject : Dom.Element) : Promise(a) {\n      Window.setScrollTop(100)\n      Promise.resolve(subject)\n    })\n}","arguments":[{"type":"Test.Context(a)","name":"context"},{"type":"Number","name":"to"}]}]},{"description":null,"name":"Time","functions":[{"type":"Maybe(Time)","description":"<p>Tries to parse the given string as an ISO date.</p>\n<pre><code>Time.parseISO(&quot;2018-04-05T00:00:00.000Z&quot;)\n</code></pre>\n","name":"parseISO","source":"/*\nTries to parse the given string as an ISO date.\n\n  Time.parseISO(\"2018-04-05T00:00:00.000Z\")\n*/\nfun parseISO (raw : String) : Maybe(Time) {\n  `\n    (() => {\n      try {\n        return #{Maybe::Just(`new Date(#{raw})`)}\n      } catch (error) {\n        return #{Maybe::Nothing}\n      }\n    })()\n    `\n}","arguments":[{"type":"String","name":"raw"}]},{"type":"Number","description":"<p>Returns the UNIX Timestamp (in milliseconds) of the given time.</p>\n<pre><code>Time.toUnix(Time.utcDate(2006, 1, 2)) == 1136160000000\n</code></pre>\n","name":"toUnix","source":"/*\nReturns the UNIX Timestamp (in milliseconds) of the given time.\n\n  Time.toUnix(Time.utcDate(2006, 1, 2)) == 1136160000000\n*/\nfun toUnix (time : Time) : Number {\n  `#{time}.getTime()`\n}","arguments":[{"type":"Time","name":"time"}]},{"type":"Time","description":"<p>Returns the time respective to the given UNIX Timestamp (in milliseconds).</p>\n<pre><code>Time.unix(1136160000000) == Time.utcDate(2006, 1, 2)\n</code></pre>\n","name":"unix","source":"/*\nReturns the time respective to the given UNIX Timestamp (in milliseconds).\n\n  Time.unix(1136160000000) == Time.utcDate(2006, 1, 2)\n*/\nfun unix (timestamp : Number) : Time {\n  `new Date(#{timestamp})`\n}","arguments":[{"type":"Number","name":"timestamp"}]},{"type":"Time","description":"<p>Returns a new time from the given parameters.</p>\n<pre><code>Time.utc(2018, 4, 5, 12, 24, 50, 100)\n</code></pre>\n","name":"utc","source":"/*\nReturns a new time from the given parameters.\n\n  Time.utc(2018, 4, 5, 12, 24, 50, 100)\n*/\nfun utc (\n  year : Number,\n  month : Number,\n  day : Number,\n  hour : Number,\n  minute : Number,\n  second : Number,\n  millisecond : Number\n) : Time {\n  `new Date(Date.UTC(#{year}, #{month} - 1, #{day}, #{hour}, #{minute}, #{second}, #{millisecond}))`\n}","arguments":[{"type":"Number","name":"year"},{"type":"Number","name":"month"},{"type":"Number","name":"day"},{"type":"Number","name":"hour"},{"type":"Number","name":"minute"},{"type":"Number","name":"second"},{"type":"Number","name":"millisecond"}]},{"type":"Time","description":"<p>Returns a new time from the given parameters (without time parts).</p>\n<pre><code>Time.utcDate(2018, 4, 5)\n</code></pre>\n","name":"utcDate","source":"/*\nReturns a new time from the given parameters (without time parts).\n\n  Time.utcDate(2018, 4, 5)\n*/\nfun utcDate (year : Number, month : Number, day : Number) : Time {\n  `new Date(Date.UTC(#{year}, #{month} - 1, #{day}))`\n}","arguments":[{"type":"Number","name":"year"},{"type":"Number","name":"month"},{"type":"Number","name":"day"}]},{"type":"Time","description":"<p>Returns the current time (in UTC).</p>\n<pre><code>Time.now()\n</code></pre>\n","name":"now","source":"/*\nReturns the current time (in UTC).\n\n  Time.now()\n*/\nfun now : Time {\n  `new Date()`\n}","arguments":[]},{"type":"Time","description":"<p>Returns the current time (offset by the clients time zone).</p>\n<pre><code>Time.local()\n</code></pre>\n","name":"local","source":"/*\nReturns the current time (offset by the clients time zone).\n\n  Time.local()\n*/\nfun local : Time {\n  let time =\n    now()\n\n  shift(time, Time.Span.Minutes(`-#{time}.getTimezoneOffset()`))\n}","arguments":[]},{"type":"Time","description":"<p>Returns the time at the begging of today.</p>\n<pre><code>Time.today()\n</code></pre>\n","name":"today","source":"/*\nReturns the time at the begging of today.\n\n  Time.today()\n*/\nfun today : Time {\n  atBeginningOfDay(now())\n}","arguments":[]},{"type":"Time","description":"<p>Returns the time at the begging of tomorrow.</p>\n<pre><code>Time.tomorrow()\n</code></pre>\n","name":"tomorrow","source":"/*\nReturns the time at the begging of tomorrow.\n\n  Time.tomorrow()\n*/\nfun tomorrow : Time {\n  nextDay(today())\n}","arguments":[]},{"type":"Time","description":"<p>Returns the time at the begging of yesterday.</p>\n<pre><code>Time.yesterday()\n</code></pre>\n","name":"yesterday","source":"/*\nReturns the time at the begging of yesterday.\n\n  Time.yesterday()\n*/\nfun yesterday : Time {\n  previousDay(today())\n}","arguments":[]},{"type":"Number","description":"<p>Returns the year of the given time.</p>\n<pre><code>Time.year(Time.utcDate(2018, 4, 5)) == 2018\n</code></pre>\n","name":"year","source":"/*\nReturns the year of the given time.\n\n  Time.year(Time.utcDate(2018, 4, 5)) == 2018\n*/\nfun year (time : Time) : Number {\n  `#{time}.getUTCFullYear()`\n}","arguments":[{"type":"Time","name":"time"}]},{"type":"Number","description":"<p>Returns the quarter of the year in which the given time occurs.</p>\n<pre><code>Time.quarterOfYear(Time.utcDate(2018, 4, 5)) == 1\n</code></pre>\n","name":"quarterOfYear","source":"/*\nReturns the quarter of the year in which the given time occurs.\n\n  Time.quarterOfYear(Time.utcDate(2018, 4, 5)) == 1\n*/\nfun quarterOfYear (time : Time) : Number {\n  `Math.trunc(#{monthNumber(time)} / 4)`\n}","arguments":[{"type":"Time","name":"time"}]},{"type":"Number","description":"<p>Returns the month of the given time (as a number).</p>\n<pre><code>Time.monthNumber(Time.utcDate(2018, 4, 5)) == 4\n</code></pre>\n","name":"monthNumber","source":"/*\nReturns the month of the given time (as a number).\n\n  Time.monthNumber(Time.utcDate(2018, 4, 5)) == 4\n*/\nfun monthNumber (time : Time) : Number {\n  `#{time}.getUTCMonth() + 1`\n}","arguments":[{"type":"Time","name":"time"}]},{"type":"Month","description":"<p>Returns the month of the given time (as a <code>Month</code>).</p>\n<pre><code>Time.month(Time.utcDate(2018, 4, 5)) == Month::April\n</code></pre>\n","name":"month","source":"/*\nReturns the month of the given time (as a `Month`).\n\n  Time.month(Time.utcDate(2018, 4, 5)) == Month::April\n*/\nfun month (time : Time) : Month {\n  case monthNumber(time) {\n    1 => Month.January\n    2 => Month.February\n    3 => Month.March\n    4 => Month.April\n    5 => Month.May\n    6 => Month.June\n    7 => Month.July\n    8 => Month.August\n    9 => Month.September\n    10 => Month.October\n    11 => Month.November\n    => Month.December\n  }\n}","arguments":[{"type":"Time","name":"time"}]},{"type":"Tuple(Number, Number)","description":"<p>Returns the ISO calendar year and week of the given time.</p>\n<p>The ISO calendar year to which the week belongs is not always in the same\nas the year of the regular calendar date. The first three days of January\nsometimes belong to week 52 (or 53) of the previous year; equally the last\nthree days of December sometimes are already in week 1 of the following year.</p>\n<p>For that reason, this method returns a tuple <code>year, week</code> consisting of the\ncalendar year to which the calendar week belongs and the ordinal number of\nthe week within that year.</p>\n<pre><code>Time.calendarWeek(Time.utcDate(2016, 1, 1)) == {2016, 53}\n</code></pre>\n","name":"calendarWeek","source":"/*\nReturns the ISO calendar year and week of the given time.\n\nThe ISO calendar year to which the week belongs is not always in the same\nas the year of the regular calendar date. The first three days of January\nsometimes belong to week 52 (or 53) of the previous year; equally the last\nthree days of December sometimes are already in week 1 of the following year.\n\nFor that reason, this method returns a tuple `year, week` consisting of the\ncalendar year to which the calendar week belongs and the ordinal number of\nthe week within that year.\n\n  Time.calendarWeek(Time.utcDate(2016, 1, 1)) == {2016, 53}\n*/\nfun calendarWeek (time : Time) : Tuple(Number, Number) {\n  `\n    (() => {\n      let year =\n        #{time}.getUTCFullYear();\n\n      const day =\n        #{time}.getUTCDate();\n\n      const dayYear =\n        #{dayOfYear(time)};\n\n      const dayWeek =\n        #{dayOfWeekNumber(time)};\n\n      // The week number can be calculated as number of Mondays in the year up to the ordinal date.\n      // The addition by +10 consists of +7 to start the week numbering with 1\n      // instead of 0 and +3 because the first week has already started in the\n      // previous year and the first Monday is actually in week 2.\n      let weekNumber = Math.trunc((dayYear - dayWeek + 10) / 7);\n\n      if (weekNumber == 0) {\n        // Week number 0 means the date belongs to the last week of the previous year.\n        year -= 1;\n\n        // The week number depends on whether the previous year has 52 or 53 weeks\n        // which can be determined by the day of week of January 1.\n        // The year has 53 weeks if January 1 is on a Friday or the year was a leap\n        // year and January 1 is on a Saturday.\n        const janFirstDayOfWeek = (dayWeek - dayYear + 1) % 7;\n        const isLeapYear = #{isNumberLeapYear(`year`)};\n\n        if (janFirstDayOfWeek == 5 || (janFirstDayOfWeek == 6 && isLeapYear)) {\n          weekNumber = 53;\n        } else {\n          weekNumber = 52;\n        }\n      } else if (weekNumber == 53) {\n        // Week number 53 is actually week number 1 of the following year, if\n        // December 31 is on a Monday, Tuesday or Wednesday.\n        const dec31DayOfWeek = (dayWeek + 31 - day) % 7;\n\n        if (dec31DayOfWeek <= 3) {\n          weekNumber = 1;\n          year += 1;\n        }\n      }\n\n      return [year, weekNumber];\n    })()\n    `\n}","arguments":[{"type":"Time","name":"time"}]},{"type":"Number","description":"<p>Returns the day of the week of the given time (as a number from 1 to 7).</p>\n<pre><code>Time.dayOfWeekNumber(Time.utcDate(2018, 4, 5)) == 4\n</code></pre>\n","name":"dayOfWeekNumber","source":"/*\nReturns the day of the week of the given time (as a number from 1 to 7).\n\n  Time.dayOfWeekNumber(Time.utcDate(2018, 4, 5)) == 4\n*/\nfun dayOfWeekNumber (time : Time) : Number {\n  `\n    (() => {\n      const dayNumber = #{time}.getUTCDay()\n      return dayNumber === 0 ? 7 : dayNumber;\n    })()\n    `\n}","arguments":[{"type":"Time","name":"time"}]},{"type":"Weekday","description":"<p>Returns the day of week of the given time.</p>\n<pre><code>Time.dayOfWeek(Time.utcDate(2018, 4, 5)) == Weekday::Thursday\n</code></pre>\n","name":"dayOfWeek","source":"/*\nReturns the day of week of the given time.\n\n  Time.dayOfWeek(Time.utcDate(2018, 4, 5)) == Weekday::Thursday\n*/\nfun dayOfWeek (time : Time) : Weekday {\n  case dayOfWeekNumber(time) {\n    1 => Weekday.Monday\n    2 => Weekday.Tuesday\n    3 => Weekday.Wednesday\n    4 => Weekday.Thursday\n    5 => Weekday.Friday\n    6 => Weekday.Saturday\n    => Weekday.Sunday\n  }\n}","arguments":[{"type":"Time","name":"time"}]},{"type":"Number","description":"<p>Returns the day of month of the given time.</p>\n<pre><code>Time.dayOfMonth(Time.utcDate(2018, 4, 5)) == 5\n</code></pre>\n","name":"dayOfMonth","source":"/*\nReturns the day of month of the given time.\n\n  Time.dayOfMonth(Time.utcDate(2018, 4, 5)) == 5\n*/\nfun dayOfMonth (time : Time) : Number {\n  `#{time}.getUTCDate()`\n}","arguments":[{"type":"Time","name":"time"}]},{"type":"Number","description":"<p>Returns the day of the year of the given time.</p>\n<pre><code>Time.dayOfYear(Time.utcDate(2018, 4, 5)) == 95\n</code></pre>\n","name":"dayOfYear","source":"/*\nReturns the day of the year of the given time.\n\n  Time.dayOfYear(Time.utcDate(2018, 4, 5)) == 95\n*/\nfun dayOfYear (time : Time) : Number {\n  `\n    (() => {\n      const first =\n        Date.UTC(#{time}.getUTCFullYear(), 0, 1)\n\n      const current =\n        Date.UTC(#{time}.getUTCFullYear(), #{time}.getUTCMonth(), #{time}.getUTCDate())\n\n      return ((current - first) / 24 / 60 / 60 / 1000) + 1\n    })()\n    `\n}","arguments":[{"type":"Time","name":"time"}]},{"type":"Number","description":"<p>Returns the hour of the given time.</p>\n<pre><code>Time.hour(Time.utc(2018, 4, 5, 10, 25, 30, 40) == 10\n</code></pre>\n","name":"hour","source":"/*\nReturns the hour of the given time.\n\n  Time.hour(Time.utc(2018, 4, 5, 10, 25, 30, 40) == 10\n*/\nfun hour (time : Time) : Number {\n  `#{time}.getUTCHours()`\n}","arguments":[{"type":"Time","name":"time"}]},{"type":"Number","description":"<p>Returns the minute of the given time.</p>\n<pre><code>Time.minute(Time.utc(2018, 4, 5, 10, 25, 30, 40)) == 25\n</code></pre>\n","name":"minute","source":"/*\nReturns the minute of the given time.\n\n  Time.minute(Time.utc(2018, 4, 5, 10, 25, 30, 40)) == 25\n*/\nfun minute (time : Time) : Number {\n  `#{time}.getUTCMinutes()`\n}","arguments":[{"type":"Time","name":"time"}]},{"type":"Number","description":"<p>Returns the second of the given time.</p>\n<pre><code>Time.second(Time.utc(2018, 4, 5, 10, 25, 30, 40)) == 30\n</code></pre>\n","name":"second","source":"/*\nReturns the second of the given time.\n\n  Time.second(Time.utc(2018, 4, 5, 10, 25, 30, 40)) == 30\n*/\nfun second (time : Time) : Number {\n  `#{time}.getUTCSeconds()`\n}","arguments":[{"type":"Time","name":"time"}]},{"type":"Number","description":"<p>Returns the millisecond of the given time.</p>\n<pre><code>Time.millisecond(Time.utc(2018, 4, 5, 10, 25, 30, 40)) == 40\n</code></pre>\n","name":"millisecond","source":"/*\nReturns the millisecond of the given time.\n\n  Time.millisecond(Time.utc(2018, 4, 5, 10, 25, 30, 40)) == 40\n*/\nfun millisecond (time : Time) : Number {\n  `#{time}.getUTCMilliseconds()`\n}","arguments":[{"type":"Time","name":"time"}]},{"type":"Bool","description":"<p>Returns if the year of the given time is a leap year or not.</p>\n<pre><code>Time.isLeapYear(Time.utcDate(2011,1,1)) == false\nTime.isLeapYear(Time.utcDate(2012,1,1)) == true\n</code></pre>\n","name":"isLeapYear","source":"/*\nReturns if the year of the given time is a leap year or not.\n\n  Time.isLeapYear(Time.utcDate(2011,1,1)) == false\n  Time.isLeapYear(Time.utcDate(2012,1,1)) == true\n*/\nfun isLeapYear (time : Time) : Bool {\n  isNumberLeapYear(year(time))\n}","arguments":[{"type":"Time","name":"time"}]},{"type":"Bool","description":"<p>Returns if the given number (year) is a leap year or not.</p>\n<pre><code>Time.isNumberLeapYear(2020) == true\nTime.isNumberLeapYear(2021) == false\n</code></pre>\n","name":"isNumberLeapYear","source":"/*\nReturns if the given number (year) is a leap year or not.\n\n  Time.isNumberLeapYear(2020) == true\n  Time.isNumberLeapYear(2021) == false\n*/\nfun isNumberLeapYear (year : Number) : Bool {\n  (year % 4 == 0) && (year % 100 != 0 || year % 400 == 0)\n}","arguments":[{"type":"Number","name":"year"}]},{"type":"Time","description":"<p>Shifts the given time using the given time span.</p>\n<pre><code>Time.shift(Time.utcDate(2018, 4, 5), Time.Span::Days(2)) ==\n  Time.utcDate(2018, 4, 7)\n</code></pre>\n","name":"shift","source":"/*\nShifts the given time using the given time span.\n\n  Time.shift(Time.utcDate(2018, 4, 5), Time.Span::Days(2)) ==\n    Time.utcDate(2018, 4, 7)\n*/\nfun shift (time : Time, delta : Time.Span) : Time {\n  `\n    (() => {\n      const time = new Date(+#{time});\n\n      #{\n        case (delta) {\n          Time.Span::Milliseconds(amount) =>\n            `time.setUTCMilliseconds(time.getUTCMilliseconds() + #{amount})`\n\n          Time.Span::Seconds(amount) =>\n            `time.setUTCSeconds(time.getUTCSeconds() + #{amount})`\n\n          Time.Span::Minutes(amount)      =>\n            `time.setUTCMinutes(time.getUTCMinutes() + #{amount})`\n\n          Time.Span::Hours(amount)        =>\n            `time.setUTCHours(time.getUTCHours() + #{amount})`\n\n          Time.Span::Days(amount)         =>\n            `time.setUTCDate(time.getUTCDate() + #{amount})`\n\n          Time.Span::Weeks(amount)        =>\n            `time.setUTCDate(time.getUTCDate() + (7 * #{amount}))`\n\n          Time.Span::Months(amount)       =>\n            `time.setUTCMonth(time.getUTCMonth() + #{amount})`\n\n          Time.Span::Years(amount)        =>\n            `time.setUTCFullYear(time.getUTCFullYear() + #{amount})`\n        }\n      }\n\n      return time;\n    })()\n    `\n}","arguments":[{"type":"Time","name":"time"},{"type":"Time.Span","name":"delta"}]},{"type":"Time","description":"<p>Returns a new time which is at the beginning of the same year\nas the given time.</p>\n<pre><code>Time.atBeginningOfYear(Time.utcDate(2017, 5, 20)) == Time.utcDate(2017, 1, 1)\n</code></pre>\n","name":"atBeginningOfYear","source":"/*\nReturns a new time which is at the beginning of the same year\nas the given time.\n\n  Time.atBeginningOfYear(Time.utcDate(2017, 5, 20)) == Time.utcDate(2017, 1, 1)\n*/\nfun atBeginningOfYear (time : Time) : Time {\n  `\n    (() => {\n      const time = new Date(+#{time});\n      time.setUTCMonth(0, 1);\n      time.setUTCHours(0, 0, 0, 0);\n      return time;\n    })()\n    `\n}","arguments":[{"type":"Time","name":"time"}]},{"type":"Time","description":"<p>Returns a new time which is at the beginning of the same month\nas the given time.</p>\n<pre><code>Time.atBeginningOfMonth(Time.utcDate(2017, 5, 20)) == Time.utcDate(2017, 5, 1)\n</code></pre>\n","name":"atBeginningOfMonth","source":"/*\nReturns a new time which is at the beginning of the same month\nas the given time.\n\n  Time.atBeginningOfMonth(Time.utcDate(2017, 5, 20)) == Time.utcDate(2017, 5, 1)\n*/\nfun atBeginningOfMonth (time : Time) : Time {\n  `\n    (() => {\n      const time = new Date(+#{time});\n      time.setUTCDate(1);\n      time.setUTCHours(0, 0, 0, 0);\n      return time;\n    })()\n    `\n}","arguments":[{"type":"Time","name":"time"}]},{"type":"Time","description":"<p>Returns a new time which is at the beginning of the same week\nas the given time.</p>\n<pre><code>Time.atBeginningOfWeek(Time.utcDate(2017, 5, 20)) == Time.utcDate(2017, 5, 15)\n</code></pre>\n","name":"atBeginningOfWeek","source":"/*\nReturns a new time which is at the beginning of the same week\nas the given time.\n\n  Time.atBeginningOfWeek(Time.utcDate(2017, 5, 20)) == Time.utcDate(2017, 5, 15)\n*/\nfun atBeginningOfWeek (time : Time) : Time {\n  let day =\n    dayOfWeekNumber(time)\n\n  shift(time, Time.Span.Days(-(day - 1)))\n}","arguments":[{"type":"Time","name":"time"}]},{"type":"Time","description":"<p>Returns a new time which is at the beginning of the same day\nas the given time.</p>\n<pre><code>Time.atBeginningOfDay(Time.utc(2017, 5, 20, 10, 34, 22, 40)) ==\n  Time.utc(2017, 5, 20, 0, 0, 0, 0)\n</code></pre>\n","name":"atBeginningOfDay","source":"/*\nReturns a new time which is at the beginning of the same day\nas the given time.\n\n  Time.atBeginningOfDay(Time.utc(2017, 5, 20, 10, 34, 22, 40)) ==\n    Time.utc(2017, 5, 20, 0, 0, 0, 0)\n*/\nfun atBeginningOfDay (time : Time) : Time {\n  `\n    (() => {\n      const time = new Date(+#{time});\n      time.setUTCHours(0, 0, 0, 0);\n      return time;\n    })()\n    `\n}","arguments":[{"type":"Time","name":"time"}]},{"type":"Time","description":"<p>Returns a new time which is at the end of the same year\nas the given time.</p>\n<pre><code>Time.atEndOfYear(Time.utcDate(2017, 5, 20)) == Time.utcDate(2017, 12, 31)\n</code></pre>\n","name":"atEndOfYear","source":"/*\nReturns a new time which is at the end of the same year\nas the given time.\n\n  Time.atEndOfYear(Time.utcDate(2017, 5, 20)) == Time.utcDate(2017, 12, 31)\n*/\nfun atEndOfYear (time : Time) : Time {\n  `\n    (() => {\n      const time = new Date(+#{time});\n      time.setUTCMonth(12, 1);         // Set it to next January 1st\n      time.setUTCHours(0, 0, 0, -1);   // Subtract 1 millisecond\n      return time;\n    })()\n    `\n}","arguments":[{"type":"Time","name":"time"}]},{"type":"Time","description":"<p>Returns a new time which is at the end of the same month\nas the given time.</p>\n<pre><code>Time.atEndOfMonth(Time.utcDate(2017, 5, 20)) == Time.utcDate(2017, 5, 31)\n</code></pre>\n","name":"atEndOfMonth","source":"/*\nReturns a new time which is at the end of the same month\nas the given time.\n\n  Time.atEndOfMonth(Time.utcDate(2017, 5, 20)) == Time.utcDate(2017, 5, 31)\n*/\nfun atEndOfMonth (time : Time) : Time {\n  `\n    (() => {\n      const time = new Date(+#{time});\n      const month = time.getUTCMonth();\n      time.setUTCMonth(month + 1, 1);   // Set it to 1st of the next month\n      time.setUTCHours(0, 0, 0, -1);    // Subtract 1 millisecond\n      return time;\n    })()\n    `\n}","arguments":[{"type":"Time","name":"time"}]},{"type":"Time","description":"<p>Returns a new time which is at the beginning of the same week\nas the given time.</p>\n<pre><code>Time.atEndOfWeek(Time.utcDate(2017, 5, 20)) == Time.utcDate(2017, 5, 1)\n</code></pre>\n","name":"atEndOfWeek","source":"/*\nReturns a new time which is at the beginning of the same week\nas the given time.\n\n  Time.atEndOfWeek(Time.utcDate(2017, 5, 20)) == Time.utcDate(2017, 5, 1)\n*/\nfun atEndOfWeek (time : Time) : Time {\n  time\n  |> shift(Time.Span.Days(7 - dayOfWeekNumber(time)))\n  |> atEndOfDay\n}","arguments":[{"type":"Time","name":"time"}]},{"type":"Time","description":"<p>Returns a new time which is at the beginning of the same day\nas the given time.</p>\n<pre><code>Time.atEndOfDay(Time.utc(2017, 5, 20, 10, 34, 22, 40)) ==\n  Time.utc(2017, 5, 20, 0, 0, 0, 0)\n</code></pre>\n","name":"atEndOfDay","source":"/*\nReturns a new time which is at the beginning of the same day\nas the given time.\n\n  Time.atEndOfDay(Time.utc(2017, 5, 20, 10, 34, 22, 40)) ==\n    Time.utc(2017, 5, 20, 0, 0, 0, 0)\n*/\nfun atEndOfDay (time : Time) : Time {\n  `\n    (() => {\n      const time = new Date(+#{time});\n      const date = time.getUTCDate();\n      time.setUTCDate(date + 1);      // Set it to the beginning of the next day\n      time.setUTCHours(0, 0, 0, -1);  // Subtract 1 millisecond\n      return time;\n    })()\n    `\n}","arguments":[{"type":"Time","name":"time"}]},{"type":"Time","description":"<p>Returns a new time which is a month later than the the given time.</p>\n<pre><code>Time.nextMonth(Time.utcDate(2017, 5, 20)) == Time.utcDate(2017, 6, 20)\n</code></pre>\n","name":"nextMonth","source":"/*\nReturns a new time which is a month later than the the given time.\n\n  Time.nextMonth(Time.utcDate(2017, 5, 20)) == Time.utcDate(2017, 6, 20)\n*/\nfun nextMonth (time : Time) : Time {\n  shift(time, Time.Span.Months(1))\n}","arguments":[{"type":"Time","name":"time"}]},{"type":"Time","description":"<p>Returns a new time which is a month sooner than the the given time.</p>\n<pre><code>Time.previousMonth(Time.utcDate(2017, 5, 20)) == Time.utcDate(2017, 4, 20)\n</code></pre>\n","name":"previousMonth","source":"/*\nReturns a new time which is a month sooner than the the given time.\n\n  Time.previousMonth(Time.utcDate(2017, 5, 20)) == Time.utcDate(2017, 4, 20)\n*/\nfun previousMonth (time : Time) : Time {\n  shift(time, Time.Span.Months(-1))\n}","arguments":[{"type":"Time","name":"time"}]},{"type":"Time","description":"<p>Returns a new time which is a week later than the the given time.</p>\n<pre><code>Time.nextWeek(Time.utcDate(2017, 5, 10)) == Time.utcDate(2017, 5, 17)\n</code></pre>\n","name":"nextWeek","source":"/*\nReturns a new time which is a week later than the the given time.\n\n  Time.nextWeek(Time.utcDate(2017, 5, 10)) == Time.utcDate(2017, 5, 17)\n*/\nfun nextWeek (time : Time) : Time {\n  shift(time, Time.Span.Weeks(1))\n}","arguments":[{"type":"Time","name":"time"}]},{"type":"Time","description":"<p>Returns a new time which is a week sooner than the the given time.</p>\n<pre><code>Time.previousWeek(Time.utcDate(2017, 5, 20)) == Time.utcDate(2017, 5, 13)\n</code></pre>\n","name":"previousWeek","source":"/*\nReturns a new time which is a week sooner than the the given time.\n\n  Time.previousWeek(Time.utcDate(2017, 5, 20)) == Time.utcDate(2017, 5, 13)\n*/\nfun previousWeek (time : Time) : Time {\n  shift(time, Time.Span.Weeks(-1))\n}","arguments":[{"type":"Time","name":"time"}]},{"type":"Time","description":"<p>Returns a new time which is a day later than the the given time.</p>\n<pre><code>Time.nextDay(Time.utcDate(2017, 5, 20)) == Time.utcDate(2017, 5, 21)\n</code></pre>\n","name":"nextDay","source":"/*\nReturns a new time which is a day later than the the given time.\n\n  Time.nextDay(Time.utcDate(2017, 5, 20)) == Time.utcDate(2017, 5, 21)\n*/\nfun nextDay (time : Time) : Time {\n  shift(time, Time.Span.Days(1))\n}","arguments":[{"type":"Time","name":"time"}]},{"type":"Time","description":"<p>Returns a new time which is a day sooner than the the given time.</p>\n<pre><code>Time.previousDay(Time.utcDate(2017, 5, 20)) == Time.utcDate(2017, 5, 19)\n</code></pre>\n","name":"previousDay","source":"/*\nReturns a new time which is a day sooner than the the given time.\n\n  Time.previousDay(Time.utcDate(2017, 5, 20)) == Time.utcDate(2017, 5, 19)\n*/\nfun previousDay (time : Time) : Time {\n  shift(time, Time.Span.Days(-1))\n}","arguments":[{"type":"Time","name":"time"}]},{"type":"Array(Time)","description":"<p>Returns an array of days from the given start to given end time (inclusive).</p>\n<pre><code>Time.range(Time.utcDate(2006, 4, 1), Time.utcDate(2006, 4, 4)) == [\n  Time.utcDate(2006, 4, 1),\n  Time.utcDate(2006, 4, 2),\n  Time.utcDate(2006, 4, 3),\n  Time.utcDate(2006, 4, 4)\n]\n</code></pre>\n","name":"range","source":"/*\nReturns an array of days from the given start to given end time (inclusive).\n\n  Time.range(Time.utcDate(2006, 4, 1), Time.utcDate(2006, 4, 4)) == [\n    Time.utcDate(2006, 4, 1),\n    Time.utcDate(2006, 4, 2),\n    Time.utcDate(2006, 4, 3),\n    Time.utcDate(2006, 4, 4)\n  ]\n*/\nfun range (from : Time, to : Time) : Array(Time) {\n  `\n    (() => {\n      const currentDate = #{atBeginningOfDay(from)};\n      const endTime = #{atEndOfDay(to)}.getTime();\n      const dates = [];\n\n      while (currentDate.getTime() <= endTime) {\n        dates.push(new Date(+currentDate))\n        currentDate.setUTCDate(currentDate.getUTCDate() + 1)\n        currentDate.setUTCHours(0, 0, 0, 0)\n      }\n\n      return dates;\n    })()`\n}","arguments":[{"type":"Time","name":"from"},{"type":"Time","name":"to"}]},{"type":"Maybe(Time)","description":"<p>Converts the given time zone, since not all browsers support time zone\nconversion this function can fail.</p>\n<pre><code>Time.inZone(&quot;America/New_York&quot;, Time.utc(2019, 1, 1, 7, 12, 35, 200)) ==\n  Maybe::Just(Time.utc(2019, 1, 1, 2, 12, 35, 200))\n</code></pre>\n","name":"inZone","source":"/*\nConverts the given time zone, since not all browsers support time zone\nconversion this function can fail.\n\n  Time.inZone(\"America/New_York\", Time.utc(2019, 1, 1, 7, 12, 35, 200)) ==\n    Maybe::Just(Time.utc(2019, 1, 1, 2, 12, 35, 200))\n*/\nfun inZone (timeZone : String, time : Time) : Maybe(Time) {\n  `\n    (() => {\n      try {\n        const time = new Date(#{time}.toLocaleString(\"en-US\", { timeZone: #{timeZone} }));\n\n        // Correct the millisecond since the en-US local string doesn't contain that.\n        time.setUTCMilliseconds(#{time}.getUTCMilliseconds())\n\n        // Shift the resulting time by the local time-zone offset.\n        time.setUTCMinutes(time.getUTCMinutes() - time.getTimezoneOffset())\n\n        return #{Maybe::Just(`time`)};\n      } catch {\n        return #{Maybe::Nothing}\n      }\n    })()\n    `\n}","arguments":[{"type":"String","name":"timeZone"},{"type":"Time","name":"time"}]},{"type":null,"description":"<p>Reports the approximate distance in time between two <code>Time</code> objects as seconds\nin the given language.</p>\n<pre><code>now =\n  Time.utc(2016, 1, 2, 12, 34, 50, 200)\n\ntime =\n  Time.shift(Time.Span::Hours(4), time)\n\nTime.distanceOfTimeInWords(time, now, Time.Format::English)) == &quot;in 4 hours&quot;\n</code></pre>\n","name":"distanceOfTimeInWords","source":"/*\nReports the approximate distance in time between two `Time` objects as seconds\nin the given language.\n\n  now =\n    Time.utc(2016, 1, 2, 12, 34, 50, 200)\n\n  time =\n    Time.shift(Time.Span::Hours(4), time)\n\n  Time.distanceOfTimeInWords(time, now, Time.Format::English)) == \"in 4 hours\"\n*/\nfun distanceOfTimeInWords (\n  from : Time,\n  to : Time,\n  language : Time.Format.Language\n) {\n  let distance =\n    Time.toUnix(to) - Time.toUnix(from)\n\n  if distance == 0 {\n    language.rightNow\n  } else {\n    let seconds =\n      Math.trunc(Math.abs(distance) / 1000)\n\n    let minutes =\n      Math.trunc(seconds / 60)\n\n    let hours =\n      Math.trunc(minutes / 60)\n\n    let days =\n      Math.trunc(hours / 24)\n\n    let positive =\n      distance > 0\n\n    if minutes < 1 {\n      if positive {\n        language.someSecondsAgo\n      } else {\n        language.inSomeSeconds\n      }(seconds)\n    } else if hours < 1 {\n      if positive {\n        language.someMinutesAgo\n      } else {\n        language.inSomeMinutes\n      }(minutes)\n    } else if hours < 24 {\n      if positive {\n        language.someHoursAgo\n      } else {\n        language.inSomeHours\n      }(hours)\n    } else if days < 30 {\n      if positive {\n        language.someDaysAgo\n      } else {\n        language.inSomeDays\n      }(days)\n    } else if days < 365 {\n      if positive {\n        language.someMonthsAgo\n      } else {\n        language.inSomeMonths\n      }(Math.trunc(days / 30))\n    } else {\n      if positive {\n        language.someYearsAgo\n      } else {\n        language.inSomeYears\n      }(Math.trunc(days / 365))\n    }\n  }\n}","arguments":[{"type":"Time","name":"from"},{"type":"Time","name":"to"},{"type":"Time.Format.Language","name":"language"}]},{"type":"String","description":"<p>Formats the given time using the given pattern in the given language.</p>\n<pre><code>Time.format(\n  Time.utcDate(2018, 4, 5),\n  Time.Format:ENGLISH,\n  &quot;%Y-%m-%dT%H:%M:%S.%LZ&quot;) == &quot;2018-04-05T00:00:00.000Z&quot;\n</code></pre>\n<p>The following token can be used in the pattern:</p>\n<pre><code>- %a: short day name (Sun, Mon, Tue, ...)\n- %^a: short day name, upcase (SUN, MON, TUE, ...)\n- %A: day name (Sunday, Monday, Tuesday, ...)\n- %^A: day name, upcase (SUNDAY, MONDAY, TUESDAY, ...)\n- %b: short month name (Jan, Feb, Mar, ...)\n- %^b: short month name, upcase (JAN, FEB, MAR, ...)\n- %B: month name (January, February, March, ...)\n- %^B: month name, upcase (JANUARY, FEBRUARY, MARCH, ...)\n- %c: date and time (Tue Apr 5 10:26:19 2016)\n- %C: year divided by 100\n- %d: day of month, zero padded (01, 02, ...)\n- %-d: day of month (1, 2, ..., 31)\n- %D: date (04/05/16)\n- %e: day of month, blank padded (&quot; 1&quot;, &quot; 2&quot;, ..., &quot;10&quot;, &quot;11&quot;, ...)\n- %F: ISO 8601 date (2016-04-05)\n- %g: week-based calendar year modulo 100 (00..99)\n- %G: week-based calendar year (0001..9999)\n- %h: (same as %b) short month name (Jan, Feb, Mar, ...)\n- %H: hour of the day, 24-hour clock, zero padded (00, 01, ..., 24)\n- %I: hour of the day, 12-hour clock, zero padded (00, 01, ..., 12)\n- %j: day of year, zero padded (001, 002, ..., 365)\n- %k: hour of the day, 24-hour clock, blank padded (&quot; 0&quot;, &quot; 1&quot;, ..., &quot;24&quot;)\n- %l: hour of the day, 12-hour clock, blank padded (&quot; 0&quot;, &quot; 1&quot;, ..., &quot;12&quot;)\n- %L: milliseconds, zero padded (000, 001, ..., 999)\n- %m: month number, zero padded (01, 02, ..., 12)\n- %_m: month number, blank padded (&quot; 1&quot;, &quot; 2&quot;, ..., &quot;12&quot;)\n- %-m: month number (1, 2, ..., 12)\n- %M: minute, zero padded (00, 01, 02, ..., 59)\n- %p: am-pm (lowercase)\n- %P: AM-PM (uppercase)\n- %r: 12-hour time (03:04:05 AM)\n- %R: 24-hour time (13:04)\n- %s: seconds since unix epoch\n- %S: seconds, zero padded (00, 01, ..., 59)\n- %T: 24-hour time (13:04:05)\n- %u: day of week (Monday is 1, 1..7)\n- %V: ISO calendar week number of the week-based year (01..53)\n- %w: day of week (Sunday is 0, 0..6)\n- %x: (same as %D) date (04/05/16)\n- %X: (same as %T) 24-hour time (13:04:05)\n- %y: year modulo 100\n- %Y: year, zero padded\n</code></pre>\n","name":"format","source":"/*\nFormats the given time using the given pattern in the given language.\n\n  Time.format(\n    Time.utcDate(2018, 4, 5),\n    Time.Format:ENGLISH,\n    \"%Y-%m-%dT%H:%M:%S.%LZ\") == \"2018-04-05T00:00:00.000Z\"\n\nThe following token can be used in the pattern:\n\n  - %a: short day name (Sun, Mon, Tue, ...)\n  - %^a: short day name, upcase (SUN, MON, TUE, ...)\n  - %A: day name (Sunday, Monday, Tuesday, ...)\n  - %^A: day name, upcase (SUNDAY, MONDAY, TUESDAY, ...)\n  - %b: short month name (Jan, Feb, Mar, ...)\n  - %^b: short month name, upcase (JAN, FEB, MAR, ...)\n  - %B: month name (January, February, March, ...)\n  - %^B: month name, upcase (JANUARY, FEBRUARY, MARCH, ...)\n  - %c: date and time (Tue Apr 5 10:26:19 2016)\n  - %C: year divided by 100\n  - %d: day of month, zero padded (01, 02, ...)\n  - %-d: day of month (1, 2, ..., 31)\n  - %D: date (04/05/16)\n  - %e: day of month, blank padded (\" 1\", \" 2\", ..., \"10\", \"11\", ...)\n  - %F: ISO 8601 date (2016-04-05)\n  - %g: week-based calendar year modulo 100 (00..99)\n  - %G: week-based calendar year (0001..9999)\n  - %h: (same as %b) short month name (Jan, Feb, Mar, ...)\n  - %H: hour of the day, 24-hour clock, zero padded (00, 01, ..., 24)\n  - %I: hour of the day, 12-hour clock, zero padded (00, 01, ..., 12)\n  - %j: day of year, zero padded (001, 002, ..., 365)\n  - %k: hour of the day, 24-hour clock, blank padded (\" 0\", \" 1\", ..., \"24\")\n  - %l: hour of the day, 12-hour clock, blank padded (\" 0\", \" 1\", ..., \"12\")\n  - %L: milliseconds, zero padded (000, 001, ..., 999)\n  - %m: month number, zero padded (01, 02, ..., 12)\n  - %_m: month number, blank padded (\" 1\", \" 2\", ..., \"12\")\n  - %-m: month number (1, 2, ..., 12)\n  - %M: minute, zero padded (00, 01, 02, ..., 59)\n  - %p: am-pm (lowercase)\n  - %P: AM-PM (uppercase)\n  - %r: 12-hour time (03:04:05 AM)\n  - %R: 24-hour time (13:04)\n  - %s: seconds since unix epoch\n  - %S: seconds, zero padded (00, 01, ..., 59)\n  - %T: 24-hour time (13:04:05)\n  - %u: day of week (Monday is 1, 1..7)\n  - %V: ISO calendar week number of the week-based year (01..53)\n  - %w: day of week (Sunday is 0, 0..6)\n  - %x: (same as %D) date (04/05/16)\n  - %X: (same as %T) 24-hour time (13:04:05)\n  - %y: year modulo 100\n  - %Y: year, zero padded\n*/\nfun format (\n  time : Time,\n  language : Time.Format.Language,\n  pattern : String\n) : String {\n  `\n    (() => {\n      let result = \"\";\n      let index = 0;\n      let char;\n\n      while (char = #{pattern}[index]) {\n        if (char == \"%\") {\n          const nextTwoChars =\n            #{pattern}.slice(index + 1, index + 3);\n\n          let converted =\n            #{formatToken(time, language, `nextTwoChars`)};\n\n          if (converted !== nextTwoChars) {\n            result += converted\n            index += 3;\n            continue;\n          } else {\n            const nextChar =\n              #{pattern}[index + 1];\n\n            const converted =\n              #{formatToken(time, language, `nextChar`)};\n\n            if (converted !== nextChar) {\n              result += converted;\n              index += 2;\n              continue;\n            }\n          }\n        }\n\n        result += char;\n        index++;\n      }\n\n      return result;\n    })()\n    `\n}","arguments":[{"type":"Time","name":"time"},{"type":"Time.Format.Language","name":"language"},{"type":"String","name":"pattern"}]},{"type":"String","description":"<p>Formats the given time to the ISO format.</p>\n<pre><code>Time.formatISO(Time.utcDate(2018, 4, 5)) == &quot;2018-04-05T00:00:00.000Z&quot;\n</code></pre>\n","name":"formatISO","source":"/*\nFormats the given time to the ISO format.\n\n  Time.formatISO(Time.utcDate(2018, 4, 5)) == \"2018-04-05T00:00:00.000Z\"\n*/\nfun formatISO (time : Time) : String {\n  format(time, Time.Format.ENGLISH, \"%Y-%m-%dT%H:%M:%S.%LZ\")\n}","arguments":[{"type":"Time","name":"time"}]},{"type":"String","description":"<p>Formats the given time by the given single token using the given language.</p>\n<pre><code>Time.formatToken(Time.Format:ENGLISH, &quot;Y&quot;, Time.utcDate(2018, 4, 5)) == &quot;2018&quot;\n</code></pre>\n","name":"formatToken","source":"/*\nFormats the given time by the given single token using the given language.\n\n  Time.formatToken(Time.Format:ENGLISH, \"Y\", Time.utcDate(2018, 4, 5)) == \"2018\"\n*/\nfun formatToken (\n  time : Time,\n  language : Time.Format.Language,\n  token : String\n) : String {\n  case token {\n    /* short day name (Sun, Mon, Tue, ...) */\n    \"a\" =>\n      time\n      |> dayOfWeek\n      |> language.toWeekdayAbbreviation\n\n    /* short day name, upcase (SUN, MON, TUE, ...) */\n    \"^a\" =>\n      time\n      |> dayOfWeek\n      |> language.toWeekdayAbbreviation\n      |> String.toUpperCase\n\n    /* day name (Sunday, Monday, Tuesday, ...) */\n    \"A\" =>\n      time\n      |> dayOfWeek\n      |> language.toWeekdayName\n\n    /* day name, upcase (SUNDAY, MONDAY, TUESDAY, ...) */\n    \"^A\" =>\n      time\n      |> dayOfWeek\n      |> language.toWeekdayName\n      |> String.toUpperCase\n\n    /* short month name (Jan, Feb, Mar, ...) */\n    \"b\" =>\n      time\n      |> month\n      |> language.toMonthAbbreviation\n\n    /* short month name, upcase (JAN, FEB, MAR, ...) */\n    \"^b\" =>\n      time\n      |> month\n      |> language.toMonthAbbreviation\n      |> String.toUpperCase\n\n    /* month name (January, February, March, ...) */\n    \"B\" =>\n      time\n      |> month\n      |> language.toMonthName\n\n    /* month name, upcase (JANUARY, FEBRUARY, MARCH, ...) */\n    \"^B\" =>\n      time\n      |> month\n      |> language.toMonthName\n      |> String.toUpperCase\n\n    /* date and time (Tue Apr 5 10:26:19 2016) */\n    \"c\" =>\n      format(time, language, \"%a %b %-d %H:%M:%S %Y\")\n\n    /* year divided by 100. */\n    \"C\" =>\n      year(time) / 100\n      |> Number.toString\n\n    /* day of month, zero padded (01, 02, ...) */\n    \"d\" =>\n      time\n      |> dayOfMonth()\n      |> Number.toString\n      |> String.padStart(\"0\", 2)\n\n    /* day of month (1, 2, ..., 31) */\n    \"-d\" =>\n      time\n      |> dayOfMonth()\n      |> Number.toString\n\n    /* date (04/05/16) */\n    \"D\" =>\n      format(time, language, \"%m/%d/%Y\")\n\n    /* day of month, blank padded (\" 1\", \" 2\", ..., \"10\", \"11\", ...) */\n    \"e\" =>\n      time\n      |> dayOfMonth()\n      |> Number.toString\n      |> String.padStart(\" \", 2)\n\n    /* ISO 8601 date (2016-04-05) */\n    \"F\" =>\n      format(time, language, \"%Y-%m-%d\")\n\n    /* week-based calendar year modulo 100 (00..99) */\n    \"g\" =>\n      (calendarWeek(time)[0] % 100)\n      |> Number.toString\n      |> String.padStart(\"0\", 2)\n\n    /* week-based calendar year (0001..9999) */\n    \"G\" =>\n      calendarWeek(time)[0]\n      |> Number.toString\n      |> String.padStart(\"0\", 4)\n\n    /* hour of the day, 24-hour clock, zero padded (00, 01, ..., 24) */\n    \"H\" =>\n      time\n      |> hour\n      |> Number.toString()\n      |> String.padStart(\"0\", 2)\n\n    /* hour of the day, 12-hour clock, zero padded (00, 01, ..., 12) */\n    \"I\" =>\n      (hour(time) - 12)\n      |> Math.abs\n      |> Number.toString()\n      |> String.padStart(\"0\", 2)\n\n    /* day of year, zero padded (001, 002, ..., 365) */\n    \"j\" =>\n      time\n      |> dayOfYear\n      |> Number.toString\n      |> String.padStart(\"0\", 3)\n\n    /* hour of the day, 24-hour clock, blank padded (\" 0\", \" 1\", ..., \"24\") */\n    \"k\" =>\n      time\n      |> hour\n      |> Number.toString()\n      |> String.padStart(\" \", 2)\n\n    /* hour of the day, 12-hour clock, blank padded (\" 0\", \" 1\", ..., \"12\") */\n    \"l\" =>\n      (hour(time) - 12)\n      |> Math.abs\n      |> Number.toString()\n      |> String.padStart(\" \", 2)\n\n    /* milliseconds, zero padded (000, 001, ..., 999) */\n    \"L\" =>\n      time\n      |> millisecond\n      |> Number.toString()\n      |> String.padStart(\"0\", 3)\n\n    /* month number, zero padded (01, 02, ..., 12) */\n    \"m\" =>\n      time\n      |> monthNumber()\n      |> Number.toString\n      |> String.padStart(\"0\", 2)\n\n    /* month number, blank padded (\" 1\", \" 2\", ..., \"12\") */\n    \"_m\" =>\n      time\n      |> monthNumber()\n      |> Number.toString\n      |> String.padStart(\" \", 2)\n\n    /* month number (1, 2, ..., 12) */\n    \"-m\" =>\n      time\n      |> monthNumber\n      |> Number.toString\n\n    /* minute, zero padded (00, 01, 02, ..., 59) */\n    \"M\" =>\n      time\n      |> minute\n      |> Number.toString()\n      |> String.padStart(\"0\", 2)\n\n    /* am-pm (lowercase) */\n    \"p\" =>\n      time\n      |> hour()\n      |> language.amPm\n      |> String.toLowerCase\n\n    /* AM-PM (uppercase) */\n    \"P\" =>\n      time\n      |> hour\n      |> language.amPm\n      |> String.toUpperCase\n\n    /* 12-hour time (03:04:05 AM) */\n    \"r\" =>\n      format(time, language, \"%I:%M:%S %P\")\n\n    /* 24-hour time (13:04) */\n    \"R\" =>\n      format(time, language, \"%H:%M\")\n\n    /* seconds since unix epoch */\n    \"s\" =>\n      time\n      |> Time.toUnix\n      |> Number.toString\n\n    /* seconds, zero padded (00, 01, ..., 59) */\n    \"S\" =>\n      time\n      |> second\n      |> Number.toString\n      |> String.padStart(\"0\", 2)\n\n    /* 24-hour time (13:04:05) */\n    \"T\" =>\n      format(time, language, \"%H:%M:%S\")\n\n    /* day of week (Monday is 1, 1..7) */\n    \"u\" =>\n      time\n      |> dayOfWeekNumber\n      |> Number.toString\n\n    /* ISO calendar week number of the week-based year (01..53) */\n    \"V\" =>\n      calendarWeek(time)[1]\n      |> Number.toString\n      |> String.padStart(\"0\", 2)\n\n    /* day of week (Sunday is 0, 0..6) */\n    \"w\" =>\n      {\n        let number =\n          dayOfWeekNumber(time)\n\n        if number == 7 {\n          0\n        } else {\n          number\n        }\n        |> Number.toString\n      }\n\n    /* (same as %D) date (04/05/16) */\n    \"x\" =>\n      format(time, language, \"%m/%d/%Y\")\n\n    /* (same as %T) 24-hour time (13:04:05) */\n    \"X\" =>\n      format(time, language, \"%H:%M:%S\")\n\n    /* year modulo 100. */\n    \"y\" =>\n      year(time) % 100\n      |> Number.toString\n\n    /* year, zero padded */\n    \"Y\" =>\n      time\n      |> year\n      |> Number.toString\n      |> String.padStart(\"0\", 4)\n\n    =>\n      token\n  }\n}","arguments":[{"type":"Time","name":"time"},{"type":"Time.Format.Language","name":"language"},{"type":"String","name":"token"}]}]},{"description":null,"name":"Time.Format","functions":[]},{"description":null,"name":"Timer","functions":[{"type":"Promise(Void)","description":"<p>Returns a promise which resolves after the next <code>animationFrame</code>.</p>\n","name":"nextFrame","source":"/* Returns a promise which resolves after the next `animationFrame`. */\nfun nextFrame : Promise(Void) {\n  `\n    new Promise((resolve) => {\n      requestAnimationFrame(() => {\n        resolve(#{void})\n      })\n    })\n    `\n}","arguments":[]},{"type":"Promise(Void)","description":"<p>Returns a promise which resolves after the given number of time in\nmilliseconds.</p>\n","name":"timeout","source":"/*\nReturns a promise which resolves after the given number of time in\nmilliseconds.\n*/\nfun timeout (duration : Number) : Promise(Void) {\n  `\n    new Promise((resolve) => {\n      setTimeout(() => {\n        resolve(#{void})\n      }, #{duration})\n    })\n    `\n}","arguments":[{"type":"Number","name":"duration"}]}]},{"description":null,"name":"Uid","functions":[{"type":"String","description":"<p>Generates a unique identifier.</p>\n","name":"generate","source":"/* Generates a unique identifier. */\nfun generate : String {\n  `\n    ([1e7] + -1e3 + -4e3 + -8e3 + -1e11)\n      .replace(/[018]/g, c =>\n        (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4)\n          .toString(16))\n    `\n}","arguments":[]}]},{"description":null,"name":"Url","functions":[{"type":"String","description":"<p>Creates an url from the given file, which is available until the current\nwindow is closed.</p>\n<pre><code>File.fromString(&quot;Content&quot;, &quot;test.html&quot;, &quot;text/html&quot;)\n|&gt; Url.createObjectUrlFromFile()\n</code></pre>\n","name":"createObjectUrlFromFile","source":"/*\nCreates an url from the given file, which is available until the current\nwindow is closed.\n\n  File.fromString(\"Content\", \"test.html\", \"text/html\")\n  |> Url.createObjectUrlFromFile()\n*/\nfun createObjectUrlFromFile (file : File) : String {\n  `URL.createObjectURL(#{file})`\n}","arguments":[{"type":"File","name":"file"}]},{"type":"String","description":"<p>Creates an url from the given content and type, which is available until the\ncurrent window is closed.</p>\n<pre><code>Url.createObjectUrlFromString(&quot;Content&quot;, &quot;text/html&quot;)\n</code></pre>\n","name":"createObjectUrlFromString","source":"/*\nCreates an url from the given content and type, which is available until the\ncurrent window is closed.\n\n  Url.createObjectUrlFromString(\"Content\", \"text/html\")\n*/\nfun createObjectUrlFromString (string : String, type : String) : String {\n  `\n    (() => {\n      let blob = new Blob([#{string}], {type : #{type}})\n      return URL.createObjectURL(blob)\n    })()\n    `\n}","arguments":[{"type":"String","name":"string"},{"type":"String","name":"type"}]},{"type":"Url","description":"<p>Parses the given string as an <code>Url</code>.</p>\n<pre><code>Url.parse(&quot;https://www.example.com&quot;).host == &quot;www.example.com&quot;\n</code></pre>\n","name":"parse","source":"/*\nParses the given string as an `Url`.\n\n  Url.parse(\"https://www.example.com\").host == \"www.example.com\"\n*/\nfun parse (url : String) : Url {\n  `\n    (() => {\n      if (!this._a) {\n        this._a = document.createElement('a')\n      }\n\n      this._a.href = #{url}\n\n      return #{{\n        hostname: `this._a.hostname || \"\"`,\n        protocol: `this._a.protocol || \"\"`,\n        origin: `this._a.origin || \"\"`,\n        path: `this._a.pathname || \"\"`,\n        search: `this._a.search || \"\"`,\n        hash: `this._a.hash || \"\"`,\n        host: `this._a.host || \"\"`,\n        port: `this._a.port || \"\"`\n      }}\n    })()\n    `\n}","arguments":[{"type":"String","name":"url"}]},{"type":"String","description":"<p>Converts the given <code>Url</code> to a <code>String</code>.</p>\n<pre><code>(Url.parse(&quot;https://www.example.com/path/?search=foo#hash&quot;)\n|&gt; Url.toString()) == &quot;https://www.example.com/path/?search=foo#hash&quot;\n</code></pre>\n","name":"toString","source":"/*\nConverts the given `Url` to a `String`.\n\n  (Url.parse(\"https://www.example.com/path/?search=foo#hash\")\n  |> Url.toString()) == \"https://www.example.com/path/?search=foo#hash\"\n*/\nfun toString (url : Url) : String {\n  `#{url}.origin + #{url}.path + #{url}.search + #{url}.hash`\n}","arguments":[{"type":"Url","name":"url"}]},{"type":"Void","description":"<p>Releases an existing object URL which was previously created.</p>\n<pre><code>Url.createObjectUrlFromString(&quot;Content&quot;, &quot;text/html&quot;)\n|&gt; Url.revokeObjectUrl()\n</code></pre>\n","name":"revokeObjectUrl","source":"/*\nReleases an existing object URL which was previously created.\n\n  Url.createObjectUrlFromString(\"Content\", \"text/html\")\n  |> Url.revokeObjectUrl()\n*/\nfun revokeObjectUrl (url : String) : Void {\n  `URL.revokeObjectURL(#{url})`\n}","arguments":[{"type":"String","name":"url"}]}]},{"description":null,"name":"Validation","functions":[{"type":"Maybe(String)","description":"<p>Returns the first error for the given key in the given errors.</p>\n","name":"getFirstError","source":"/* Returns the first error for the given key in the given errors. */\nfun getFirstError (errors : Map(String, Array(String)), key : String) : Maybe(String) {\n  errors\n  |> Map.get(key)\n  |> Maybe.map(Array.first)\n  |> Maybe.flatten\n}","arguments":[{"type":"Map(String, Array(String))","name":"errors"},{"type":"String","name":"key"}]},{"type":"Maybe(Tuple(String, String))","description":"<p>Returns the given error if the given string is does not have the exact number\nof characters.</p>\n<pre><code>Validation.hasExactNumberOfCharacters(\n  &quot;&quot;,\n  5,\n  {&quot;zip&quot;, &quot;Zip code does is not 5 characters!&quot;}) ==\n    Maybe::Just({&quot;zip&quot;, &quot;Zip code does is not 5 characters!&quot;})\n</code></pre>\n","name":"hasExactNumberOfCharacters","source":"/*\nReturns the given error if the given string is does not have the exact number\nof characters.\n\n  Validation.hasExactNumberOfCharacters(\n    \"\",\n    5,\n    {\"zip\", \"Zip code does is not 5 characters!\"}) ==\n      Maybe::Just({\"zip\", \"Zip code does is not 5 characters!\"})\n*/\nfun hasExactNumberOfCharacters (\n  value : String,\n  size : Number,\n  error : Tuple(String, String)\n) : Maybe(Tuple(String, String)) {\n  if String.size(value) == size {\n    Maybe.Nothing\n  } else {\n    Maybe.Just(error)\n  }\n}","arguments":[{"type":"String","name":"value"},{"type":"Number","name":"size"},{"type":"Tuple(String, String)","name":"error"}]},{"type":"Maybe(Tuple(String, String))","description":"<p>Returns the given error if the given string does not have at least the given\nnumber of characters.</p>\n<pre><code>Validation.hasMinimumNumberOfCharacters(\n  &quot;&quot;,\n  5,\n  {&quot;zip&quot;, &quot;Zip code does is not 5 characters or more!&quot;}) ==\n    Maybe::Just({&quot;zip&quot;, &quot;Zip code does is not 5 characters or more!&quot;})\n</code></pre>\n","name":"hasMinimumNumberOfCharacters","source":"/*\nReturns the given error if the given string does not have at least the given\nnumber of characters.\n\n  Validation.hasMinimumNumberOfCharacters(\n    \"\",\n    5,\n    {\"zip\", \"Zip code does is not 5 characters or more!\"}) ==\n      Maybe::Just({\"zip\", \"Zip code does is not 5 characters or more!\"})\n*/\nfun hasMinimumNumberOfCharacters (\n  value : String,\n  size : Number,\n  error : Tuple(String, String)\n) : Maybe(Tuple(String, String)) {\n  if String.size(value) >= size {\n    Maybe.Nothing\n  } else {\n    Maybe.Just(error)\n  }\n}","arguments":[{"type":"String","name":"value"},{"type":"Number","name":"size"},{"type":"Tuple(String, String)","name":"error"}]},{"type":"Maybe(Tuple(String, String))","description":"<p>Returns the given error when the given string is blank\n(contains only whitespace).</p>\n<pre><code>Validation.isNotBlank(&quot;&quot;, {&quot;name&quot;, &quot;Name is empty!&quot;}) ==\n  Maybe::Just({&quot;name&quot;, &quot;Name is empty!&quot;})\n</code></pre>\n","name":"isNotBlank","source":"/*\nReturns the given error when the given string is blank\n(contains only whitespace).\n\n  Validation.isNotBlank(\"\", {\"name\", \"Name is empty!\"}) ==\n    Maybe::Just({\"name\", \"Name is empty!\"})\n*/\nfun isNotBlank (value : String, error : Tuple(String, String)) : Maybe(Tuple(String, String)) {\n  if String.isNotBlank(value) {\n    Maybe.Nothing\n  } else {\n    Maybe.Just(error)\n  }\n}","arguments":[{"type":"String","name":"value"},{"type":"Tuple(String, String)","name":"error"}]},{"type":"Maybe(Tuple(String, String))","description":"<p>Returns the given error if the given string is not a number.</p>\n<pre><code>Validation.isNumber(&quot;foo&quot;, {&quot;multiplicand&quot;, &quot;Multiplicand is not a number!&quot;}) ==\n  Maybe::Just({&quot;multiplicand&quot;, &quot;Multiplicand is not a number!&quot;})\n</code></pre>\n","name":"isNumber","source":"/*\nReturns the given error if the given string is not a number.\n\n  Validation.isNumber(\"foo\", {\"multiplicand\", \"Multiplicand is not a number!\"}) ==\n    Maybe::Just({\"multiplicand\", \"Multiplicand is not a number!\"})\n*/\nfun isNumber (value : String, error : Tuple(String, String)) : Maybe(Tuple(String, String)) {\n  case Number.fromString(value) {\n    Maybe.Just => Maybe.Nothing\n    => Maybe.Just(error)\n  }\n}","arguments":[{"type":"String","name":"value"},{"type":"Tuple(String, String)","name":"error"}]},{"type":"Maybe(Tuple(String, String))","description":"<p>Returns the given error if the given string does not consist of just digits.</p>\n<pre><code>Validation.isDigits(&quot;1234x&quot;, {&quot;zip&quot;, &quot;Zip code is not just digits!&quot;}) ==\n  Maybe::Just({&quot;zip&quot;, &quot;Zip code is not just digits!&quot;})\n</code></pre>\n","name":"isDigits","source":"/*\nReturns the given error if the given string does not consist of just digits.\n\n  Validation.isDigits(\"1234x\", {\"zip\", \"Zip code is not just digits!\"}) ==\n    Maybe::Just({\"zip\", \"Zip code is not just digits!\"})\n*/\nfun isDigits (value : String, error : Tuple(String, String)) : Maybe(Tuple(String, String)) {\n  if Regexp.match(DIGITS_REGEXP, value) {\n    Maybe.Nothing\n  } else {\n    Maybe.Just(error)\n  }\n}","arguments":[{"type":"String","name":"value"},{"type":"Tuple(String, String)","name":"error"}]},{"type":"Maybe(Tuple(String, String))","description":"<p>Returns the given error if the two given values are not the same.</p>\n<pre><code>Validation.isSame(\n  &quot;password&quot;,\n  &quot;confirmation&quot;,\n  {&quot;confirmation&quot;, &quot;Confirmation is not the same!&quot;}) ==\n    Maybe::Just({&quot;confirmation&quot;, &quot;Confirmation is not the same!&quot;})\n</code></pre>\n","name":"isSame","source":"/*\nReturns the given error if the two given values are not the same.\n\n  Validation.isSame(\n    \"password\",\n    \"confirmation\",\n    {\"confirmation\", \"Confirmation is not the same!\"}) ==\n      Maybe::Just({\"confirmation\", \"Confirmation is not the same!\"})\n*/\nfun isSame (value : a, value2 : a, error : Tuple(String, String)) : Maybe(Tuple(String, String)) {\n  if value == value2 {\n    Maybe.Nothing\n  } else {\n    Maybe.Just(error)\n  }\n}","arguments":[{"type":"a","name":"value"},{"type":"a","name":"value2"},{"type":"Tuple(String, String)","name":"error"}]},{"type":"Maybe(Tuple(String, String))","description":"<p>Returns the given error if the given string is not an email address.</p>\n<pre><code>Validation.isValidEmail(\n  &quot;test&quot;,\n  {&quot;email&quot;, &quot;Email is not a valid email address!&quot;}) ==\n    Maybe::Just({&quot;email&quot;, &quot;Email is not a valid email address!&quot;})\n</code></pre>\n","name":"isValidEmail","source":"/*\nReturns the given error if the given string is not an email address.\n\n  Validation.isValidEmail(\n    \"test\",\n    {\"email\", \"Email is not a valid email address!\"}) ==\n      Maybe::Just({\"email\", \"Email is not a valid email address!\"})\n*/\nfun isValidEmail (value : String, error : Tuple(String, String)) : Maybe(Tuple(String, String)) {\n  if Regexp.match(EMAIL_REGEXP, value) {\n    Maybe.Nothing\n  } else {\n    Maybe.Just(error)\n  }\n}","arguments":[{"type":"String","name":"value"},{"type":"Tuple(String, String)","name":"error"}]},{"type":"Map(String, Array(String))","description":"<p>Merges the result of many validations into a <code>Map(String, Array(String))</code>.</p>\n<pre><code>Validation.merge([\n  Validation.isNotBlank(&quot;&quot;, {&quot;firstName&quot;, &quot;Please enter the first name.&quot;}),\n  Validation.isNotBlank(&quot;&quot;, {&quot;message&quot;, &quot;Please enter the message.&quot;}),\n]) == (Map.empty()\n  |&gt; Map.set(&quot;firstName&quot;, &quot;Please enter the first name.&quot;)\n  |&gt; Map.set(&quot;message&quot;, &quot;Please enter the message.&quot;))\n</code></pre>\n","name":"merge","source":"/*\nMerges the result of many validations into a `Map(String, Array(String))`.\n\n  Validation.merge([\n    Validation.isNotBlank(\"\", {\"firstName\", \"Please enter the first name.\"}),\n    Validation.isNotBlank(\"\", {\"message\", \"Please enter the message.\"}),\n  ]) == (Map.empty()\n    |> Map.set(\"firstName\", \"Please enter the first name.\")\n    |> Map.set(\"message\", \"Please enter the message.\"))\n*/\nfun merge (errors : Array(Maybe(Tuple(String, String)))) : Map(String, Array(String)) {\n  errors\n  |> Array.reduce(\n    Map.empty(), \n    (\n      memo : Map(String, Array(String)),\n      item : Maybe(Tuple(String, String))\n    ) : Map(String, Array(String)) {\n      case item {\n        Maybe.Just(error) =>\n          {\n            let #(key, message) =\n              error\n\n            let messages =\n              memo\n              |> Map.get(key)\n              |> Maybe.withDefault([])\n\n            Map.set(memo, key, Array.push(messages, message))\n          }\n\n        => memo\n      }\n    })\n}","arguments":[{"type":"Array(Maybe(Tuple(String, String)))","name":"errors"}]}]},{"description":null,"name":"WebSocket","functions":[{"type":"Promise(Void)","description":"<p>Closes the given websocket connection.</p>\n<pre><code>WebSocket.close(websocket)\n</code></pre>\n<p>If the <code>reconnectOnClose</code> flag was specified then the connection will\nreconnect using this function.</p>\n","name":"close","source":"/*\nCloses the given websocket connection.\n\n  WebSocket.close(websocket)\n\nIf the `reconnectOnClose` flag was specified then the connection will\nreconnect using this function.\n*/\nfun close (socket : WebSocket) : Promise(Void) {\n  `#{socket}.close()`\n}","arguments":[{"type":"WebSocket","name":"socket"}]},{"type":"Promise(Void)","description":"<p>Closes the given websocket connection without reconnecting, even if the\n<code>reconnectOnClose</code> flag was set.</p>\n<pre><code>WebSocket.closeWithoutReconnecting(websocket)\n</code></pre>\n","name":"closeWithoutReconnecting","source":"/*\nCloses the given websocket connection without reconnecting, even if the\n`reconnectOnClose` flag was set.\n\n  WebSocket.closeWithoutReconnecting(websocket)\n*/\nfun closeWithoutReconnecting (socket : WebSocket) : Promise(Void) {\n  `\n    (() => {\n      #{socket}.shouldNotReconnect = true;\n      #{socket}.close();\n    })()\n    `\n}","arguments":[{"type":"WebSocket","name":"socket"}]},{"type":"WebSocket","description":"<p>Creates a websocket connection from the given configuration:</p>\n<pre><code>websocket =\n  WebSocket.open({\n    url: &quot;wss://echo.websocket.org&quot;,\n    reconnectOnClose: true,\n    onMessage: handleMessage,\n    onError: handleError,\n    onClose: handleClose,\n    onOpen: handleOpen\n  })\n</code></pre>\n<p>If <code>reconnectOnClose</code> is set then when a connection is closed it tries to\nreconnect, using the same configuration (basically calls open again).</p>\n","name":"open","source":"/*\nCreates a websocket connection from the given configuration:\n\n  websocket =\n    WebSocket.open({\n      url: \"wss://echo.websocket.org\",\n      reconnectOnClose: true,\n      onMessage: handleMessage,\n      onError: handleError,\n      onClose: handleClose,\n      onOpen: handleOpen\n    })\n\nIf `reconnectOnClose` is set then when a connection is closed it tries to\nreconnect, using the same configuration (basically calls open again).\n*/\nfun open (config : WebSocket.Config) : WebSocket {\n  `\n    (() => {\n      /* Initialize a new WebSocket object. */\n      const socket = new WebSocket(#{config.url});\n\n      /* Event handlers. */\n      const onMessage = (event) => #{config.onMessage(`event.data`)}\n      const onOpen = () => #{config.onOpen(`socket`)}\n      const onError = () => #{config.onError()}\n\n      /*\n      *  The close event handler is different:\n      *  - removes event listeners\n      *  - reconnects as a new websocket connection if specified\n      *  - calls close event handler\n      */\n      const onClose = () => {\n        socket.removeEventListener(\"message\", onMessage);\n        socket.removeEventListener(\"error\", onError);\n        socket.removeEventListener(\"close\", onClose);\n        socket.removeEventListener(\"open\", onOpen);\n\n        #{config.onClose()};\n\n        if (#{config.reconnectOnClose} && !socket.shouldNotReconnect) {\n          #{open(config)};\n        }\n\n        delete socket.shouldNotReconnect;\n      }\n\n      /* Add event listeners. */\n      socket.addEventListener(\"message\", onMessage)\n      socket.addEventListener(\"error\", onError)\n      socket.addEventListener(\"close\", onClose)\n      socket.addEventListener(\"open\", onOpen)\n\n      return socket\n    })()\n    `\n}","arguments":[{"type":"WebSocket.Config","name":"config"}]},{"type":"Promise(Void)","description":"<p>Sends the given data to the given websocket connection.</p>\n<pre><code>WebSocket.send(websocket, &quot;some data&quot;)\n</code></pre>\n","name":"send","source":"/*\nSends the given data to the given websocket connection.\n\n  WebSocket.send(websocket, \"some data\")\n*/\nfun send (socket : WebSocket, data : String) : Promise(Void) {\n  `#{socket}.send(#{data})`\n}","arguments":[{"type":"WebSocket","name":"socket"},{"type":"String","name":"data"}]}]},{"description":null,"name":"Window","functions":[{"type":"Function(Void)","description":"<p>Adds a listener to the window and returns the function which\nremoves this listener.</p>\n<pre><code>listener =\n  Window.addEventListener(&quot;click&quot;, true, (event : Html.Event) {\n    Debug.log(event)\n  })\n</code></pre>\n","name":"addEventListener","source":"/*\nAdds a listener to the window and returns the function which\nremoves this listener.\n\n  listener =\n    Window.addEventListener(\"click\", true, (event : Html.Event) {\n      Debug.log(event)\n    })\n*/\nfun addEventListener (\n  type : String,\n  capture : Bool,\n  listener : Function(Html.Event, a)\n) : Function(Void) {\n  `\n    (() => {\n      const listener = (event) => {\n        #{listener}(_normalizeEvent(event))\n      }\n\n      window.addEventListener(#{type}, listener, #{capture});\n      return () => window.removeEventListener(#{type}, listener, #{capture});\n    })()\n    `\n}","arguments":[{"type":"String","name":"type"},{"type":"Bool","name":"capture"},{"type":"Function(Html.Event, a)","name":"listener"}]},{"type":"Function(Void)","description":"<p>Adds a media query listener to the window and returns the function which\nremoves this listener.</p>\n<pre><code>listener =\n  Window.addMediaQueryListener(&quot;(max-width: 320px)&quot;, (matches : Bool) {\n    Debug.log(matches)\n  })\n</code></pre>\n","name":"addMediaQueryListener","source":"/*\nAdds a media query listener to the window and returns the function which\nremoves this listener.\n\n  listener =\n    Window.addMediaQueryListener(\"(max-width: 320px)\", (matches : Bool) {\n      Debug.log(matches)\n    })\n*/\nfun addMediaQueryListener (query : String, listener : Function(Bool, a)) : Function(Void) {\n  `\n    (() => {\n      const query = window.matchMedia(#{query});\n      const listener = (event) => #{listener}(query.matches);\n      query.addListener(listener)\n      #{listener}(query.matches)\n      return () => query.removeListener(listener);\n    })()\n    `\n}","arguments":[{"type":"String","name":"query"},{"type":"Function(Bool, a)","name":"listener"}]},{"type":"Promise(Void)","description":"<p>Shows the default alert popup of the browser with the given message.</p>\n<p>This function returns a promise but blocks execution until the popup is\nclosed.</p>\n<pre><code>Window.alert(&quot;Hello World!&quot;)\n</code></pre>\n","name":"alert","source":"/*\nShows the default alert popup of the browser with the given message.\n\nThis function returns a promise but blocks execution until the popup is\nclosed.\n\n  Window.alert(\"Hello World!\")\n*/\nfun alert (message : String) : Promise(Void) {\n  `\n    new Promise((resolve, reject) => {\n      window.alert(#{message})\n\n      resolve()\n    })\n    `\n}","arguments":[{"type":"String","name":"message"}]},{"type":"Promise(Result(String, Void))","description":"<p>Shows the default confirm popup of the browser with the given message.</p>\n<p>This function returns a promise but blocks execution until the popup is\nclosed.</p>\n<pre><code>Window.confirm(&quot;Are you ready?&quot;)\n</code></pre>\n","name":"confirm","source":"/*\nShows the default confirm popup of the browser with the given message.\n\nThis function returns a promise but blocks execution until the popup is\nclosed.\n\n  Window.confirm(\"Are you ready?\")\n*/\nfun confirm (message : String) : Promise(Result(String, Void)) {\n  `\n    new Promise((resolve, reject) => {\n      let result = window.confirm(#{message})\n\n      if (result) {\n        resolve(#{Result::Ok(`result`)})\n      } else {\n        resolve(#{Result::Err(\"User cancelled!\")})\n      }\n    })\n    `\n}","arguments":[{"type":"String","name":"message"}]},{"type":"Number","description":"<p>Gets the width of the scrollbar.</p>\n<pre><code>Window.getScrollbarWidth() == 10\n</code></pre>\n","name":"getScrollbarWidth","source":"/*\nGets the width of the scrollbar.\n\n  Window.getScrollbarWidth() == 10\n*/\nfun getScrollbarWidth : Number {\n  `\n    (() => {\n      // Create an outer div which is scrollable\n      const outer = document.createElement(\"div\");\n\n      // Set the needed styles\n      outer.style.visibility = \"hidden\";\n      outer.style.width = \"100px\";\n      outer.style.msOverflowStyle = \"scrollbar\"; // needed for WinJS apps\n\n      // Append it to the body\n      document.body.appendChild(outer);\n\n      const widthNoScroll = outer.offsetWidth;\n\n      // Force scrollbars\n      outer.style.overflow = \"scroll\";\n\n      // Add innerdiv\n      const inner = document.createElement(\"div\");\n      inner.style.width = \"100%\";\n      outer.appendChild(inner);\n\n      const widthWithScroll = inner.offsetWidth;\n\n      // remove divs\n      outer.parentNode.removeChild(outer);\n\n      return widthNoScroll - widthWithScroll;\n    })()\n    `\n}","arguments":[]},{"type":"Number","description":"<p>Returns the height of the window in pixels.</p>\n<pre><code>Window.height() == 768\n</code></pre>\n","name":"height","source":"/*\nReturns the height of the window in pixels.\n\n  Window.height() == 768\n*/\nfun height : Number {\n  `window.innerHeight`\n}","arguments":[]},{"type":"String","description":"<p>Returns the windows URL as a string.</p>\n<pre><code>Window.href() == &quot;https://www.example.com&quot;\n</code></pre>\n","name":"href","source":"/*\nReturns the windows URL as a string.\n\n  Window.href() == \"https://www.example.com\"\n*/\nfun href : String {\n  `window.location.href`\n}","arguments":[]},{"type":"Bool","description":"<p>Returns true if the given url is the same as the current url of the page.</p>\n<pre><code>Window.isActiveURL(&quot;https://www.example.com&quot;)\n</code></pre>\n","name":"isActiveURL","source":"/*\nReturns true if the given url is the same as the current url of the page.\n\n  Window.isActiveURL(\"https://www.example.com\")\n*/\nfun isActiveURL (url : String) : Bool {\n  let window =\n    Window.url()\n\n  let current =\n    Url.parse(url)\n\n  (window.hostname == current.hostname &&\n    window.protocol == current.protocol &&\n    window.origin == current.origin &&\n    window.path == current.path &&\n    window.host == current.host &&\n    window.port == current.port)\n}","arguments":[{"type":"String","name":"url"}]},{"type":"Promise(Void)","description":"<p>Like <code>Window.navigate()</code>, but also triggers a jump to the start of the\ndocument or the hash, if it exists.</p>\n<pre><code>Window.jump(&quot;/new-url&quot;)\n</code></pre>\n","name":"jump","source":"/*\nLike `Window.navigate()`, but also triggers a jump to the start of the\ndocument or the hash, if it exists.\n\n  Window.jump(\"/new-url\")\n*/\nfun jump (url : String) : Promise(Void) {\n  `_navigate(\n      #{url},\n      /* dispatch */ true,\n      /* triggerJump */ true,\n      /* routeInfo */ null\n    )`\n}","arguments":[{"type":"String","name":"url"}]},{"type":"Bool","description":"<p>Returns <code>true</code> if the given media query matches.</p>\n<pre><code>Window.matchesMediaQuery(&quot;(max-width: 320px)&quot;)\n</code></pre>\n","name":"matchesMediaQuery","source":"/*\nReturns `true` if the given media query matches.\n\n  Window.matchesMediaQuery(\"(max-width: 320px)\")\n*/\nfun matchesMediaQuery (query : String) : Bool {\n  `window.matchMedia(#{query}).matches`\n}","arguments":[{"type":"String","name":"query"}]},{"type":"Promise(Void)","description":"<p>Sets the URL of the window. If there is a route defined for this URL, runs\nits handler. Updates the navigation history.</p>\n<pre><code>Window.navigate(&quot;/new-url&quot;)\n</code></pre>\n","name":"navigate","source":"/*\nSets the URL of the window. If there is a route defined for this URL, runs\nits handler. Updates the navigation history.\n\n  Window.navigate(\"/new-url\")\n*/\nfun navigate (url : String) : Promise(Void) {\n  `_navigate(\n      #{url},\n      /* dispatch */ true,\n      /* triggerJump */ false,\n      /* routeInfo */ null\n    )`\n}","arguments":[{"type":"String","name":"url"}]},{"type":"Promise(Void)","description":"<p>Opens the given url in a new window or tab.</p>\n<pre><code>Window.open(&quot;https://www.google.com&quot;)\n</code></pre>\n","name":"open","source":"/*\nOpens the given url in a new window or tab.\n\n  Window.open(\"https://www.google.com\")\n*/\nfun open (url : String) : Promise(Void) {\n  `window.open(#{url})`\n}","arguments":[{"type":"String","name":"url"}]},{"type":"Promise(Maybe(String))","description":"<p>Shows the default prompt popup of the browser with the given message and\nvalue.</p>\n<p>This function returns the entered text as a <code>Maybe(String)</code> and blocks\nexecution until the popup is closed. If the user cancelled the popup it\nreturns <code>Maybe::Nothing</code>.</p>\n<pre><code>case (Window.prompt(&quot;How old are you?&quot;)) {\n  Maybe::Just(value) =&gt; Debug.log(value)\n  Maybe::Nothing =&gt; Debug.log(&quot;User cancelled&quot;)\n}\n</code></pre>\n","name":"prompt","source":"/*\nShows the default prompt popup of the browser with the given message and\nvalue.\n\nThis function returns the entered text as a `Maybe(String)` and blocks\nexecution until the popup is closed. If the user cancelled the popup it\nreturns `Maybe::Nothing`.\n\n  case (Window.prompt(\"How old are you?\")) {\n    Maybe::Just(value) => Debug.log(value)\n    Maybe::Nothing => Debug.log(\"User cancelled\")\n  }\n*/\nfun prompt (label : String, current : String = \"\") : Promise(Maybe(String)) {\n  `\n    new Promise((resolve) => {\n      let result = window.prompt(#{label}, #{current})\n\n      if (result !== null) {\n        resolve(#{Maybe::Just(`result`)})\n      } else {\n        resolve(#{Maybe::Nothing})\n      }\n    })\n    `\n}","arguments":[{"type":"String","name":"label"},{"type":"String","name":"current"}]},{"type":"Number","description":"<p>Returns the scrollable height of the window in pixels.</p>\n<pre><code>Window.scrollHeight() == 768\n</code></pre>\n","name":"scrollHeight","source":"/*\nReturns the scrollable height of the window in pixels.\n\n  Window.scrollHeight() == 768\n*/\nfun scrollHeight : Number {\n  `\n    (() => {\n      const body = document.body\n      const html = document.documentElement\n\n      return Math.max(\n        body.scrollHeight, html.scrollHeight,\n        body.offsetHeight, html.offsetHeight,\n        body.clientHeight, html.clientHeight\n      )\n    })()\n    `\n}","arguments":[]},{"type":"Number","description":"<p>Returns the horizontal scroll position of the window in pixels.</p>\n<pre><code>Window.scrollLeft() == 100\n</code></pre>\n","name":"scrollLeft","source":"/*\nReturns the horizontal scroll position of the window in pixels.\n\n  Window.scrollLeft() == 100\n*/\nfun scrollLeft : Number {\n  `window.pageXOffset`\n}","arguments":[]},{"type":"Number","description":"<p>Returns the vertical scroll position of the window in pixels.</p>\n<pre><code>Window.scrollTop() == 100\n</code></pre>\n","name":"scrollTop","source":"/*\nReturns the vertical scroll position of the window in pixels.\n\n  Window.scrollTop() == 100\n*/\nfun scrollTop : Number {\n  `window.pageYOffset`\n}","arguments":[]},{"type":"Number","description":"<p>Returns the scrollable width of the window in pixels.</p>\n<pre><code>Window.scrollWidth() == 1024\n</code></pre>\n","name":"scrollWidth","source":"/*\nReturns the scrollable width of the window in pixels.\n\n  Window.scrollWidth() == 1024\n*/\nfun scrollWidth : Number {\n  `\n    (() => {\n      const body = document.body\n      const html = document.documentElement\n\n      return Math.max(\n        body.scrollWidth, html.scrollWidth,\n        body.offsetWidth, html.offsetWidth,\n        body.clientWidth, html.clientWidth\n      )\n    })()\n    `\n}","arguments":[]},{"type":"Promise(Void)","description":"<p>Sets the vertical scroll position of the window in pixels.</p>\n<pre><code>Window.setScrollLeft(100)\n</code></pre>\n","name":"setScrollLeft","source":"/*\nSets the vertical scroll position of the window in pixels.\n\n  Window.setScrollLeft(100)\n*/\nfun setScrollLeft (position : Number) : Promise(Void) {\n  `window.scrollTo(#{position}, #{scrollTop()})`\n}","arguments":[{"type":"Number","name":"position"}]},{"type":"Promise(Void)","description":"<p>Sets the horizontal scroll position of the window in pixels.</p>\n<pre><code>Window.setScrollTop(100)\n</code></pre>\n","name":"setScrollTop","source":"/*\nSets the horizontal scroll position of the window in pixels.\n\n  Window.setScrollTop(100)\n*/\nfun setScrollTop (position : Number) : Promise(Void) {\n  `window.scrollTo(#{scrollLeft()}, #{position})`\n}","arguments":[{"type":"Number","name":"position"}]},{"type":"Promise(Void)","description":"<p>Sets the windows title.</p>\n<pre><code>Window.setTitle(&quot;New Title!&quot;)\n</code></pre>\n","name":"setTitle","source":"/*\nSets the windows title.\n\n  Window.setTitle(\"New Title!\")\n*/\nfun setTitle (title : String) : Promise(Void) {\n  `document.title = #{title}`\n}","arguments":[{"type":"String","name":"title"}]},{"type":"Promise(Void)","description":"<p>Sets the URL of the window.</p>\n<pre><code>Window.setUrl(&quot;/new-url&quot;)\n</code></pre>\n","name":"setUrl","source":"/*\nSets the URL of the window.\n\n  Window.setUrl(\"/new-url\")\n*/\nfun setUrl (url : String) : Promise(Void) {\n  `_navigate(\n      #{url},\n      /* dispatch */ false,\n      /* triggerJump */ false,\n      /* routeInfo */ null\n    )`\n}","arguments":[{"type":"String","name":"url"}]},{"type":"String","description":"<p>Returns the windows title.</p>\n<pre><code>Window.title() == &quot;Title!&quot;\n</code></pre>\n","name":"title","source":"/*\nReturns the windows title.\n\n  Window.title() == \"Title!\"\n*/\nfun title : String {\n  `document.title`\n}","arguments":[]},{"type":"Promise(Void)","description":"<p>Triggers a jump to the current location on the page.</p>\n<p>When a page loads and the current url has a hash <code>#anchor-name</code>, the browser\nautomatically jumps to the element with the matching id or to the anchor tag\nwith the matching name <code>&lt;a name=&quot;anchor-name&quot;&gt;</code>. This behavior does not happen\nwhen the history is manipulated manually.</p>\n<p>This function triggers that behavior. When there is a hash in the current URL,\nit jumps to it, otherwise it jumps to the start of the document.</p>\n","name":"triggerJump","source":"/*\nTriggers a jump to the current location on the page.\n\nWhen a page loads and the current url has a hash `#anchor-name`, the browser\nautomatically jumps to the element with the matching id or to the anchor tag\nwith the matching name `<a name=\"anchor-name\">`. This behavior does not happen\nwhen the history is manipulated manually.\n\nThis function triggers that behavior. When there is a hash in the current URL,\nit jumps to it, otherwise it jumps to the start of the document.\n*/\nfun triggerJump : Promise(Void) {\n  `requestAnimationFrame(() => {\n      if (window.location.hash) {\n        window.location.href = window.location.hash\n      } else {\n        window.scrollTo(0, 0)\n      }\n    })\n    `\n}","arguments":[]},{"type":"Url","description":"<p>Returns the current <code>Url</code> of the window.</p>\n<pre><code>Window.url().host == &quot;www.example.com&quot;\n</code></pre>\n","name":"url","source":"/*\nReturns the current `Url` of the window.\n\n  Window.url().host == \"www.example.com\"\n*/\nfun url : Url {\n  Url.parse(href())\n}","arguments":[]},{"type":"Number","description":"<p>Returns the width of the window in pixels.</p>\n<pre><code>Window.width == 1024\n</code></pre>\n","name":"width","source":"/*\nReturns the width of the window in pixels.\n\n  Window.width == 1024\n*/\nfun width : Number {\n  `window.innerWidth`\n}","arguments":[]}]}],"providers":[{"description":"<p>A provider for the <code>requestAnimationFrame</code> API.</p>\n","subscription":"Provider.AnimationFrame.Subscription","name":"Provider.AnimationFrame","functions":[{"type":"Promise(Void)","description":"<p>Call the subscribers.</p>\n","name":"process","source":"/* Call the subscribers. */\nfun process (timestamp : Number) : Promise(Void) {\n  for subscription of subscriptions {\n    subscription.frames(timestamp)\n  }\n\n  next { id: AnimationFrame.request(process) }\n}","arguments":[{"type":"Number","name":"timestamp"}]},{"type":"Promise(Void)","description":"<p>Updates the provider.</p>\n","name":"update","source":"/* Updates the provider. */\nfun update : Promise(Void) {\n  if Array.isEmpty(subscriptions) {\n    next { id: AnimationFrame.cancel(id) }\n  } else if id == -1 {\n    next { id: AnimationFrame.request(process) }\n  } else {\n    next { }\n  }\n}","arguments":[]}]},{"description":"<p>A provider which provides events when the size of the element changes.</p>\n","subscription":"Provider.ElementSize.Subscription","name":"Provider.ElementSize","functions":[{"type":"Array(Array(Promise(Void)))","description":"<p>Notifies all subscribers when there are changes.</p>\n","name":"notify","source":"/* Notifies all subscribers when there are changes. */\nfun notify (entries : Array(ResizeObserver.Entry)) : Array(Array(Promise(Void))) {\n  for entry of entries {\n    for subscription of subscriptions {\n      if subscription.element == Maybe.Just(entry.target) {\n        subscription.changes(entry.dimensions)\n      } else {\n        next { }\n      }\n    }\n  }\n}","arguments":[{"type":"Array(ResizeObserver.Entry)","name":"entries"}]},{"type":"Promise(Void)","description":"<p>Updates the provider.</p>\n","name":"update","source":"/* Updates the provider. */\nfun update : Promise(Void) {\n  for element of Array.compact(observedElements) {\n    ResizeObserver.unobserve(observer, element)\n  }\n\n  for subscription of subscriptions {\n    case subscription.element {\n      Maybe.Just(element) =>\n        {\n          ResizeObserver.observe(observer, element)\n          void\n        }\n\n      Maybe.Nothing => void\n    }\n  }\n\n  next\n    {\n      observedElements:\n        for subscription of subscriptions {\n          subscription.element\n        }\n    }\n}","arguments":[]}]},{"description":"<p>A provider to provide events when the given element is visible on the screen.</p>\n","subscription":"Provider.Intersection.Subscription","name":"Provider.Intersection","functions":[{"type":"Promise(Void)","description":"<p>Updates the provider.</p>\n","name":"update","source":"/* Updates the provider. */\nfun update : Promise(Void) {\n  /*\n  Gather all of the current observers, and remove ones that are no\n  longer present.\n  */\n  let currentObservers =\n    for item of observers {\n      let #(subscription, observer) =\n        item\n\n      if Array.contains(subscriptions, subscription) {\n        Maybe.Just(#(subscription, observer))\n      } else {\n        case subscription.element {\n          Maybe.Just(observed) =>\n            {\n              IntersectionObserver.unobserve(observer, observed)\n              Maybe.Nothing\n            }\n\n          => Maybe.Nothing\n        }\n      }\n    }\n    |> Array.compact()\n\n  /* Create new observers. */\n  let newObservers =\n    for subscription of subscriptions {\n      case subscription.element {\n        Maybe.Just(observed) =>\n          Maybe.Just(\n            #(\n              subscription,\n              IntersectionObserver.new(\n                subscription.rootMargin, \n                subscription.threshold, \n                subscription.callback)\n              |> IntersectionObserver.observe(observed)\n            ))\n\n        => Maybe.Nothing\n      }\n    } when {\n      let size =\n        observers\n        |> Array.select(\n          (\n            item : Tuple(Provider.Intersection.Subscription, IntersectionObserver)\n          ) {\n            item[0] == subscription\n          })\n        |> Array.size()\n\n      (size == 0)\n    }\n    |> Array.compact()\n\n  next { observers: Array.concat([currentObservers, newObservers]) }\n}","arguments":[]}]},{"description":"<p>A provider for global keyboard events.</p>\n","subscription":"Provider.Keyboard.Subscription","name":"Provider.Keyboard","functions":[{"type":"Promise(Void)","description":"<p>Updates the provider.</p>\n","name":"update","source":"/* Updates the provider. */\nfun update : Promise(Void) {\n  if Array.isEmpty(subscriptions) {\n    Maybe.map(\n      listeners, \n      (methods : Tuple(Function(Void), Function(Void))) {\n        let #(keydownListener, keyupListener) =\n          methods\n\n        keydownListener()\n        keyupListener()\n      })\n\n    next { listeners: Maybe.Nothing }\n  } else {\n    case listeners {\n      Maybe.Nothing =>\n        next\n          {\n            listeners:\n              Maybe.Just(\n                #(\n                  Window.addEventListener(\n                    \"keydown\", \n                    true, \n                    (event : Html.Event) {\n                      for subscription of subscriptions {\n                        subscription.downs(event)\n                      }\n                    }),\n                  Window.addEventListener(\n                    \"keyup\", \n                    true, \n                    (event : Html.Event) {\n                      for subscription of subscriptions {\n                        subscription.ups(event)\n                      }\n                    })\n                ))\n          }\n\n      => next { }\n    }\n  }\n}","arguments":[]}]},{"description":"<p>This provider sends changes when the given media query in the subscription\nchanges.</p>\n","subscription":"Provider.MediaQuery.Subscription","name":"Provider.MediaQuery","functions":[{"type":"Promise(Void)","description":null,"name":"update","source":"fun update : Promise(Void) {\n  let updatedListeners =\n    subscriptions\n    |> Array.reduce(\n      listeners, \n      (\n        memo : Map(String, Function(Void)),\n        subscription : Provider.MediaQuery.Subscription\n      ) {\n        case Map.get(listeners, subscription.query) {\n          Maybe.Nothing =>\n            Map.set(\n              memo, \n              subscription.query, \n              Window.addMediaQueryListener(\n                subscription.query, \n                (active : Bool) {\n                  for item of subscriptions {\n                    subscription.changes(active)\n                  } when {\n                    item.query == subscription.query\n                  }\n                }))\n\n          Maybe.Just => memo\n        }\n      })\n\n  let finalListeners =\n    updatedListeners\n    |> Map.reduce(\n      updatedListeners, \n      (\n        memo : Map(String, Function(Void)),\n        query : String,\n        listener : Function(Void)\n      ) {\n        let subscription =\n          subscriptions\n          |> Array.find(\n            (item : Provider.MediaQuery.Subscription) { item.query == query })\n\n        case subscription {\n          Maybe.Just => memo\n\n          Maybe.Nothing =>\n            {\n              listener()\n              Map.delete(memo, query)\n            }\n        }\n      })\n\n  next { listeners: finalListeners }\n}","arguments":[]}]},{"description":"<p>A provider for global mouse events.</p>\n","subscription":"Provider.Mouse.Subscription","name":"Provider.Mouse","functions":[{"type":"Promise(Void)","description":"<p>Updates the provider.</p>\n","name":"update","source":"/* Updates the provider. */\nfun update : Promise(Void) {\n  if Array.isEmpty(subscriptions) {\n    Maybe.map(\n      listeners, \n      (\n        methods : Tuple(Function(Void), Function(Void), Function(Void))\n      ) {\n        let #(clickListener, moveListener, upListener) =\n          methods\n\n        clickListener()\n        moveListener()\n        upListener()\n      })\n\n    next { listeners: Maybe.Nothing }\n  } else {\n    case listeners {\n      Maybe.Nothing =>\n        next\n          {\n            listeners:\n              Maybe.Just(\n                #(\n                  Window.addEventListener(\n                    \"click\", \n                    true, \n                    (event : Html.Event) {\n                      for subscription of subscriptions {\n                        subscription.clicks(event)\n                      }\n                    }),\n                  Window.addEventListener(\n                    \"mousemove\", \n                    false, \n                    (event : Html.Event) {\n                      AnimationFrame.cancel(id)\n\n                      next\n                        {\n                          id:\n                            AnimationFrame.request(\n                              (timestamp : Number) {\n                                for subscription of subscriptions {\n                                  subscription.moves(event)\n                                }\n                              })\n                        }\n                    }),\n                  Window.addEventListener(\n                    \"mouseup\", \n                    false, \n                    (event : Html.Event) {\n                      for subscription of subscriptions {\n                        subscription.ups(event)\n                      }\n                    })\n                ))\n          }\n\n      => next { }\n    }\n  }\n}","arguments":[]}]},{"description":"<p>A provider to provide events when the DOM structure of the given\nelement changes.</p>\n","subscription":"Provider.Mutation.Subscription","name":"Provider.Mutation","functions":[{"type":"Array(Array(Promise(Void)))","description":"<p>Notifies the subscribers when changes occur.</p>\n","name":"notify","source":"/* Notifies the subscribers when changes occur. */\nfun notify (entries : Array(MutationObserver.Entry)) : Array(Array(Promise(Void))) {\n  for entry of entries {\n    for subscription of subscriptions {\n      case subscription.element {\n        Maybe.Just(element) =>\n          if Dom.contains(element, entry.target) {\n            subscription.changes()\n          } else {\n            next { }\n          }\n\n        Maybe.Nothing => next { }\n      }\n    }\n  }\n}","arguments":[{"type":"Array(MutationObserver.Entry)","name":"entries"}]},{"type":"Promise(Void)","description":"<p>Updates the provider.</p>\n","name":"update","source":"/* Updates the provider. */\nfun update : Promise(Void) {\n  /* Unobserve all elements. */\n  for element of Array.compact(observedElements) {\n    MutationObserver.unobserve(observer, element)\n  }\n\n  /* For each subscription observe the given elements. */\n  for subscription of subscriptions {\n    case subscription.element {\n      Maybe.Just(element) =>\n        {\n          MutationObserver.observe(observer, element, true, true)\n          subscription.changes()\n        }\n\n      Maybe.Nothing => next { }\n    }\n  }\n\n  /* Update the observed elements array. */\n  next\n    {\n      observedElements:\n        for subscription of subscriptions {\n          subscription.element\n        }\n    }\n}","arguments":[]}]},{"description":"<p>A provider to provide events when clicking outside of the given element.</p>\n","subscription":"Provider.OutsideClick.Subscription","name":"Provider.OutsideClick","functions":[{"type":"Array(Promise(Void))","description":"<p>The event handler.</p>\n","name":"handle","source":"/* The event handler. */\nfun handle (event : Html.Event) : Array(Promise(Void)) {\n  for subscription of subscriptions {\n    let inside =\n      subscription.elements\n      |> Array.compact()\n      |> Array.any((item : Dom.Element) { Dom.contains(item, event.target) })\n\n    if inside {\n      Promise.never()\n    } else {\n      subscription.clicks()\n    }\n  }\n}","arguments":[{"type":"Html.Event","name":"event"}]},{"type":"Promise(Void)","description":"<p>Updates the provider.</p>\n","name":"update","source":"/* Updates the provider. */\nfun update : Promise(Void) {\n  if Array.isEmpty(subscriptions) {\n    Maybe.map(listener, (unsubscribe : Function(Void)) { unsubscribe() })\n    next { listener: Maybe.Nothing }\n  } else {\n    case listener {\n      Maybe.Nothing =>\n        next { listener: Maybe.Just(Window.addEventListener(\"mouseup\", true, handle)) }\n\n      => next { }\n    }\n  }\n}","arguments":[]}]},{"description":"<p>A provider for global Pointer events.</p>\n","subscription":"Provider.Pointer.Subscription","name":"Provider.Pointer","functions":[{"type":"Promise(Void)","description":"<p>Updates the provider.</p>\n","name":"update","source":"/* Updates the provider. */\nfun update : Promise(Void) {\n  if Array.isEmpty(subscriptions) {\n    Maybe.map(\n      listeners, \n      (\n        methods : Tuple(Function(Void), Function(Void), Function(Void))\n      ) {\n        let #(downListener, moveListener, upListener) =\n          methods\n\n        downListener()\n        moveListener()\n        upListener()\n      })\n\n    next { listeners: Maybe.Nothing }\n  } else {\n    case listeners {\n      Maybe.Nothing =>\n        next\n          {\n            listeners:\n              Maybe.Just(\n                #(\n                  Window.addEventListener(\n                    \"pointerdown\", \n                    true, \n                    (event : Html.Event) {\n                      for subscription of subscriptions {\n                        subscription.downs(event)\n                      }\n                    }),\n                  Window.addEventListener(\n                    \"pointermove\", \n                    false, \n                    (event : Html.Event) {\n                      AnimationFrame.cancel(id)\n\n                      next\n                        {\n                          id:\n                            AnimationFrame.request(\n                              (timestamp : Number) {\n                                for subscription of subscriptions {\n                                  subscription.moves(event)\n                                }\n                              })\n                        }\n                    }),\n                  Window.addEventListener(\n                    \"pointerup\", \n                    false, \n                    (event : Html.Event) {\n                      for subscription of subscriptions {\n                        subscription.ups(event)\n                      }\n                    })\n                ))\n          }\n\n      => next { }\n    }\n  }\n}","arguments":[]}]},{"description":"<p>A provider for handling changes of the viewport.</p>\n","subscription":"Provider.Resize.Subscription","name":"Provider.Resize","functions":[{"type":"Array(Promise(Void))","description":"<p>Handles the resize events.</p>\n","name":"handle","source":"/* Handles the resize events. */\nfun handle (event : Html.Event) : Array(Promise(Void)) {\n  for subscription of subscriptions {\n    subscription.resizes(event)\n  }\n}","arguments":[{"type":"Html.Event","name":"event"}]},{"type":"Promise(Void)","description":"<p>Updates the provider.</p>\n","name":"update","source":"/* Updates the provider. */\nfun update : Promise(Void) {\n  if Array.isEmpty(subscriptions) {\n    Maybe.map(listener, (unsubscribe : Function(Void)) { unsubscribe() })\n    next { listener: Maybe.Nothing }\n  } else {\n    case listener {\n      Maybe.Nothing =>\n        next { listener: Maybe.Just(Window.addEventListener(\"resize\", true, handle)) }\n\n      => next { }\n    }\n  }\n}","arguments":[]}]},{"description":"<p>A provider for global scroll events.</p>\n","subscription":"Provider.Scroll.Subscription","name":"Provider.Scroll","functions":[{"type":"Array(Promise(Void))","description":"<p>Handles the scroll events.</p>\n","name":"handle","source":"/* Handles the scroll events. */\nfun handle (event : Html.Event) : Array(Promise(Void)) {\n  for subscription of subscriptions {\n    subscription.scrolls(event)\n  }\n}","arguments":[{"type":"Html.Event","name":"event"}]},{"type":"Promise(Void)","description":"<p>Updates the provider.</p>\n","name":"update","source":"/* Updates the provider. */\nfun update : Promise(Void) {\n  if Array.isEmpty(subscriptions) {\n    Maybe.map(listener, (unsubscribe : Function(Void)) { unsubscribe() })\n    next { listener: Maybe.Nothing }\n  } else {\n    case listener {\n      Maybe.Nothing =>\n        next { listener: Maybe.Just(Window.addEventListener(\"scroll\", false, handle)) }\n\n      => next { }\n    }\n  }\n}","arguments":[]}]},{"description":"<p>This provider allows components to subscribe to global shortcuts.</p>\n","subscription":"Provider.Shortcuts.Subscription","name":"Provider.Shortcuts","functions":[{"type":"Array(Array(Promise(Void)))","description":"<p>Handles keypress events.</p>\n","name":"handle","source":"/* Handles keypress events. */\nfun handle (event : Html.Event) : Array(Array(Promise(Void))) {\n  let control =\n    if event.ctrlKey && event.keyCode != 17 {\n      Maybe.Just(17)\n    } else {\n      Maybe.Nothing\n    }\n\n  let shift =\n    if event.shiftKey && event.keyCode != 16 {\n      Maybe.Just(16)\n    } else {\n      Maybe.Nothing\n    }\n\n  let combo =\n    [Maybe.Just(event.keyCode), control, shift]\n    |> Array.compact()\n    |> Array.sortBy((item : Number) { item })\n\n  let focused =\n    `document.querySelector(\"*:focus\")`\n\n  for subscription of subscriptions {\n    for item of subscription.shortcuts {\n      Html.Event.stopPropagation(event)\n      Html.Event.preventDefault(event)\n      item.action()\n    } when {\n      let sorted =\n        item.shortcut\n        |> Array.sortBy((item : Number) : Number { item })\n\n      (sorted == combo && item.condition()) && (!focused || item.bypassFocused)\n    }\n  }\n}","arguments":[{"type":"Html.Event","name":"event"}]},{"type":"Promise(Void)","description":"<p>Updates the provider.</p>\n","name":"update","source":"/* Updates the provider. */\nfun update : Promise(Void) {\n  if Array.isEmpty(subscriptions) {\n    Maybe.map(listener, (unsubscribe : Function(Void)) { unsubscribe() })\n    next { listener: Maybe.Nothing }\n  } else {\n    case listener {\n      Maybe.Nothing =>\n        next { listener: Maybe.Just(Window.addEventListener(\"keydown\", true, handle)) }\n\n      => next { }\n    }\n  }\n}","arguments":[]}]},{"description":"<p>A provider for periodic updates (every 1 seconds).</p>\n","subscription":"Provider.Tick.Subscription","name":"Provider.Tick","functions":[{"type":"Array(Promise(Void))","description":"<p>Call the subscribers.</p>\n","name":"process","source":"/* Call the subscribers. */\nfun process : Array(Promise(Void)) {\n  for subscription of subscriptions {\n    subscription.ticks()\n  }\n}","arguments":[]},{"type":"Promise(Void)","description":"<p>Attaches the provider.</p>\n","name":"update","source":"/* Attaches the provider. */\nfun update : Promise(Void) {\n  if Array.isEmpty(subscriptions) {\n    next { id: `clearInterval(#{id}) || -1` }\n  } else if id == -1 {\n    next { id: `setInterval(#{process}, 1000)` }\n  } else {\n    next { }\n  }\n}","arguments":[]}]},{"description":"<p>A provider for global &quot;popstate&quot; events, which emit the current URL.</p>\n","subscription":"Provider.Url.Subscription","name":"Provider.Url","functions":[{"type":"Array(Promise(Void))","description":"<p>The event handler.</p>\n","name":"handle","source":"/* The event handler. */\nfun handle (event : Html.Event) : Array(Promise(Void)) {\n  let url =\n    Window.url()\n\n  for subscription of subscriptions {\n    subscription.changes(url)\n  }\n}","arguments":[{"type":"Html.Event","name":"event"}]},{"type":"Promise(Void)","description":"<p>Updates the provider.</p>\n","name":"update","source":"/* Updates the provider. */\nfun update : Promise(Void) {\n  if Array.isEmpty(subscriptions) {\n    Maybe.map(listener, (unsubscribe : Function(Void)) { unsubscribe() })\n    next { listener: Maybe.Nothing }\n  } else {\n    case listener {\n      Maybe.Nothing =>\n        next { listener: Maybe.Just(Window.addEventListener(\"popstate\", false, handle)) }\n\n      => next { }\n    }\n  }\n}","arguments":[]}]},{"description":"<p>Provider to handle websocket connections.</p>\n","subscription":"WebSocket.Config","name":"Provider.WebSocket","functions":[{"type":"Promise(Void)","description":"<p>Handles the open event.</p>\n","name":"onOpen","source":"/* Handles the open event. */\nfun onOpen (url : String, socket : WebSocket) : Promise(Void) {\n  for subscription of subscriptions {\n    subscription.onOpen(socket)\n  } when {\n    subscription.url == url\n  }\n\n  next { }\n}","arguments":[{"type":"String","name":"url"},{"type":"WebSocket","name":"socket"}]},{"type":"Promise(Void)","description":"<p>Handles the message event.</p>\n","name":"onMessage","source":"/* Handles the message event. */\nfun onMessage (url : String, data : String) : Promise(Void) {\n  for subscription of subscriptions {\n    subscription.onMessage(data)\n  } when {\n    subscription.url == url\n  }\n\n  next { }\n}","arguments":[{"type":"String","name":"url"},{"type":"String","name":"data"}]},{"type":"Promise(Void)","description":"<p>Handles the error event.</p>\n","name":"onError","source":"/* Handles the error event. */\nfun onError (url : String) : Promise(Void) {\n  for subscription of subscriptions {\n    subscription.onError()\n  } when {\n    subscription.url == url\n  }\n\n  next { }\n}","arguments":[{"type":"String","name":"url"}]},{"type":"Promise(Void)","description":"<p>Handles the close event.</p>\n","name":"onClose","source":"/* Handles the close event. */\nfun onClose (url : String) : Promise(Void) {\n  for subscription of subscriptions {\n    subscription.onClose()\n  } when {\n    subscription.url == url\n  }\n\n  next { }\n}","arguments":[{"type":"String","name":"url"}]},{"type":"Promise(Void)","description":"<p>Handles updates to the provider.</p>\n","name":"update","source":"/* Handles updates to the provider. */\nfun update : Promise(Void) {\n  let updatedConnections =\n    subscriptions\n    |> Array.reduce(\n      connections, \n      (\n        memo : Map(String, WebSocket),\n        config : WebSocket.Config\n      ) {\n        case Map.get(connections, config.url) {\n          Maybe.Nothing =>\n            Map.set(\n              memo, \n              config.url, \n              WebSocket.open(\n                {\n                  onMessage: (message : String) { onMessage(config.url, message) },\n                  onOpen: (socket : WebSocket) { onOpen(config.url, socket) },\n                  onClose: () { onClose(config.url) },\n                  onError: () { onError(config.url) },\n                  reconnectOnClose: config.reconnectOnClose,\n                  url: config.url\n                }))\n\n          Maybe.Just => memo\n        }\n      })\n\n  let finalConnections =\n    updatedConnections\n    |> Map.reduce(\n      updatedConnections, \n      (\n        memo : Map(String, WebSocket),\n        url : String,\n        socket : WebSocket\n      ) {\n        let subscription =\n          subscriptions\n          |> Array.find(\n            (config : WebSocket.Config) { config.url == url })\n\n        case subscription {\n          Maybe.Nothing =>\n            {\n              WebSocket.closeWithoutReconnecting(socket)\n              Map.delete(memo, url)\n            }\n\n          Maybe.Just => memo\n        }\n      })\n\n  next { connections: finalConnections }\n}","arguments":[]}]},{"description":"<p>A provider to provide the tab in and tab out events for an element.</p>\n","subscription":"Provider.TabFocus.Subscription","name":"Providers.TabFocus","functions":[{"type":"Array(Promise(Void))","description":"<p>The <code>keyUp</code> event handler.</p>\n","name":"handleKeyUp","source":"/* The `keyUp` event handler. */\nfun handleKeyUp (event : Html.Event) : Array(Promise(Void)) {\n  if event.keyCode == Html.Event.TAB {\n    let activeElement =\n      Dom.getActiveElement()\n\n    for subscription of subscriptions {\n      subscription.onTabIn()\n    } when {\n      subscription.element == activeElement\n    }\n  } else {\n    []\n  }\n}","arguments":[{"type":"Html.Event","name":"event"}]},{"type":"Array(Promise(Void))","description":"<p>The <code>keyDown</code> event handler.</p>\n","name":"handleKeyDown","source":"/* The `keyDown` event handler. */\nfun handleKeyDown (event : Html.Event) : Array(Promise(Void)) {\n  if event.keyCode == Html.Event.TAB {\n    let target =\n      Maybe.Just(event.target)\n\n    for subscription of subscriptions {\n      subscription.onTabOut()\n    } when {\n      subscription.element == target\n    }\n  } else {\n    []\n  }\n}","arguments":[{"type":"Html.Event","name":"event"}]},{"type":"Promise(Void)","description":"<p>Updates the provider.</p>\n","name":"update","source":"/* Updates the provider. */\nfun update : Promise(Void) {\n  if Array.isEmpty(subscriptions) {\n    Maybe.map(\n      listeners, \n      (methods : Tuple(Function(Void), Function(Void))) {\n        let #(keyDownListener, keyUpListener) =\n          methods\n\n        keyDownListener()\n        keyUpListener()\n      })\n\n    next { listeners: Maybe.Nothing }\n  } else {\n    case listeners {\n      Maybe.Nothing =>\n        next\n          {\n            listeners:\n              Maybe.Just(\n                #(\n                  Window.addEventListener(\"keydown\", true, handleKeyDown),\n                  Window.addEventListener(\"keyup\", true, handleKeyUp)\n                ))\n          }\n\n      => next { }\n    }\n  }\n}","arguments":[]}]}],"records":[{"description":"<p>Record for the dimensions of an element on the screen.</p>\n","name":"Dom.Dimensions","fields":[{"key":"height","type":"Number","mapping":null},{"key":"bottom","type":"Number","mapping":null},{"key":"width","type":"Number","mapping":null},{"key":"right","type":"Number","mapping":null},{"key":"left","type":"Number","mapping":null},{"key":"top","type":"Number","mapping":null},{"key":"x","type":"Number","mapping":null},{"key":"y","type":"Number","mapping":null}]},{"description":"<p>Represents an HTML event.</p>\n","name":"Html.Event","fields":[{"key":"bubbles","type":"Bool","mapping":null},{"key":"cancelable","type":"Bool","mapping":null},{"key":"currentTarget","type":"Dom.Element","mapping":null},{"key":"defaultPrevented","type":"Bool","mapping":null},{"key":"dataTransfer","type":"Html.DataTransfer","mapping":null},{"key":"clipboardData","type":"Html.DataTransfer","mapping":null},{"key":"eventPhase","type":"Number","mapping":null},{"key":"isTrusted","type":"Bool","mapping":null},{"key":"target","type":"Dom.Element","mapping":null},{"key":"timeStamp","type":"Number","mapping":null},{"key":"type","type":"String","mapping":null},{"key":"data","type":"String","mapping":null},{"key":"altKey","type":"Bool","mapping":null},{"key":"charCode","type":"Number","mapping":null},{"key":"ctrlKey","type":"Bool","mapping":null},{"key":"key","type":"String","mapping":null},{"key":"keyCode","type":"Number","mapping":null},{"key":"locale","type":"String","mapping":null},{"key":"location","type":"Number","mapping":null},{"key":"metaKey","type":"Bool","mapping":null},{"key":"repeat","type":"Bool","mapping":null},{"key":"shiftKey","type":"Bool","mapping":null},{"key":"which","type":"Number","mapping":null},{"key":"button","type":"Number","mapping":null},{"key":"buttons","type":"Number","mapping":null},{"key":"clientX","type":"Number","mapping":null},{"key":"clientY","type":"Number","mapping":null},{"key":"pageX","type":"Number","mapping":null},{"key":"pageY","type":"Number","mapping":null},{"key":"screenX","type":"Number","mapping":null},{"key":"screenY","type":"Number","mapping":null},{"key":"detail","type":"Number","mapping":null},{"key":"deltaMode","type":"Number","mapping":null},{"key":"deltaX","type":"Number","mapping":null},{"key":"deltaY","type":"Number","mapping":null},{"key":"deltaZ","type":"Number","mapping":null},{"key":"animationName","type":"String","mapping":null},{"key":"pseudoElement","type":"String","mapping":null},{"key":"propertyName","type":"String","mapping":null},{"key":"elapsedTime","type":"Number","mapping":null},{"key":"event","type":"Html.NativeEvent","mapping":null}]},{"description":"<p>Represents the possible failures of an HTTP request.</p>\n","name":"Http.Error","fields":[{"description":"<p>The request cannot be loaded because of a network failure</p>\n","name":"NetworkError","parameters":[]},{"description":"<p>The client (browser) aborted the request</p>\n","name":"Aborted","parameters":[]},{"description":"<p>The request timed out</p>\n","name":"Timeout","parameters":[]},{"description":"<p>The url is malformed and cannot be loaded</p>\n","name":"BadUrl","parameters":[]}]},{"description":"<p>Represents an HTTP request which failed to load.</p>\n","name":"Http.ErrorResponse","fields":[{"key":"headers","type":"Map(String, String)","mapping":null},{"key":"type","type":"Http.Error","mapping":null},{"key":"status","type":"Number","mapping":null},{"key":"url","type":"String","mapping":null}]},{"description":"<p>Represents a HTTP header</p>\n","name":"Http.Header","fields":[{"key":"value","type":"String","mapping":null},{"key":"key","type":"String","mapping":null}]},{"description":"<p>Represents an HTTP request.</p>\n","name":"Http.Request","fields":[{"key":"headers","type":"Array(Http.Header)","mapping":null},{"key":"withCredentials","type":"Bool","mapping":null},{"key":"body","type":"Http.Body","mapping":null},{"key":"method","type":"String","mapping":null},{"key":"url","type":"String","mapping":null}]},{"description":"<p>Represents an HTTP response.</p>\n","name":"Http.Response","fields":[{"key":"headers","type":"Map(String, String)","mapping":null},{"key":"body","type":"Http.ResponseBody","mapping":null},{"key":"bodyString","type":"String","mapping":null},{"key":"status","type":"Number","mapping":null}]},{"description":"<p>Represents the body of a HTTP response.</p>\n","name":"Http.ResponseBody","fields":[{"description":null,"name":"JSON","parameters":["Object"]},{"description":null,"name":"HTML","parameters":["Object"]},{"description":null,"name":"Text","parameters":["String"]},{"description":null,"name":"XML","parameters":["Object"]},{"description":null,"name":"File","parameters":["File"]}]},{"description":"<p>The data structure for Maybe.</p>\n","name":"Maybe","fields":[{"description":null,"name":"Just","parameters":["value"]},{"description":null,"name":"Nothing","parameters":[]}]},{"description":"<p>Represents a month of the week in the Gregorian calendar.</p>\n","name":"Month","fields":[{"description":null,"name":"January","parameters":[]},{"description":null,"name":"February","parameters":[]},{"description":null,"name":"March","parameters":[]},{"description":null,"name":"April","parameters":[]},{"description":null,"name":"May","parameters":[]},{"description":null,"name":"June","parameters":[]},{"description":null,"name":"July","parameters":[]},{"description":null,"name":"August","parameters":[]},{"description":null,"name":"September","parameters":[]},{"description":null,"name":"October","parameters":[]},{"description":null,"name":"November","parameters":[]},{"description":null,"name":"December","parameters":[]}]},{"description":null,"name":"MutationObserver.Entry","fields":[{"key":"target","type":"Dom.Element","mapping":null},{"key":"type","type":"String","mapping":null}]},{"description":"<p>Represents a subscription for <code>Provider.AnimationFrame</code></p>\n","name":"Provider.AnimationFrame.Subscription","fields":[{"key":"frames","type":"Function(Number, Promise(Void))","mapping":null}]},{"description":"<p>Represents a subscription for <code>Provider.ElementSize</code></p>\n","name":"Provider.ElementSize.Subscription","fields":[{"key":"changes","type":"Function(Dom.Dimensions, Promise(Void))","mapping":null},{"key":"element","type":"Maybe(Dom.Element)","mapping":null}]},{"description":"<p>Represents a subscription for <code>Provider.Intersection</code></p>\n","name":"Provider.Intersection.Subscription","fields":[{"key":"callback","type":"Function(Number, Promise(Void))","mapping":null},{"key":"element","type":"Maybe(Dom.Element)","mapping":null},{"key":"rootMargin","type":"String","mapping":null},{"key":"threshold","type":"Number","mapping":null}]},{"description":"<p>Represents a subscription for <code>Provider.Keyboard</code></p>\n","name":"Provider.Keyboard.Subscription","fields":[{"key":"downs","type":"Function(Html.Event, Promise(Void))","mapping":null},{"key":"ups","type":"Function(Html.Event, Promise(Void))","mapping":null}]},{"description":"<p>Represents a subscription for <code>Provider.MediaQuery</code></p>\n","name":"Provider.MediaQuery.Subscription","fields":[{"key":"changes","type":"Function(Bool, Promise(Void))","mapping":null},{"key":"query","type":"String","mapping":null}]},{"description":"<p>Represents a subscription for <code>Provider.Mouse</code></p>\n","name":"Provider.Mouse.Subscription","fields":[{"key":"clicks","type":"Function(Html.Event, Promise(Void))","mapping":null},{"key":"moves","type":"Function(Html.Event, Promise(Void))","mapping":null},{"key":"ups","type":"Function(Html.Event, Promise(Void))","mapping":null}]},{"description":"<p>Represents a subscription for <code>Provider.Mutation</code></p>\n","name":"Provider.Mutation.Subscription","fields":[{"key":"changes","type":"Function(Promise(Void))","mapping":null},{"key":"element","type":"Maybe(Dom.Element)","mapping":null}]},{"description":"<p>Represents a subscription for <code>Provider.OutsideClick</code></p>\n","name":"Provider.OutsideClick.Subscription","fields":[{"key":"clicks","type":"Function(Promise(Void))","mapping":null},{"key":"elements","type":"Array(Maybe(Dom.Element))","mapping":null}]},{"description":"<p>Represents a subscription for <code>Provider.Pointer</code></p>\n","name":"Provider.Pointer.Subscription","fields":[{"key":"downs","type":"Function(Html.Event, Promise(Void))","mapping":null},{"key":"moves","type":"Function(Html.Event, Promise(Void))","mapping":null},{"key":"ups","type":"Function(Html.Event, Promise(Void))","mapping":null}]},{"description":"<p>Represents a subscription for <code>Provider.Resize</code></p>\n","name":"Provider.Resize.Subscription","fields":[{"key":"resizes","type":"Function(Html.Event, Promise(Void))","mapping":null}]},{"description":"<p>Represents a subscription for <code>Provider.Scroll</code></p>\n","name":"Provider.Scroll.Subscription","fields":[{"key":"scrolls","type":"Function(Html.Event, Promise(Void))","mapping":null}]},{"description":"<p>Represents a shortcut:</p>\n<ul>\n<li><strong>action</strong> - the function to execute when the shortcut is pressed</li>\n<li><strong>condition</strong> - the function that evaluates if the action should be called</li>\n<li><strong>shortcut</strong> - the array of <strong>keyCodes</strong> that needs to be matched.</li>\n<li><strong>bypassFocused</strong> - whether or not trigger the action if something is in focus</li>\n</ul>\n","name":"Provider.Shortcuts.Shortcut","fields":[{"key":"action","type":"Function(Promise(Void))","mapping":null},{"key":"condition","type":"Function(Bool)","mapping":null},{"key":"shortcut","type":"Array(Number)","mapping":null},{"key":"bypassFocused","type":"Bool","mapping":null}]},{"description":"<p>Record for <code>Provider.Shortcuts</code>.</p>\n","name":"Provider.Shortcuts.Subscription","fields":[{"key":"shortcuts","type":"Array(Provider.Shortcuts.Shortcut)","mapping":null}]},{"description":"<p>Represents a subscription for <code>Provider.TabFocus</code></p>\n","name":"Provider.TabFocus.Subscription","fields":[{"key":"onTabOut","type":"Function(Promise(Void))","mapping":null},{"key":"onTabIn","type":"Function(Promise(Void))","mapping":null},{"key":"element","type":"Maybe(Dom.Element)","mapping":null}]},{"description":"<p>Represents a subscription for <code>Provider.Tick</code></p>\n","name":"Provider.Tick.Subscription","fields":[{"key":"ticks","type":"Function(Promise(Void))","mapping":null}]},{"description":"<p>Represents a subscription for <code>Provider.Url</code></p>\n","name":"Provider.Url.Subscription","fields":[{"key":"changes","type":"Function(Url, Promise(Void))","mapping":null}]},{"description":"<p>Represents a regular expression match.</p>\n","name":"Regexp.Match","fields":[{"key":"submatches","type":"Array(String)","mapping":null},{"key":"match","type":"String","mapping":null},{"key":"index","type":"Number","mapping":null}]},{"description":"<p>Represents the options for a regular expression.</p>\n","name":"Regexp.Options","fields":[{"key":"caseInsensitive","type":"Bool","mapping":null},{"key":"multiline","type":"Bool","mapping":null},{"key":"unicode","type":"Bool","mapping":null},{"key":"global","type":"Bool","mapping":null},{"key":"sticky","type":"Bool","mapping":null}]},{"description":null,"name":"ResizeObserver.Entry","fields":[{"key":"dimensions","type":"Dom.Dimensions","mapping":null},{"key":"target","type":"Dom.Element","mapping":null}]},{"description":null,"name":"Result","fields":[{"description":null,"name":"Err","parameters":["error"]},{"description":null,"name":"Ok","parameters":["value"]}]},{"description":"<p>Represents the possible failures when dealing with the <code>Storage</code> API.</p>\n","name":"Storage.Error","fields":[{"description":"<p>The storage API is disabled.</p>\n","name":"SecurityError","parameters":[]},{"description":"<p>The storage is full (over the quota, usually 5MB).</p>\n","name":"QuotaExceeded","parameters":[]},{"description":"<p>The key in the storage does not exist.</p>\n","name":"NotFound","parameters":[]},{"description":"<p>The reason for the failure is unknown.</p>\n","name":"Unknown","parameters":[]}]},{"description":"<p>Represents a language for time formatting.</p>\n","name":"Time.Format.Language","fields":[{"key":"toOrdinalSuffix","type":"Function(Number, String)","mapping":null},{"key":"toMonthName","type":"Function(Month, String)","mapping":null},{"key":"toMonthAbbreviation","type":"Function(Month, String)","mapping":null},{"key":"toWeekdayName","type":"Function(Weekday, String)","mapping":null},{"key":"toWeekdayAbbreviation","type":"Function(Weekday, String)","mapping":null},{"key":"amPm","type":"Function(Number, String)","mapping":null},{"key":"someSecondsAgo","type":"Function(Number, String)","mapping":null},{"key":"someMinutesAgo","type":"Function(Number, String)","mapping":null},{"key":"someHoursAgo","type":"Function(Number, String)","mapping":null},{"key":"someDaysAgo","type":"Function(Number, String)","mapping":null},{"key":"someMonthsAgo","type":"Function(Number, String)","mapping":null},{"key":"someYearsAgo","type":"Function(Number, String)","mapping":null},{"key":"inSomeSeconds","type":"Function(Number, String)","mapping":null},{"key":"inSomeMinutes","type":"Function(Number, String)","mapping":null},{"key":"inSomeHours","type":"Function(Number, String)","mapping":null},{"key":"inSomeDays","type":"Function(Number, String)","mapping":null},{"key":"inSomeMonths","type":"Function(Number, String)","mapping":null},{"key":"inSomeYears","type":"Function(Number, String)","mapping":null},{"key":"rightNow","type":"String","mapping":null}]},{"description":"<p>Represents a duration (span) of time.</p>\n","name":"Time.Span","fields":[{"description":null,"name":"Milliseconds","parameters":["Number"]},{"description":null,"name":"Seconds","parameters":["Number"]},{"description":null,"name":"Minutes","parameters":["Number"]},{"description":null,"name":"Hours","parameters":["Number"]},{"description":null,"name":"Days","parameters":["Number"]},{"description":null,"name":"Weeks","parameters":["Number"]},{"description":null,"name":"Months","parameters":["Number"]},{"description":null,"name":"Years","parameters":["Number"]}]},{"description":"<p>Represents a URL</p>\n","name":"Url","fields":[{"key":"hostname","type":"String","mapping":null},{"key":"protocol","type":"String","mapping":null},{"key":"origin","type":"String","mapping":null},{"key":"search","type":"String","mapping":null},{"key":"path","type":"String","mapping":null},{"key":"hash","type":"String","mapping":null},{"key":"host","type":"String","mapping":null},{"key":"port","type":"String","mapping":null}]},{"description":null,"name":"WebSocket.Config","fields":[{"key":"onOpen","type":"Function(WebSocket, Promise(Void))","mapping":null},{"key":"onMessage","type":"Function(String, Promise(Void))","mapping":null},{"key":"onError","type":"Function(Promise(Void))","mapping":null},{"key":"onClose","type":"Function(Promise(Void))","mapping":null},{"key":"reconnectOnClose","type":"Bool","mapping":null},{"key":"url","type":"String","mapping":null}]},{"description":"<p>Represents a day of the week in the Gregorian calendar.</p>\n","name":"Weekday","fields":[{"description":null,"name":"Monday","parameters":[]},{"description":null,"name":"Tuesday","parameters":[]},{"description":null,"name":"Wednesday","parameters":[]},{"description":null,"name":"Thursday","parameters":[]},{"description":null,"name":"Friday","parameters":[]},{"description":null,"name":"Saturday","parameters":[]},{"description":null,"name":"Sunday","parameters":[]}]}]}